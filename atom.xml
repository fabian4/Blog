<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fabian Bao</title>
  
  <subtitle>for Knowledge</subtitle>
  <link href="https://fabian4.site/blog/atom.xml" rel="self"/>
  
  <link href="https://fabian4.site/blog/"/>
  <updated>2022-08-24T07:47:19.054Z</updated>
  <id>https://fabian4.site/blog/</id>
  
  <author>
    <name>Fabian Bao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mysql 执行流程和日志系统</title>
    <link href="https://fabian4.site/blog/55079.html"/>
    <id>https://fabian4.site/blog/55079.html</id>
    <published>2021-05-14T16:00:00.000Z</published>
    <updated>2022-08-24T07:47:19.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql-执行流程和日志系统"><a href="#Mysql-执行流程和日志系统" class="headerlink" title="Mysql 执行流程和日志系统"></a>Mysql 执行流程和日志系统</h1><h2 id="一、Mysql-逻辑架构"><a href="#一、Mysql-逻辑架构" class="headerlink" title="一、Mysql 逻辑架构"></a>一、Mysql 逻辑架构</h2><p>这里先拿一张图来简单说明一下</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20211018095608297.png" alt="image-20211018095608297"></p><ul><li>客户端层：<br> 负责连接处理、授权认证、安全服务等功能的处理</li><li>核心服务层：<br> 查询解析、分析、优化、调用内置函数等等。所有的跨存储引擎功能也在这一层实现：存储过程、触发器、视图等等</li><li>存储引擎：<br> 负责MySQL中的数据存储和提取。中间的服务层通过API与存储引擎通信，屏蔽了不同存储引擎实现上的差异</li></ul><h2 id="二、执行流程"><a href="#二、执行流程" class="headerlink" title="二、执行流程"></a>二、执行流程</h2><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20211018100726996.png" alt="image-20211018100726996"></p><h3 id="1-客户端-x2F-服务端通信协议"><a href="#1-客户端-x2F-服务端通信协议" class="headerlink" title="1. 客户端&#x2F;服务端通信协议"></a>1. 客户端&#x2F;服务端通信协议</h3><ul><li><p>在任一时刻， 要么是服务器向客户端发送数据，要么是客户端向服务器发送数据，这两个动作不能同时发生。  </p></li><li><p>一旦一端开始发送消息，另一端要接收完整个消息才能响应它。  </p></li><li><p>服务端响应客户端请求时，客户端必须接收整个返回结果。</p><blockquote><p>因此在实际开发中，应该尽量保持查询简单且只返回必须的数据，这也是查询中尽量避免使用 <code>SELECT *</code> 和 <code>LIMIT</code> 的原因之一。</p></blockquote></li></ul><h3 id="2-查询缓存"><a href="#2-查询缓存" class="headerlink" title="2. 查询缓存"></a>2. 查询缓存</h3><ul><li><p>在查询缓存打开的情况下，解析一个查询语句的时候，MySQL会先检查这个查询缓存是否命中查询缓存中的数据。</p><p>  <strong>如果当前查询恰好命中查询缓存，在检查用户权限之后，会直接返回缓存中的结果，这种情况下查询不会被解析，不会生成执行计划，更不会执行。</strong>  </p></li><li><p>MySQL将缓存存放在一个引用表（类似于HashMap的数据结构），通过一个哈希值索引，这个哈希值通过查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息计算得来。</p><p>  <strong>所以两个查询在任何字符上的不同（例如：空格、注释），都会导致缓存不会命中。</strong>  </p></li><li><p><strong>如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、mysql库中的系统表，其查询结果都不会被缓存。</strong>因为同一个函数调用返回的结果可能不同(如 <code>NOW()</code> <code>CURRENT_USER</code>等)，这样的查询结果缓存起来没有意义。</p></li></ul><h4 id="是缓存，就会失效，那查询缓存何时失效呢？"><a href="#是缓存，就会失效，那查询缓存何时失效呢？" class="headerlink" title="是缓存，就会失效，那查询缓存何时失效呢？"></a>是缓存，就会失效，那查询缓存何时失效呢？</h4><p>系统会跟踪查询中涉及的每个表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。</p><blockquote><p>正因为如此，在任何的写操作时，MySQL必须将对应表的所有缓存都设置为失效。如果查询缓存非常大或者碎片很多，这个操作就可能带来很大的系统消耗。</p></blockquote><h4 id="除了写操作，读操作也会造成系统消耗："><a href="#除了写操作，读操作也会造成系统消耗：" class="headerlink" title="除了写操作，读操作也会造成系统消耗："></a>除了写操作，读操作也会造成系统消耗：</h4><ol><li>任何的查询语句在开始之前都必须经过检查，即使这条SQL语句永远不会命中缓存</li><li>如果查询结果可以被缓存，那么执行完成后，会将结果存入缓存，也会带来额外的系统消耗</li></ol><p>基于此，我们要知道并不是什么情况下查询缓存都会提高系统性能，缓存和失效都会带来额外消耗，只有当缓存带来的资源节约大于其本身消耗的资源时，才会给系统带来性能提升。</p><blockquote><p>如果系统确实存在一些性能问题，可以尝试打开查询缓存，并在数据库设计上做一些优化，比如：</p><ul><li>用多个小表代替一个大表，注意不要过度设计</li><li>批量插入代替循环单条插入</li><li>合理控制缓存空间大小，一般来说其大小设置为几十兆比较合适</li><li>可以通过SQL_CACHE和SQL_NO_CACHE来控制某个查询语句是否需要进行缓存</li></ul></blockquote><h3 id="3-语法解析和查询优化"><a href="#3-语法解析和查询优化" class="headerlink" title="3. 语法解析和查询优化"></a>3. 语法解析和查询优化</h3><p>根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p><p>如果你的语句不对，就会收到“You have an error in your SQL syntax”的错误提醒</p><p>MySQL的查询优化器是一个非常复杂的部件，它使用了非常多的优化策略来生成一个最优的执行计划：</p><ul><li>重新定义表的关联顺序（多张表关联查询时，并不一定按照SQL中指定的顺序进行，但有一些技巧可以指定关联顺序）</li><li>优化MIN()和MAX()函数（找某列的最小值，如果该列有索引，只需要查找B+Tree索引最左端，反之则可以找到最大值）</li><li>提前终止查询（比如：使用Limit时，查找到满足数量的结果集后会立即终止查询）</li><li>优化排序（在老版本MySQL会使用两次传输排序，即先读取行指针和需要排序的字段在内存中对其排序，然后再根据排序结果去读取数据行，而新版本采用的是单次传输排序，也就是一次读取所有的数据行，然后根据给定的列排序。对于I&#x2F;O密集型应用，效率会高很多）</li></ul><h3 id="4-执行引擎"><a href="#4-执行引擎" class="headerlink" title="4. 执行引擎"></a>4. 执行引擎</h3><p>在完成解析和优化阶段以后，MySQL会生成对应的执行计划，查询执行引擎根据执行计划给出的指令逐步执行得出结果。</p><p>整个执行过程的大部分操作均是通过调用存储引擎实现的接口来完成，这些接口被称为handler API</p><h3 id="5-返回结果"><a href="#5-返回结果" class="headerlink" title="5. 返回结果"></a>5. 返回结果</h3><ul><li>即使查询不到数据，MySQL仍然会返回这个查询的相关信息，比如该查询影响到的行数以及执行时间等等。</li><li>如果查询缓存被打开且这个查询可以被缓存，MySQL也会将结果存放到缓存中。</li><li>结果集返回客户端是一个增量且逐步返回的过程。有可能MySQL在生成第一条结果时，就开始向客户端逐步返回结果集了。这样服务端就无须存储太多结果而消耗过多内存，也可以让客户端第一时间获得返回结果。</li></ul><h3 id="MySQL整个查询执行过程，总的来说分为5个步骤："><a href="#MySQL整个查询执行过程，总的来说分为5个步骤：" class="headerlink" title="MySQL整个查询执行过程，总的来说分为5个步骤："></a>MySQL整个查询执行过程，总的来说分为5个步骤：</h3><ol><li>客户端向MySQL服务器发送一条查询请求</li><li>服务器首先检查查询缓存，如果命中缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段</li><li>服务器进行SQL解析、预处理、再由优化器生成对应的执行计划</li><li>MySQL根据执行计划，调用存储引擎的API来执行查询</li><li>将结果返回给客户端，同时缓存查询结果</li></ol><h2 id="三、日志系统"><a href="#三、日志系统" class="headerlink" title="三、日志系统"></a>三、日志系统</h2><p>与查询流程不一样的是，更新流程还涉及两个重要的日志模块</p><ul><li>redolog（重做日志）</li><li>binlog（归档日志）</li></ul><h3 id="1-redolog-重做日志"><a href="#1-redolog-重做日志" class="headerlink" title="1. redolog 重做日志"></a>1. redolog 重做日志</h3><p>在 MySQL 中，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL 的设计者就采用了日志（redo log）来提升更新效率。而日志和磁盘配合的整个过程，其实就是 MySQL 里的 WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是<strong>先写日志，再写磁盘。</strong></p><ul><li>具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（redolog buffer）里面，并更新内存（buffer pool），这个时候更新就算完成了。</li><li>同时，InnoDB 引擎会在适当的时候（如系统空闲时），将这个操作记录更新到磁盘里面（刷脏页）。</li></ul><p>redo log 是 InnoDB 存储引擎层的日志，又称重做日志文件，redo log 是循环写的，redo log 不是记录数据页更新之后的状态，而是记录这个页做了什么改动。</p><p>redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么日志总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下图所示。</p><ul><li>checkpoint 是当前要擦除的位置，擦除记录前需要先把对应的数据落盘（更新内存页，等待刷脏页）。</li><li>write pos 到 checkpoint 之间的部分可以用来记录新的操作，如果 write pos 和 checkpoint 相遇，说明 redolog 已满，这个时候数据库停止进行数据库更新语句的执行，转而进行 redo log 日志同步到磁盘中。</li></ul><blockquote><p>redo log 用于保证 crash-safe 能力。innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。</p></blockquote><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20211018142440691.png" alt="image-20211018142440691" style="zoom: 25%;" /><h3 id="2-binlog-归档日志"><a href="#2-binlog-归档日志" class="headerlink" title="2. binlog 归档日志"></a>2. binlog 归档日志</h3><p>MySQL 整体来看，其实就有两块：</p><ul><li>一块是 Server 层，它主要做的是 MySQL 功能层面的事情；</li><li>还有一块是引擎层，负责存储相关的具体事宜。</li></ul><p>redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。</p><p>binlog 属于逻辑日志，是以二进制的形式记录的是这个语句的原始逻辑，依靠 binlog 是没有 crash-safe 能力的。</p><p>binlog 有两种模式，statement 格式的话是记 sql 语句，row 格式会记录行的内容，记两条，更新前和更新后都有。</p><blockquote><p>sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。</p></blockquote><p><strong>redo log 和 binlog 区别：</strong></p><ol><li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li><li>redo log 是物理日志，记录的是在某个数据页上做了什么修改；binlog 是逻辑日志，记录的是这个语句的原始逻辑。</li><li>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。追加写是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ol><blockquote><p>binlog 会记录所有的逻辑操作，并且是采用追加写的形式。当需要恢复到指定的某一秒时，比如今天下午二点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：</p><ul><li>首先，找到最近的一次全量备份，从这个备份恢复到临时库</li><li>然后，从备份的时间点开始，将备份的 binlog 依次取出来，重放到中午误删表之前的那个时刻。</li></ul><p>这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来，按需要恢复到线上库去。</p></blockquote><p>一个事务的 binlog 是有完整格式的：</p><ul><li>statement 格式的 binlog，最后会有 COMMIT</li><li>row 格式的 binlog，最后会有一个 XID event</li></ul><p>在 MySQL 5.6.2 版本以后，还引入了 binlog-checksum 参数，用来验证 binlog 内容的正确性。对于 binlog 日志由于磁盘原因，可能会在日志中间出错的情况，MySQL 可以通过校验 checksum 的结果来发现。所以，MySQL 是有办法验证事务 binlog 的完整性的。</p><h3 id="3-update-语句的执行流程图"><a href="#3-update-语句的执行流程图" class="headerlink" title="3. update 语句的执行流程图"></a>3. update 语句的执行流程图</h3><p>图中灰色框表示是在 InnoDB 内部执行的，绿色框表示是在执行器中执行的。</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20211019085451551.png" alt="image-20211019085451551" style="zoom: 50%;" /><blockquote><p>redo log 和 binlog 怎么关联起来</p><p>redo log 和 binlog 有一个共同的数据字段，叫 XID。崩溃恢复的时候，会按顺序扫描 redo log：</p><ul><li>如果碰到既有 prepare、又有 commit 的 redo log，就直接提交；</li><li>如果碰到只有 parepare、而没有 commit 的 redo log，就拿着 XID 去 binlog 找对应的事务。</li></ul></blockquote><h3 id="4-两阶段提交-2PC"><a href="#4-两阶段提交-2PC" class="headerlink" title="4. 两阶段提交 2PC"></a>4. 两阶段提交 2PC</h3><p>MySQL 使用两阶段提交主要解决 binlog 和 redo log 的数据一致性的问题。</p><p>redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。下图为 MySQL 二阶段提交简图：</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20211019090558784.png" alt="image-20211019090558784" style="zoom:33%;" /><blockquote><p>每个事务 binlog 的末尾，会记录一个 XID event，标志着事务是否提交成功，也就是说，recovery 过程中，binlog 最后一个 XID event 之后的内容都应该被 purge。</p></blockquote>]]></content>
    
    
    <summary type="html">Mysql 执行流程和日志系统</summary>
    
    
    
    <category term="Mysql" scheme="https://fabian4.site/blog/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://fabian4.site/blog/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 锁机制</title>
    <link href="https://fabian4.site/blog/47132.html"/>
    <id>https://fabian4.site/blog/47132.html</id>
    <published>2021-04-24T16:00:00.000Z</published>
    <updated>2022-08-24T07:47:19.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql-锁机制"><a href="#Mysql-锁机制" class="headerlink" title="Mysql 锁机制"></a>Mysql 锁机制</h1><p>根据上面一篇文章，我们可以知道：当发生了<code>读-写</code>和<code>写-读</code> 问题的时候，innodb 是通过 MVCC 和 undo log 实现了在不加锁的情况下的事务隔离，保证了数据安全的同时也提高了并发性能。</p><p><strong>那么这里我们提到的锁机制 就是来解决 <code>写-写</code>  问题。</strong></p><blockquote><p>根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类。</p></blockquote><h2 id="一、全局锁"><a href="#一、全局锁" class="headerlink" title="一、全局锁"></a>一、全局锁</h2><h3 id="1-加锁"><a href="#1-加锁" class="headerlink" title="1. 加锁"></a>1. 加锁</h3><p><strong>顾名思义，全局锁就是对整个数据库实例加锁。</strong></p><p>MySQL 提供了一个加全局读锁的方法，命令是 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flush tables with <span class="built_in">read</span> lock (FTWRL)。</span><br></pre></td></tr></table></figure><p>当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：</p><ul><li>数据更新语句（数据的增删改）</li><li>数据定义语句（包括建表、修改表结构等）</li><li>更新类事务的提交语句。</li></ul><blockquote><p>全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都 select 出来存成文本。</p></blockquote><h3 id="2-逻辑备份"><a href="#2-逻辑备份" class="headerlink" title="2. 逻辑备份"></a>2. 逻辑备份</h3><p>以前有一种做法，是通过 FTWRL 确保不会有其他线程对数据库做更新，然后对整个库做备份。</p><p>注意，在备份过程中整个库完全处于只读状态。但是让整库都只读，听上去就很危险：</p><ul><li>如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；</li><li>如果你在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟。</li></ul><p>官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数–single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。</p><p><strong>但是对于 MyISAM 这种不支持事务的引擎依然会破坏数据的一致性，所以这也是DBA要求数据库引擎迁移至 innodb 的原因</strong></p><p>不过这里也不建议使用 <code>set global readonly = true</code>：</p><ol><li>在有些系统中 <code>readonly</code> 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大。</li><li>在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而<strong>将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态</strong>，这样会导致整个库长时间处于不可写状态，风险较高。</li></ol><h2 id="二、表级锁"><a href="#二、表级锁" class="headerlink" title="二、表级锁"></a>二、表级锁</h2><blockquote><p>MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。</p></blockquote><h3 id="1-表锁"><a href="#1-表锁" class="headerlink" title="1. 表锁"></a>1. 表锁</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock tables … <span class="built_in">read</span>/write。</span><br></pre></td></tr></table></figure><p>与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。</p><p>需要注意，<strong>lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象</strong>。</p><blockquote><p>在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面还是太大。</p></blockquote><h3 id="2-元数据锁-MDL（metadata-lock"><a href="#2-元数据锁-MDL（metadata-lock" class="headerlink" title="2. 元数据锁 MDL（metadata lock)"></a>2. 元数据锁 MDL（metadata lock)</h3><p>MDL 不需要显式使用，在访问一个表的时候会被自动加上。</p><p>MDL 的作用是，保证读写的正确性。</p><p>如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。因此，在 MySQL 5.5 版本中引入了 MDL</p><blockquote><p>当对一个表做增删改查操作的时候，加 MDL 读锁</p><p>当要对表做结构变更操作的时候，加 MDL 写锁。</p></blockquote><ul><li><p>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</p></li><li><p>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。</p></li></ul><p><strong>因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</strong></p><p>虽然 MDL 锁是系统默认会加的，但却是你不能忽略的一个机制。给一个表加字段，或者修改字段，或者加索引，需要扫描全表的数据。这里又要特别小心几个场景了：</p><ol><li><strong>关于长事务</strong>：事务不提交，就会一直占着 MDL 锁。在 MySQL 的 <code>information_schema</code> 库的 <code>innodb_trx</code> 表中，你可以查到当前执行中的事务。如果你要做 DDL 变更的表刚好有长事务在执行，要考虑先暂停 DDL，或者 kill 掉这个长事务。</li><li><strong>当要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而又不得不加个字段</strong>：这时候 <code>kill</code> 可能未必管用，因为新的请求马上就来了。比较理想的机制是，在 <code>alter table</code> 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。</li></ol><h2 id="三、行锁"><a href="#三、行锁" class="headerlink" title="三、行锁"></a>三、行锁</h2><blockquote><p>MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。</p><p>不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。</p><p>InnoDB 是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一。</p></blockquote><h3 id="1-两阶段锁协议"><a href="#1-两阶段锁协议" class="headerlink" title="1. 两阶段锁协议"></a>1. 两阶段锁协议</h3><table><thead><tr><th align="center">事务A</th><th align="center">事务B</th></tr></thead><tbody><tr><td align="center">begin;</td><td align="center"></td></tr><tr><td align="center">update t set k &#x3D; k + 1 where id &#x3D; 1;</td><td align="center"></td></tr><tr><td align="center">update t set k &#x3D; k + 1 where id &#x3D; 2;</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">begin;</td></tr><tr><td align="center"></td><td align="center">update t set k &#x3D; k + 1 where id &#x3D; 1;</td></tr><tr><td align="center">commit;</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">commit;</td></tr></tbody></table><p><strong>在这个场景下，事务B会被阻塞一直到事务A提交</strong></p><blockquote><p>在 InnoDB 事务中，行锁是在需要的时候才加上的，但<strong>并不是不需要了就立刻释放，而是要等到事务结束时才释放。</strong></p><p>这个就是两阶段锁协议。</p></blockquote><p><strong>所以：如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放！！！！！！</strong></p><p><strong>所以：如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放！！！！！！</strong></p><p><strong>所以：如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放！！！！！！</strong></p><h3 id="2-死锁和死锁检测"><a href="#2-死锁和死锁检测" class="headerlink" title="2. 死锁和死锁检测"></a>2. 死锁和死锁检测</h3><blockquote><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。</p></blockquote><table><thead><tr><th align="center">事务A</th><th align="center">事务B</th></tr></thead><tbody><tr><td align="center">begin;</td><td align="center"></td></tr><tr><td align="center">update t set k &#x3D; k + 1 where id &#x3D; 1;</td><td align="center">begin;</td></tr><tr><td align="center"></td><td align="center">update t set k &#x3D; k + 1 where id &#x3D; 2;</td></tr><tr><td align="center">update t set k &#x3D; k + 1 where id &#x3D; 2;</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">update t set k &#x3D; k + 1 where id &#x3D; 1;</td></tr><tr><td align="center">commit;</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">commit;</td></tr></tbody></table><p>这个时候就形成了死锁：</p><ul><li>事务A持有 <code>id=1</code> 的行锁去争取 <code>id=2</code> 的行锁</li><li>事务B持有 <code>id=2</code> 的行锁去争取 <code>id=1</code> 的行锁</li></ul><p>对于死锁，这里有两种解决策略：</p><ul><li><p>直接进入等待，直到超时。这个超时时间可以通过参数 <code>innodb_lock_wait_timeout</code> 来设置。</p><blockquote><p>在 InnoDB 中，<code>innodb_lock_wait_timeout</code> 的默认值是 50s</p><p>但是这个时间的值也是不容易确定下来的：</p><ol><li>如果时间过长，那么在产生死锁之后就需要等待很久才会退出事务，很明显拉低了数据库的并发性能</li><li>如果时间太短，可能只是简单的锁等待，就会产生很多误伤</li></ol></blockquote></li><li><p>发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启这个逻辑。</p><blockquote><p>每一个事务都会检测死锁，那么当并发事务增多时，大量的CPU资源被用来死锁检测。最后就是CPU利用率很高却执行不了几个事务。</p></blockquote></li></ul><h2 id="四、innodb-的-行锁"><a href="#四、innodb-的-行锁" class="headerlink" title="四、innodb 的 行锁"></a>四、innodb 的 行锁</h2><p>InnoDB存储引擎有3种行锁的算法，分别是：</p><ul><li>Record Lock: 单个记录上的锁</li><li>Gap Lock: 间隙锁，锁定一个范围，但不包括记录本身</li><li>Next-Key Lock: Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身</li></ul><blockquote><p>什么是幻读：</p><p><strong>在可重复读的隔离界别下、实行当前读的时候</strong>：一个事务(同一个read view)在前后两次查询同一范围的时候，后一次查询看到了前一次查询没有看到的行。<strong>两点需要说明</strong>：<br> 　1、在可重复读隔离级别下，普通查询是快照读，是不会看到别的事务插入的数据的，幻读只在<strong>当前读</strong>下才会出现。<br> 　2、幻读专指<strong>新插入的行</strong>，读到原本存在行的更新结果不算。因为<strong>当前读</strong>的作用就是能读到所有已经提交记录的最新值。</p></blockquote><p>由于普通的行锁即 <code>Record Lock</code> 只能锁住单独的行，并不能阻止新的数据的插入，所以任然会引起幻读。</p><p>这个时候就会引入间隙锁或者是<code>Next-key Lock</code>来避免幻读的产生</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20211018090855069.png" alt="image-20211018090855069"></p><p><strong>MyISAM引擎和InnoDB引擎简单对比：</strong></p><table><thead><tr><th></th><th>MyISAM引擎</th><th>InnoDB引擎</th></tr></thead><tbody><tr><td>主外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>行表锁</td><td>表所.不适合高并发</td><td>行锁.适合高并发</td></tr><tr><td>缓存</td><td>只缓存索引</td><td>缓存索引和真实数据</td></tr><tr><td>表空间</td><td>小</td><td>大</td></tr><tr><td>关注点</td><td>性能.偏读</td><td>事务</td></tr><tr><td>默认安装</td><td>是</td><td>是</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">Mysql 锁机制</summary>
    
    
    
    <category term="Mysql" scheme="https://fabian4.site/blog/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://fabian4.site/blog/tags/Mysql/"/>
    
    <category term="锁" scheme="https://fabian4.site/blog/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Mysql 隔离级别与MVCC</title>
    <link href="https://fabian4.site/blog/10729.html"/>
    <id>https://fabian4.site/blog/10729.html</id>
    <published>2021-04-19T16:00:00.000Z</published>
    <updated>2022-08-24T07:47:19.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql-隔离级别与MVCC"><a href="#Mysql-隔离级别与MVCC" class="headerlink" title="Mysql 隔离级别与MVCC"></a>Mysql 隔离级别与MVCC</h1><blockquote><p>以下内容都是基于 5.7 的 MySQL 的 innode 的存储引擎</p></blockquote><h2 id="一、问题的出现"><a href="#一、问题的出现" class="headerlink" title="一、问题的出现"></a>一、问题的出现</h2><ul><li>读-读：没有并发问题</li><li>读-写：会造成数据不一致  </li><li>写-写：造成数据丢失问题</li></ul><p><strong>很明显在两个事务同时读操作，是不存在线程并发安全问题。但当一旦开始出现了写操作，那么就会开始干扰另一个事务了。</strong></p><p>为了解决 <strong>读-写</strong> 和 <strong>写-写</strong> 这两个场景下的问题，innodb 引入了 <strong>MVCC</strong> 和 <strong>锁机制</strong> 来保证事务的隔离</p><h2 id="二、隔离级别"><a href="#二、隔离级别" class="headerlink" title="二、隔离级别"></a>二、隔离级别</h2><p>这里我们引入一个场景再来看看事务的隔离级别</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> T(c <span class="type">int</span>) engine<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T(c) <span class="keyword">values</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">事务A</th><th align="center">事务B</th></tr></thead><tbody><tr><td align="center">启动事务</td><td align="center"></td></tr><tr><td align="center">查询得到结果 1</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">启动事务</td></tr><tr><td align="center"></td><td align="center">查询得到结果 1</td></tr><tr><td align="center"></td><td align="center">将 1 改成 2</td></tr><tr><td align="center">查询得到值 a</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">提交事务</td></tr><tr><td align="center">查询得到值 b</td><td align="center"></td></tr><tr><td align="center">提交事务</td><td align="center"></td></tr><tr><td align="center">查询得到值 c</td><td align="center"></td></tr></tbody></table><p><strong>在不同隔离级别下 a b c 的值：</strong></p><ul><li><p><strong>读未提交</strong> <code>Read UnCommitted</code>：</p><ul><li>a：2</li><li>b：2</li><li>c：2</li></ul><p>事务A 总是能直接读到 事务B 未提交的内容，那么查询到的就一直是最新的数据</p></li><li><p><strong>读已提交</strong> <code>Read Committed</code>：</p><ul><li>a：1</li><li>b：2</li><li>c：2</li></ul><p>事务A 只能读到 事务B 已提交的内容，那么在提交之后就能读到新的值</p></li><li><p><strong>可重复读</strong> <code>Repeatable Read</code>：</p><ul><li>a：1</li><li>b：1</li><li>c：2</li></ul><p>事务A 在可重复读 的隔离级别下，能保证在同一个事务中读到的值是不受其他事务影响的</p></li><li><p><strong>串行化</strong> <code>Serializable</code>：</p><ul><li>a：1</li><li>b：1</li><li>c：2</li></ul><p>在串行化的隔离级别下，事务B 的修改操作会被 事务A 阻塞住，这样知道 事务A 提交才会继续执行，所以 事务A 查询之后任然是初始的值</p></li></ul><blockquote><p>在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。</p><ul><li>在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。</li><li>在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。</li><li>这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；</li><li>而“串行化”隔离级别下直接用加锁的方式来避免并行访问。</li></ul></blockquote><p>我们可以通过 show variables 来查看当前的隔离级别</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">&#x27;transaction_isolation&#x27;</span>;</span><br><span class="line">+-----------------------+----------------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+-----------------------+----------------+</span><br><span class="line">| transaction_isolation | READ-COMMITTED |</span><br><span class="line">+-----------------------+----------------+</span><br></pre></td></tr></table></figure><h2 id="三、MVCC-及-实现"><a href="#三、MVCC-及-实现" class="headerlink" title="三、MVCC 及 实现"></a>三、MVCC 及 实现</h2><h3 id="1-当前读和快照读"><a href="#1-当前读和快照读" class="headerlink" title="1. 当前读和快照读"></a>1. 当前读和快照读</h3><ul><li><p>关于当前读：</p><p>每一次数据的查询都是基于目前最新版本的数据，这种很显然是最简单的一种实现方式。但是由于当前读，遇到多事务并行的场景的时候，很明显就会出现各种各样的问题。<br>除非把数据库的隔离级别调整到最高即<strong>串行化</strong>：所有事务串行执行，那很明显就大大的降低了数据库的并发性能。</p></li><li><p>快照读：</p><p>为了保证事务的隔离级别，在每一个事务开始之前对当前的数据创建一个快照，这样在数据读取的过程中，只读自己事务的快照。<strong>这样其他事务的写入就不会影响自己的读取，也就不会产生一些脏读和幻读的现象。</strong></p></li></ul><h3 id="2-MVCC（Mutil-Version-Concurrency-Control）"><a href="#2-MVCC（Mutil-Version-Concurrency-Control）" class="headerlink" title="2. MVCC（Mutil-Version Concurrency Control）"></a>2. MVCC（Mutil-Version Concurrency Control）</h3><blockquote><p>MVCC(Mutil-Version Concurrency Control)，就是多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。</p><p>在Mysql的InnoDB引擎中就是指在 <strong>已提交读(READ COMMITTD)</strong> 和 <strong>可重复读(REPEATABLE READ)</strong> 这两种隔离级别下的事务对于SELECT操作会<strong>访问版本链中的记录</strong>的过程。</p></blockquote><ul><li><p>版本链</p><p>这里的版本链就是 <strong>快照读</strong> 在 innodb 中的具体的实现方式。</p><p>在每一个事务开始的时候创建一个版本分支，每一次该事务的读或者写都是在各自对应的版本链中实现，从而可以达到事务之间的隔离。</p></li><li><p>对于版本链的引入，可以在<strong>不加锁</strong>的情况下实现读事务，进而大大的提高数据库的并发性能。</p></li></ul><h3 id="3-基于-Undo-log-的版本链"><a href="#3-基于-Undo-log-的版本链" class="headerlink" title="3. 基于 Undo log 的版本链"></a>3. 基于 Undo log 的版本链</h3><blockquote><p>如果快照读的实现是在事务开始的时候对数据库做一个全部的快照，那么在高并发场景下的内存开销一定是灾难</p></blockquote><p>InnoDB 的 MVCC是通过在每行记录后面保存两个隐藏的列来实现的。</p><ul><li><p><strong>一个保存了行的事务ID（DB_TRX_ID）</strong></p><p>每行数据也都是有多个版本的，每次事务更新数据的时候，都会生成一个新的数据版本，并且把<code>transaction id</code>赋值给这个数据版本的事务ID，记为<code>row trx_id</code>。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。</p><p>也就是说，数据表中的一行记录，其实可能有多个版本(row)，每个版本有自己的<code>row trx_id</code>。</p></li><li><p><strong>一个保存了行的回滚指针（DB_ROLL_PT）</strong>。</p><p>每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到<code>undo日志</code>中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息</p></li></ul><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20211007151855474.png" alt="image-20211007151855474"></p><p><code>undo log</code>的回滚机制也是依靠这个版本链，每次对记录进行改动，都会记录一条undo日志，每条undo日志也都有一个<code>roll_pointer</code>属性（INSERT操作对应的undo日志没有该属性，因为该记录并没有更早的版本），可以将这些undo日志都连起来，串成一个链表，所以现在的情况就像下图一样</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20211007152027329.png" alt="image-20211007152027329"></p><h3 id="4-insert-undo-log-和-update-undo-log"><a href="#4-insert-undo-log-和-update-undo-log" class="headerlink" title="4. insert undo log 和 update undo log"></a>4. <strong>insert undo log</strong> 和 <strong>update undo log</strong></h3><blockquote><p>根据行为的不同，undo log分为两种：<strong>insert undo log</strong> 和 <strong>update undo log</strong></p></blockquote><ul><li><p><strong>insert undo log：</strong></p><p>insert 操作中产生的undo log，因为insert操作记录只对当前事务本身课件，对于其他事务此记录不可见，所以 insert undo log 可以在事务提交后直接删除而不需要进行purge操作。</p><blockquote><p>purge的主要任务是将数据库中已经 mark del 的数据删除，另外也会批量回收undo pages</p></blockquote><p>数据库 Insert时的数据初始状态：<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20211007155050351.png" alt="image-20211007155050351"></p></li><li><p><strong>update undo log：</strong></p><p>update 或 delete 操作中产生的 undo log。因为会对已经存在的记录产生影响，为了提供 MVCC机制，因此update undo log 不能在事务提交时就进行删除，而是将事务提交时放到入 history list 上，等待 purge 线程进行最后的删除操作。</p><p><strong>数据第一次被修改时：</strong></p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20211007155107177.png" alt="image-20211007155107177"></p><p><strong>当另一个事务第二次修改当前数据：</strong></p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20211007155121264.png" alt="image-20211007155121264"></p></li></ul><blockquote><p>为了保证事务并发操作时，在写各自的undo log时不产生冲突，InnoDB采用回滚段的方式来维护undo log的并发写入和持久化。回滚段实际上是一种 Undo 文件组织方式。</p></blockquote><h3 id="5-可重复读隔离级别下的增删改查"><a href="#5-可重复读隔离级别下的增删改查" class="headerlink" title="5. 可重复读隔离级别下的增删改查"></a>5. 可重复读隔离级别下的增删改查</h3><h4 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a><strong>SELECT</strong></h4><ul><li>InnoDB 会根据以下两个条件检查每行记录：<ol><li>InnoDB只查找版本早于当前事务版本的数据行（也就是，行的事务编号小于或等于当前事务的事务编号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。</li><li>删除的行要事务ID判断，读取到事务开始之前状态的版本，只有符合上述两个条件的记录，才能返回作为查询结果。</li></ol></li></ul><h4 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a><strong>INSERT</strong></h4><ul><li>InnoDB为新插入的每一行保存当前事务编号作为行版本号。</li></ul><h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a><strong>DELETE</strong></h4><ul><li>InnoDB为删除的每一行保存当前事务编号作为行删除标识。</li></ul><h4 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a><strong>UPDATE</strong></h4><ul><li>InnoDB为插入一行新记录，保存当前事务编号作为行版本号，同时保存当前事务编号到原来的行作为行删除标识。</li></ul><h2 id="四、ReadView"><a href="#四、ReadView" class="headerlink" title="四、ReadView"></a>四、ReadView</h2><blockquote><p>对于 <strong>RU(READ UNCOMMITTED)</strong> 隔离级别下，所有事务直接读取数据库的最新值即可，和 <strong>SERIALIZABLE</strong> 隔离级别，所有请求都会加锁，同步执行。所以这对这两种情况下是不需要使用到 <strong>Read View</strong> 的版本控制。</p></blockquote><p>对于 <strong>RC(READ COMMITTED)</strong> 和 <strong>RR(REPEATABLE READ)</strong> 隔离级别的实现就是通过上面的版本控制来完成。</p><p>两种隔离界别下的核心处理逻辑就是判断所有版本中哪个版本是当前事务可见的处理。</p><p>针对这个问题InnoDB在设计上增加了<strong>ReadView</strong>的设计，<strong>ReadView</strong>中主要包含当前系统中还有哪些活跃的读写事务，把它们的事务id放到一个列表中，我们把这个列表命名为为<strong>m_ids</strong>。</p><p>对于查询时的版本链数据是否看见的判断逻辑：</p><ul><li>如果被访问版本的 trx_id 属性值小于 m_ids 列表中最小的事务id，表明生成该版本的事务在生成 ReadView 前已经提交，所以该版本可以被当前事务访问。</li><li>如果被访问版本的 trx_id 属性值大于 m_ids 列表中最大的事务id，表明生成该版本的事务在生成 ReadView 后才生成，所以该版本不可以被当前事务访问。</li><li>如果被访问版本的 trx_id 属性值在 m_ids 列表中最大的事务id和最小事务id之间，那就需要判断一下 trx_id 属性值是不是在 m_ids 列表中，如果在，说明创建 ReadView 时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问。</li></ul><h2 id="五、事务的启动"><a href="#五、事务的启动" class="headerlink" title="五、事务的启动"></a>五、事务的启动</h2><p>MySQL 的事务启动方式有以下两种：</p><ol><li>显式启动事务语句， begin 或 start transaction。配套的提交语句是 commit，回滚语句是 rollback。</li><li>set autocommit&#x3D;0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个 select 语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行 commit 或 rollback 语句，或者断开连接。</li></ol><p>有些客户端连接框架会默认连接成功后先执行一个 set autocommit&#x3D;0 的命令。这就导致接下来的查询都在事务中，如果是长连接，就导致了意外的长事务。</p><blockquote><p>因此，我会建议你总是使用 set autocommit&#x3D;1, 通过显式语句的方式来启动事务。</p><p>但是有的开发同学会纠结“多一次交互”的问题。对于一个需要频繁使用事务的业务，第二种方式每个事务在开始时都不需要主动执行一次 “begin”，减少了语句的交互次数。如果你也有这个顾虑，我建议你使用 commit work and chain 语法。</p><p>在 autocommit 为 1 的情况下，用 begin 显式启动的事务，如果执行 commit 则提交事务。如果执行 commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行 begin 语句的开销。同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。</p></blockquote><p>你可以在 information_schema 库的 innodb_trx 这个表中查询长事务，比如下面这个语句，用于查找持续时间超过 60s 的事务。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.innodb_trx <span class="keyword">where</span> TIME_TO_SEC(timediff(now(),trx_started))<span class="operator">&gt;</span><span class="number">60</span></span><br></pre></td></tr></table></figure><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>所谓的MVCC（Multi-Version Concurrency Control ，多版本并发控制）指的就是：</p><p>在使用 <strong>READ COMMITTD</strong> 、<strong>REPEATABLE READ</strong> 这两种隔离级别的事务在执行普通的 SEELCT 操作时访问记录的版本链的过程，这样子可以使不同事务的 <code>读-写</code> 、 <code>写-读</code> 操作并发执行，从而提升系统性能。</p><p>在 MySQL 中， READ COMMITTED 和 REPEATABLE READ 隔离级别的的一个非常大的区别就是<strong>它们生成 ReadView 的时机不同。</strong></p><ul><li>在 READ COMMITTED 中每次查询都会生成一个实时的 ReadView，做到保证每次提交后的数据是处于当前的可见状态。</li><li>REPEATABLE READ 中，在当前事务第一次查询时生成当前的 ReadView，并且当前的 ReadView 会一直沿用到当前事务提交，以此来保证可重复读（REPEATABLE READ）。</li></ul>]]></content>
    
    
    <summary type="html">Mysql 隔离级别与MVCC</summary>
    
    
    
    <category term="Mysql" scheme="https://fabian4.site/blog/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://fabian4.site/blog/tags/Mysql/"/>
    
    <category term="MVCC" scheme="https://fabian4.site/blog/tags/MVCC/"/>
    
  </entry>
  
  <entry>
    <title>数据库四大性质和隔离等级</title>
    <link href="https://fabian4.site/blog/58885.html"/>
    <id>https://fabian4.site/blog/58885.html</id>
    <published>2021-04-07T16:00:00.000Z</published>
    <updated>2022-08-24T07:47:19.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库四大性质和隔离等级"><a href="#数据库四大性质和隔离等级" class="headerlink" title="数据库四大性质和隔离等级"></a>数据库四大性质和隔离等级</h1><h2 id="一、四大性质：ACID"><a href="#一、四大性质：ACID" class="headerlink" title="一、四大性质：ACID"></a>一、四大性质：ACID</h2><blockquote><p><strong>如果想要说明一个数据库或者一个框架支持事务性操作，则必须要满足下面的四大特性</strong>:</p><ol><li>原子性（Atomicity）</li><li>一致性（Consistency）</li><li>隔离性（Isolation）</li><li>持久性（Durability）</li></ol></blockquote><h3 id="1-原子性（Atomicity）"><a href="#1-原子性（Atomicity）" class="headerlink" title="1. 原子性（Atomicity）"></a>1. 原子性（Atomicity）</h3><ul><li>事务包含的所有操作<strong>要么全部成功，要么全部失败回滚</strong>。</li><li>失败回滚的操作事务，将<strong>不能对事物有任何影响</strong>。</li></ul><h3 id="2-一致性（Consistency）"><a href="#2-一致性（Consistency）" class="headerlink" title="2. 一致性（Consistency）"></a>2. 一致性（Consistency）</h3><p><strong>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</strong></p><blockquote><p>数据库状态如何变化？</p><ul><li>每一次数据变更就会导致数据库的状态迁移。</li><li>如果数据库的初始状态是C0，第一次事务T1的提交就会导致系统生成一个SYSTEM CHANGE NUMBER（SCN），这是数据库状态从C0转变成C1。</li><li>执行第二个事务T2的时候数据库状态从T1变成T2</li><li>以此类推，执行第Tn次事务的时候数据库状态由C(n-1)变成Cn。</li></ul></blockquote><p>一致性可以从一致读和一致写两个方面来理解。</p><ul><li><p><strong>一致读</strong> 事务读取数据只能从一个状态中读取，不能从2个或者2个以上状态读取。</p><p>也就是T(n)只能从C(n-1），C(n-2)… C(1)中的一个状态读取数据，不能一部分数据读取自C(n-1)，而另一部分数据读取自C(n-2)。</p></li><li><p><strong>一致写</strong> 事务执行的数据变更只能基于上一个一致的状态，且只能体现在一个状态中。</p><p>T(n)的变更结果只能基于C(n-1)，C(n-2), …C(1)状态，且只能体现在C(n)状态中。也就是说，一个状态只能有一个事务变更数据，不允许有2个或者2个以上事务在一个状态中变更数据。至于具体一致写基于哪个状态，需要判断T(n)事务是否和T(n-1)，T(n-2),…T(1)有依赖关系。</p></li></ul><h3 id="3-隔离性（Isolation）"><a href="#3-隔离性（Isolation）" class="headerlink" title="3. 隔离性（Isolation）"></a>3. 隔离性（Isolation）</h3><p>隔离性是指当多个用户并发访问数据库时，比如同时访问一张表<strong>数据库每一个用户开启的事务，不能被其他事务所做的操作干扰，多个并发事务之间，应当相互隔离。</strong></p><p>例如同时有T1和T2两个并发事务，从T1角度来看，T2要不在T1执行之前就已经结束，要么在T1执行完成后才开始。</p><p>将多个事务隔离开，每个事务都不能访问到其他事务操作过程中的状态。</p><h3 id="4-持久性（Durability）"><a href="#4-持久性（Durability）" class="headerlink" title="4. 持久性（Durability）"></a>4. 持久性（Durability）</h3><p>持久性是指事务的操作，一旦提交，对于数据库中数据的改变是永久性的，即使数据库发生故障也不能丢失已提交事务所完成的改变。</p><h2 id="二、没有隔离性并发操作遇到的问题"><a href="#二、没有隔离性并发操作遇到的问题" class="headerlink" title="二、没有隔离性并发操作遇到的问题"></a>二、没有隔离性并发操作遇到的问题</h2><h3 id="1-脏读"><a href="#1-脏读" class="headerlink" title="1. 脏读"></a>1. 脏读</h3><p><strong>脏读是指一个事务读取了未提交事务执行过程中的数据。</strong></p><blockquote><p>当一个事务的操作正在多次修改数据，而在事务还未提交的时候，另外一个并发事务来读取了数据，就会导致读取到的数据并非是最终持久化之后的数据，这个数据就是脏读的数据。</p></blockquote><table><thead><tr><th align="center">事务A</th><th align="center">事务B</th></tr></thead><tbody><tr><td align="center">事务开始</td><td align="center">总数100</td></tr><tr><td align="center"></td><td align="center">事务开始</td></tr><tr><td align="center"></td><td align="center">插入新数据</td></tr><tr><td align="center">查询数据总数 101</td><td align="center"></td></tr><tr><td align="center">提交事务</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">回滚</td></tr></tbody></table><h3 id="2-不可重复读"><a href="#2-不可重复读" class="headerlink" title="2. 不可重复读"></a>2. 不可重复读</h3><p>不可重复读是指对于数据库中的某个数据，<strong>一个事务执行过程中多次查询返回不同查询结果，这就是在事务执行过程中，数据被其他事务提交修改了</strong>。</p><table><thead><tr><th align="center">事务A</th><th align="center">事务B</th></tr></thead><tbody><tr><td align="center">查询数据总数 100</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">插入新数据</td></tr><tr><td align="center">查询数据总数 101</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">插入新数据</td></tr><tr><td align="center">查询数据总数 102</td><td align="center"></td></tr></tbody></table><p>不可重复读同脏读的区别在于</p><ul><li>脏读是一个事务读取了另一未完成的事务执行过程中的数据</li><li>而不可重复读是一个事务执行过程中，另一事务提交并修改了当前事务正在读取的数据。</li></ul><h3 id="3-幻读"><a href="#3-幻读" class="headerlink" title="3. 幻读"></a>3. 幻读</h3><p>幻读是事务非独立执行时发生的一种现象：</p><blockquote><p>如果一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。</p></blockquote><table><thead><tr><th align="center">事务A</th><th align="center">事务B</th></tr></thead><tbody><tr><td align="center">查询数据总数 100</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">插入新数据</td></tr><tr><td align="center">查询数据总数 101</td><td align="center"></td></tr></tbody></table><p>幻读和不可重复读都是读取了另一条已经提交的事务（这点同脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</p><h2 id="三、隔离级别说明"><a href="#三、隔离级别说明" class="headerlink" title="三、隔离级别说明"></a>三、隔离级别说明</h2><p>MySQL定义了四种隔离级别，包括一些具体规则，用于限定事务内外哪些改变是可见的，哪些改变是不可见的。低级别的隔离一般支持更高的并发处理，并且拥有更低的系统开销。</p><h3 id="Repeatable-Read-可重复读"><a href="#Repeatable-Read-可重复读" class="headerlink" title="Repeatable Read 可重复读"></a><code>Repeatable Read</code> 可重复读</h3><p>MySQL数据库默认的隔离级别。该级别解决了READ UNCOMMITTED隔离级别导致的问题。它保证同一事务的多个实例在并发读取事务时，会“看到同样的”数据行。不过，这会导致另外一个棘手问题“幻读”。InnoDB和Falcon存储引擎通过多版本并发控制机制解决了幻读问题。</p><h3 id="Read-Committed-读取提交内容"><a href="#Read-Committed-读取提交内容" class="headerlink" title="Read Committed 读取提交内容"></a><code>Read Committed</code> 读取提交内容</h3><p>大多数数据库系统的默认隔离级别（但是不是MySQL的默认隔离级别），满足了隔离的早先简单定义：一个事务开始时，只能“看见”已经提交事务所做的改变，一个事务从开始到提交前，所做的任何数据改变都是不可见的，除非已经提交。这种隔离级别也支持所谓的“不可重复读”。这意味着用户运行同一个语句两次，看到的结果是不同的。</p><h3 id="Read-UnCommitted-读取未提交内容"><a href="#Read-UnCommitted-读取未提交内容" class="headerlink" title="Read UnCommitted 读取未提交内容"></a><code>Read UnCommitted</code> 读取未提交内容</h3><p>在这个隔离级别，所有事务都可以“看到”未提交事务的执行结果。在这种级别上，可能会产生很多问题，除非用户真的知道自己在做什么，并有很好的理由选择这样做。本隔离级别很少用于实际应用，因为它的性能也不必其他性能好多少，而别的级别还有其他更多的优点。读取未提交数据，也被称为“脏读”</p><h3 id="Serializable-可串行化"><a href="#Serializable-可串行化" class="headerlink" title="Serializable 可串行化"></a><code>Serializable</code> 可串行化</h3><p>该级别是最高级别的隔离级。它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简而言之，SERIALIZABLE是在每个读的数据行上加锁。在这个级别，可能导致大量的超时<code>Timeout</code>和锁竞争<code>Lock Contention</code>现象，实际应用中很少使用到这个级别，但如果用户的应用为了数据的稳定性，需要强制减少并发的话，也可以选择这种隔离级</p><p>下面的表格总结了各种隔离级别和各自的缺点</p><table><thead><tr><th align="left">隔离级别</th><th align="center">脏读可能性</th><th align="center">不可重复读可能性</th><th align="center">幻读可能性</th></tr></thead><tbody><tr><td align="left"><code>READ UNCOMMITTED</code></td><td align="center">是</td><td align="center">是</td><td align="center">是</td></tr><tr><td align="left"><code>READ COMMITTED</code></td><td align="center">否</td><td align="center">是</td><td align="center">是</td></tr><tr><td align="left"><code>REPEATABLE READ</code></td><td align="center">否</td><td align="center">否</td><td align="center">是</td></tr><tr><td align="left"><code>SERIALIZABLE</code></td><td align="center">否</td><td align="center">否</td><td align="center">否</td></tr></tbody></table><h2 id="四、修改隔离级别的方法"><a href="#四、修改隔离级别的方法" class="headerlink" title="四、修改隔离级别的方法"></a>四、修改隔离级别的方法</h2><h3 id="全局修改"><a href="#全局修改" class="headerlink" title="全局修改"></a>全局修改</h3><p>全局修改需要修改MySql的全局文件mysql.ini，修改内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 #可选参数有：READ-UNCOMMITTED, READ-COMMITTED, REPEATABLE-READ, SERIALIZABLE.</span><br><span class="line">2 [mysqld]</span><br><span class="line">3 transaction-isolation = REPEATABLE-READ</span><br></pre></td></tr></table></figure><h3 id="语句修改"><a href="#语句修改" class="headerlink" title="语句修改"></a>语句修改</h3><p>在命令行模式下连上MySql后，可以使用下列语句查看MySql当前隔离级别</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@tx_isolation;</span><br><span class="line">+-----------------+</span><br><span class="line">| @@tx_isolation  |</span><br><span class="line">+-----------------+</span><br><span class="line">| REPEATABLE-READ |</span><br><span class="line">+-----------------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p>可以使用下面的命令修改当前会话Session的隔离级</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> session transaction isolation level <span class="built_in">read</span> committed;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; select @@tx_isolation;</span><br><span class="line">+----------------+</span><br><span class="line">| @@tx_isolation |</span><br><span class="line">+----------------+</span><br><span class="line">| READ-COMMITTED |</span><br><span class="line">+----------------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="AutoCommit-事务自动提交"><a href="#AutoCommit-事务自动提交" class="headerlink" title="AutoCommit 事务自动提交"></a>AutoCommit 事务自动提交</h3><p>MySql中有AutoCommit参数，默认为on，也就是开启状态。</p><p>它的作用是每一条单独的查询都是一个事务，自动开始，自动提交（语句执行完成就提交。如果你要适用select for update，而不手动调用 start transaction，这个for update的行锁机制等于没用，因为行锁在自动提交后就释放了）。所以事务隔离级别和锁机制即使你不显式调用<code>start transaction</code>，这种机制在单独一条语句查询中也是适用的。</p><p>在命令行模式下可以使用下面的命令查看当前MySql的autocommit是否开启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">&#x27;autocommit&#x27;</span>;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| autocommit    | ON    |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure><p>如果需要关闭autocommit，我们可以使用下面语句设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="built_in">set</span> autocommit=0;</span><br><span class="line"><span class="comment"># 0就是OFF，1就是ON。</span></span><br></pre></td></tr></table></figure><p>设置为OFF之后，则用户执行语句之后，将一直处于一个事务中，直到执行commit或者rollback，才会结束当前事务，重新开始新的事务。</p>]]></content>
    
    
    <summary type="html">数据库四大性质和隔离等级</summary>
    
    
    
    <category term="Mysql" scheme="https://fabian4.site/blog/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://fabian4.site/blog/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>HashMap、HashTable和ConcurrentHashMap</title>
    <link href="https://fabian4.site/blog/5986.html"/>
    <id>https://fabian4.site/blog/5986.html</id>
    <published>2021-04-02T16:00:00.000Z</published>
    <updated>2022-08-24T07:47:19.050Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashMap、HashTable和ConcurrentHashMap"><a href="#HashMap、HashTable和ConcurrentHashMap" class="headerlink" title="HashMap、HashTable和ConcurrentHashMap"></a>HashMap、HashTable和ConcurrentHashMap</h1><h2 id="一、接口和继承"><a href="#一、接口和继承" class="headerlink" title="一、接口和继承"></a>一、接口和继承</h2><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20211001114726723.png" alt="image-20211001114726723"></p><ul><li><code>HashMap</code>：继承于 <code>AbstractMap</code>类</li><li><code>ConcurrentHashMap</code>：继承于<code>AbstractMap</code>类</li><li><code>HashTable</code>：继承于<code>Dictionary</code>类，自己实现了<code>Map</code>接口</li></ul><blockquote><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20211001120130544.png" alt="image-20211001120130544"></p><p>根据jdk中的注释我们可以看出<code>Dictionary</code>已经是一个历史遗留的集合抽象类：</p><p><strong>注意：这个类已经过时了。 新的实现应该实现 Map 接口，而不是扩展这个类。</strong></p><p>Hashtable类与HashMap类的作用一样，实际上，它们拥有相同的接口。与Vector类的方法一样。Hashtable的方法也是同步的。如果对同步性或与遗留代码的兼容性没有任何要求，就应该使用HashMap。如果需要并发访问，则要使用ConcurrentHashMap。</p></blockquote><h2 id="二、ConcurrentHashMap-的-put方法"><a href="#二、ConcurrentHashMap-的-put方法" class="headerlink" title="二、ConcurrentHashMap 的 put方法"></a>二、ConcurrentHashMap 的 <code>put</code>方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="comment">// 不允许键或值为 null</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 计算哈希值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 先判断有没有初始化，懒加载</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有哈希冲突就直接 cas 尝试写入</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果在扩容，该线程就一起帮助辅助扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 加锁写入</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 链表结点，加在末尾</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 红黑树</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否需要链表转二叉树</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增加计数</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/3.png" alt="image-20211001160134033"></p><h2 id="三、数据结构、初始化、扩容和线程安全"><a href="#三、数据结构、初始化、扩容和线程安全" class="headerlink" title="三、数据结构、初始化、扩容和线程安全"></a>三、数据结构、初始化、扩容和线程安全</h2><h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h3><ul><li><p><code>HashMap</code>：<strong>数组+链表+红黑树</strong></p><p><strong>为了避免链表长度过长，影响查找元素的效率，当链表的长度 &gt; 8时，会将链表转换为红黑树，链表的长度 &lt; 6时，将红黑树转换为链表</strong>(但是红黑树转换为链表的时机不是在删除链表时，而是在扩容时，发现红黑树分解后的两个链表 &lt; 6，就按链表处理，否则就建立两个小的红黑树，设置到扩容后的位置)。</p><p>之所以临界点为8是因为红黑树的查找时间复杂度为logN，链表的平均时间查找复杂度为N&#x2F;2，当N为8时，logN为3，是小于N&#x2F;2的，正好可以<strong>通过转换为红黑树减少查找的时间复杂度</strong>。</p></li><li><p><code>ConcurrentHashMap</code>：<strong>数组+链表+红黑树</strong></p><p>底层数据结构跟<code>HashMap</code>一致。只不过使用了<code>volatile</code>来进行修饰它的属性，来保证内存可见性</p><blockquote><p>一个线程修改了这些属性后，会使得其他线程中对于该属性的缓存失效，以便下次读取时取最新的值。</p></blockquote></li><li><p><code>Hashtable</code>：<strong>数组+链表</strong></p><p>底层数据结构跟<code>HashMap</code>类似，也是通过链地址法来解决冲突。</p><p>只是链表过长时，不会转换为红黑树来减少查找时的时间复杂度。<strong>Hashtable属于历史遗留类，实际开发中很少使用。</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table; <span class="comment">//HashMap</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;<span class="comment">//ConcurrentHashMap</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;？,？&gt;[] table;<span class="comment">//HashTable</span></span><br></pre></td></tr></table></figure><h3 id="2-初始化和扩容"><a href="#2-初始化和扩容" class="headerlink" title="2. 初始化和扩容"></a>2. 初始化和扩容</h3><ul><li><p><strong>不指定初始容量</strong></p><ul><li><p><code>HashMap</code>：默认16</p></li><li><p><code>ConcurrentHashMap</code>：默认16</p></li><li><p><code>HashTable</code>：默认11</p></li></ul></li><li><p><strong>指定初始容量</strong></p><ul><li><code>HashMap</code>：比初始容量稍微大一些的2的幂次方大小</li><li><code>ConcurrentHashMap</code>：比初始容量稍微大一些的2的幂次方大小</li><li><code>HashTable</code>：使用初始容量</li></ul></li><li><p><strong>扩容</strong></p><p>扩容时，如果原长度是N</p><ul><li><code>HashMap</code>：2N</li><li><code>ConcurrentHashMap</code>：2N</li><li><code>HashTable</code>：2N+1</li></ul></li></ul><blockquote><p>HashTable会扩容为2N+1，HashTable之所以容量取11，及扩容时是是2N+1，是<strong>为了保证 HashTable的长度是一个素数</strong>，因为数组的下标是用key的hashCode与数组的长度取模进行计算得到的，而当数组的长度是素数时，可以保证计算得到的数组下标分布得更加均匀。</p><p>HashMap和ConcurrentHashMap的hash值都是通过将key的hashCode()高16位与低16位进行异或运算(这样可以保留高位的特征，避免一些key的hashCode高位不同，低位相同，造成hash冲突)，得到hash值，然后将hash&amp;(n-1)计算得到数组下标。<br>（n为数组的长度，因为当n为2的整数次幂时，hash mod n的结果在数学上等于hash&amp;(n-1)，而计算机进行&amp;运算更快，所以这也是HashMap的长度总是设置为2的整数次幂的原因）</p></blockquote><h3 id="3-线程安全"><a href="#3-线程安全" class="headerlink" title="3. 线程安全"></a>3. 线程安全</h3><ul><li><p><strong><code>HashMap</code>：非线程安全</strong></p><p>例如多个线程插入多个键值对，如果两个键值对的<code>key</code>哈希冲突，可能会使得两个线程在操作同一个链表中的节点，导致一个键值对的<code>value</code>被覆盖</p></li><li><p><strong><code>HashTable</code>：线程安全</strong></p><p>主要通过使用<code>synchronized</code>关键字修饰大部分方法，使得每次只能一个线程对<code>HashTable</code>进行同步修改，性能开销较大。</p></li><li><p><strong><code>ConcurrentHashMap</code>：线程安全</strong></p><p>主要是通过CAS操作+<code>synchronized</code>来保证线程安全的。</p></li></ul><h2 id="四、关于-null-值"><a href="#四、关于-null-值" class="headerlink" title="四、关于 null 值"></a>四、关于 null 值</h2><blockquote><p><strong><code>ConcurrentHashMap</code>和<code>HashTable</code>不允许 key 或 value 为 null</strong></p></blockquote><p><code>HashMap</code>是非线程安全的，默认单线程环境中使用，如果<code>get(key)</code>为null，可以通过<code>containsKey(key) </code>方法来判断这个key的value为null，还是不存在这个key。</p><p>而<code>ConcurrentHashMap</code>，<code>HashTable</code>是线程安全的， 在多线程操作时，因为<code>get(key)</code>和<code>containsKey(key)</code>两个操作和在一起<strong>不是一个原子性操作</strong>，可能在<code>containsKey(key)</code>时发现存在这个键值对，但是<code>get(key)</code>时，有其他线程删除了键值对，导致<code>get(key)</code>返回的Node是null，然后执行方法时抛出异常。所以无法区分value为null还是不存在key。</p><h2 id="五、HashSet-和-LinkedHashMap"><a href="#五、HashSet-和-LinkedHashMap" class="headerlink" title="五、HashSet 和 LinkedHashMap"></a>五、HashSet 和 LinkedHashMap</h2><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20211001175620138.png" alt="image-20211001175620138"></p><h2 id="1-HashSet"><a href="#1-HashSet" class="headerlink" title="1. HashSet"></a>1. HashSet</h2><p><code>HashMap</code>主要是用于<strong>存储非重复键值对</strong>，<code>HashSet</code><strong>存储非重复的对象</strong>。虽然<code>HashMap</code>是继承于<code>AbstractMap</code>，实现了<code>Map</code>接口，<code>HashSet</code>继承于<code>AbstractSet</code>，实现了<code>Set</code>接口。但是由于它们都有去重的需求，所以**<code>HashSet</code>主要实现都是基于<code>HashMap</code>的**。</p><blockquote><p>如果需要复用一个类，我们可以使用继承模式，也可以使用组合模式。组合模式就是将一个类作为新类的组成部分，以此来达到复用的目的。</p><p>例如，在HashSet类中，有一个HashMap类型的成员变量map，这就是组合模式的应用。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">extends</span> <span class="title class_">AbstractSet</span>&lt;E&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Set</span>&lt;E&gt;, Cloneable, java.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(Math.max((<span class="type">int</span>) (c.size()/<span class="number">.75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    HashSet(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">boolean</span> dummy) &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.containsKey(o);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.remove(o)==PRESENT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-LinkedHashMap"><a href="#2-LinkedHashMap" class="headerlink" title="2. LinkedHashMap"></a>2. LinkedHashMap</h2><p><code>LinkedHashMap</code>是<code>HashMap</code>的子类，与<code>HashMap</code>的实现基本一致，只是说在<code>HashMap</code>的基础上做了一些扩展：</p><p>所有的节点都有一个<code>before</code>指针和<code>after</code>指针，根据插入顺序形成一个<strong>双向链表</strong>。默认<code>accessOrder</code>是false，也就是按照<strong>插入顺序</strong>来排序的，每次新插入的元素都是插入到链表的末尾。<code>map.keySet().iterator().next()</code>第一个元素是最早插入的元素的key。<code>LinkedHashMap</code>可以用来实现LRU算法。(<code>accessOrder为true</code>，会按照访问顺序来排序。)</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20211001180827290.png" alt="image-20211001180827290"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// overrides of HashMap hook methods</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123; <span class="comment">// unlink</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">        (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">    p.before = p.after = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">        head = a;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b.after = a;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span>)</span><br><span class="line">        tail = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        a.before = b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeInsertion</span><span class="params">(<span class="type">boolean</span> evict)</span> &#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="literal">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        <span class="type">K</span> <span class="variable">key</span> <span class="operator">=</span> first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> &#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="literal">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="literal">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = p;</span><br><span class="line">        ++modCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据-LinkedHashMap-实现-LRUCache-的两种方式"><a href="#根据-LinkedHashMap-实现-LRUCache-的两种方式" class="headerlink" title="根据 LinkedHashMap 实现 LRUCache 的两种方式"></a>根据 LinkedHashMap 实现 LRUCache 的两种方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用LinkedHashMap实现LRU算法(accessOrder为false的实现方式)</span></span><br><span class="line"><span class="comment"> * LinkedHashMap默认的accessOrder为false，也就是会按照插入顺序排序，</span></span><br><span class="line"><span class="comment"> * 所以在插入新的键值对时，总是添加在队列尾部，</span></span><br><span class="line"><span class="comment"> * 如果是访问已存在的键值对，或者是put操作的键值对已存在，那么需要将键值对先移除再添加。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先删除旧的位置，再放入新位置</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> map.remove(key);</span><br><span class="line">        map.put(key, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            map.remove(key);</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//超出capacity，删除最久没用的,利用迭代器，删除第一个</span></span><br><span class="line">        <span class="keyword">if</span> (map.size() &gt; capacity) &#123;</span><br><span class="line">            map.remove(map.keySet().iterator().next());</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用LinkedHashMap实现LRU算法(accessOrder为true的实现方式</span></span><br><span class="line"><span class="comment"> * 如果是将accessOrder设置为true，get和put已有键值对时就不需要删除key了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache2</span> &#123;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    LinkedHashMap&lt;Integer, Integer&gt; linkedHashMap;</span><br><span class="line"></span><br><span class="line">    LRUCache2(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        linkedHashMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;Integer, Integer&gt;(<span class="number">16</span>, <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> linkedHashMap.get(key);</span><br><span class="line">        <span class="keyword">return</span> value == <span class="literal">null</span> ? -<span class="number">1</span> : value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> linkedHashMap.get(key);</span><br><span class="line">        linkedHashMap.put(key, val);</span><br><span class="line">        <span class="keyword">if</span> (linkedHashMap.size() &gt; capacity) &#123;</span><br><span class="line">            linkedHashMap.remove(linkedHashMap.keySet().iterator().next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">HashMap、HashTable和ConcurrentHashMap</summary>
    
    
    
    <category term="jdk源码" scheme="https://fabian4.site/blog/categories/jdk%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="java" scheme="https://fabian4.site/blog/tags/java/"/>
    
    <category term="源码" scheme="https://fabian4.site/blog/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="jdk" scheme="https://fabian4.site/blog/tags/jdk/"/>
    
    <category term="HashMap" scheme="https://fabian4.site/blog/tags/HashMap/"/>
    
    <category term="HashTable" scheme="https://fabian4.site/blog/tags/HashTable/"/>
    
    <category term="ConcurrentHashMap" scheme="https://fabian4.site/blog/tags/ConcurrentHashMap/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码解析</title>
    <link href="https://fabian4.site/blog/14375.html"/>
    <id>https://fabian4.site/blog/14375.html</id>
    <published>2021-03-26T16:00:00.000Z</published>
    <updated>2022-08-24T07:47:19.050Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashMap源码解析"><a href="#HashMap源码解析" class="headerlink" title="HashMap源码解析"></a>HashMap源码解析</h1><p>作为面试必问的hashmap，我们今天来一起来探究一下他的源码。这里先贴一张 hashmap 的内部类和部分方法函数</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210921204040629.png" alt="image-20210921204040629" style="zoom: 67%;" /><h2 id="一、什么是-哈希，-哈希函数（散列函数）"><a href="#一、什么是-哈希，-哈希函数（散列函数）" class="headerlink" title="一、什么是 哈希， 哈希函数（散列函数）"></a>一、什么是 哈希， 哈希函数（散列函数）</h2><blockquote><p>Hash，一般翻译做散列、杂凑，或音译为哈希，是把任意长度的<a href="https://baike.baidu.com/item/%E8%BE%93%E5%85%A5/5481954">输入</a>（又叫做预映射pre-image）通过散列算法变换成固定长度的<a href="https://baike.baidu.com/item/%E8%BE%93%E5%87%BA/11056752">输出</a>，该输出就是散列值。这种转换是一种<a href="https://baike.baidu.com/item/%E5%8E%8B%E7%BC%A9%E6%98%A0%E5%B0%84/5114126">压缩映射</a>，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的<a href="https://baike.baidu.com/item/%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81/4547744">消息摘要</a>的函数。</p></blockquote><p>上面是百度百科的解释。我们可以简单的概括为</p><ul><li>hash 就是将 <strong>任意的输入</strong> 通过 一种 <strong>特殊的算法</strong> 变成 <strong>长度固定</strong> 的输出。 </li><li>可以类似于一种摘要算法，获取我们输入内容的特征来生成一个简短的摘要</li><li>由于算法可以保证：相同的输入每次都是可以得到相同的输出，即hash值</li><li>但是也会发生：不同的输入哈希之后会得到相同的结果 <strong>即 哈希冲突</strong></li></ul><h3 id="object-中的-hashcode-方法"><a href="#object-中的-hashcode-方法" class="headerlink" title="object 中的 hashcode 方法"></a>object 中的 hashcode 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>方法本身是 native 方法，调用了底层的的类库，根据注释：</p><p>hashCode 遵守着如下的约定：</p><ul><li>Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application.</li><li>If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result.</li><li>It is not required that if two objects are unequal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables.</li></ul><p>翻译一下就是</p><ul><li><p>在程序一次执行的过程中，无论何时被调用，这个方法都会返回相同的值。但是程序的多次执行就不能保证每一次都相等</p></li><li><p>如果两个对象的 equals 方法返回 true，那么他们调用此方法就一定返回相同的结果</p></li><li><p>当然也不一定要确保：两个对象如果根据重写的 equals 方法返回为 false，那么此方法的返回结果一定不同。</p><blockquote><p>即：两个对象 根据重写的equals判断为不相等，此时的 hashcode 也可以相同</p><p>不过我们在写程序时应该注意尽量是不同的对象返回不同的hashcode，以便加强哈希效率，避免哈希冲突</p></blockquote></li></ul><h3 id="hashmap-采用的哈希方法"><a href="#hashmap-采用的哈希方法" class="headerlink" title="hashmap 采用的哈希方法"></a>hashmap 采用的哈希方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// 这里当 key 不为 null 的时候，将key的哈希值 和 右移16位的哈希值 做异或运算</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210924132832294.png" alt="image-20210924132832294"></p><p>将h无符号右移16为相当于将高区16位移动到了低区的16位，再与原hashcode做异或运算，可以<strong>将高低位二进制特征混合起来</strong>。即<strong>哈希扰动</strong>。</p><p>从上文可知高区的16位与原hashcode相比没有发生变化，低区的16位发生了变化。</p><p>我们都知道重新计算出的新哈希值在后面将会参与hashmap中数组槽位的计算，计算公式：(n - 1) &amp; hash，假如这时数组槽位有16个，则槽位计算如下：</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210924133141544.png" alt="image-20210924133141544"></p><p><strong>高区的16位很有可能会被数组槽位数的二进制码屏蔽，如果我们不做刚才移位异或运算，那么在计算槽位时将丢失高区特征</strong></p><p>也许你可能会说，即使丢失了高区特征不同hashcode也可以计算出不同的槽位来，但是细想当两个哈希码很接近时，那么这高区的一点点差异就<strong>可能导致一次哈希碰撞</strong>，所以这也是将性能做到极致的一种体现</p><h3 id="取余-和位运算-amp"><a href="#取余-和位运算-amp" class="headerlink" title="取余 % 和位运算 &amp;"></a>取余 % 和位运算 &amp;</h3><p>我们看到源码中存放值的时候：<code>(n - 1) &amp; hash</code></p><p>一般来说我们的认为都是将 哈希值 和数组的长度进行取模运算来获得数组的下标</p><ul><li>那么这里主要考虑到的是：<strong>位运算相比取模运算效率更高</strong></li></ul><p>关于为什么位运算能代替取模运算可以参考这个 👉<a href="https://www.cnblogs.com/ysocean/p/9054804.html"><strong>由HashMap哈希算法引出的求余%和与运算&amp;转换问题</strong></a></p><blockquote><p><strong>当 lenth &#x3D; 2n 时，X % length &#x3D; X &amp; (length - 1)</strong></p><ul><li>也就是说，长度为2的n次幂时，模运算 % 可以变换为按位与 &amp; 运算。</li></ul><p>　　比如：9 % 4 &#x3D; 1，9的二进制是 1001 ,4-1 &#x3D; 3,3的二进制是 0011。 9 &amp; 3 &#x3D; 1001 &amp; 0011 &#x3D; 0001 &#x3D; 1</p><p>　　再比如：12 % 8 &#x3D; 4,12的二进制是 1100,8-1 &#x3D; 7,7的二进制是 0111。12 &amp; 7 &#x3D; 1100 &amp; 0111 &#x3D; 0100 &#x3D; 4</p><ul><li>上面两个例子4和8都是2的n次幂，结论是成立的，那么当长度不为2的n次幂呢？</li></ul><p>　　比如：9 % 5 &#x3D; 4，9的二进制是 1001，5-1 &#x3D; 4,4的二进制是0100。9 &amp; 4 &#x3D; 1001 &amp; 0100 &#x3D; 0000 &#x3D; 0。显然是不成立的。</p></blockquote><h2 id="二、存储方式和数据结构"><a href="#二、存储方式和数据结构" class="headerlink" title="二、存储方式和数据结构"></a>二、存储方式和数据结构</h2><blockquote><p>问：HashMap的底层数据结构是什么</p><p>答：数组+链表+红黑树</p></blockquote><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210924142231035.png" alt="image-20210924142231035"></p><p>从上面的图中我们可以看出hashmap的存储结构，默认是数组+链表的结构。</p><p>当<strong>链表的长度大于 8 (默认)</strong> 的时候，链表会转换为红黑树。</p><ul><li><p>node 的数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment">* necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment">* (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment">* bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure></li><li><p>node 结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment">* TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.hash = hash;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>        &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>      &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * node结点的哈希值：将 key 的哈希值和 value 的哈希值进行异或运算</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>treenode 结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn</span></span><br><span class="line"><span class="comment">* extends Node) so can be used as extension of either regular or</span></span><br><span class="line"><span class="comment">* linked node.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="type">boolean</span> red;</span><br><span class="line">    TreeNode(<span class="type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>Hashmap中的链表大小超过八个时会自动转化为红黑树，当删除小于六时重新变为链表</p></blockquote><h2 id="三、构造方法和初始化"><a href="#三、构造方法和初始化" class="headerlink" title="三、构造方法和初始化"></a>三、构造方法和初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and load factor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment"> *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是最后被调用的构造方法，本质上就是先给 hashmap 初始两个值：<strong>initialCapacity</strong> 和 <strong>loadFactor</strong>：即初始容量和负载因子</p><h3 id="1-初始容量-initialCapacity"><a href="#1-初始容量-initialCapacity" class="headerlink" title="1. 初始容量 initialCapacity"></a>1. 初始容量 initialCapacity</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取 比 cap 大的最小的二进制数</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="comment">// 避免 输入为2的幂时 返回了 cap * 2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们以输入 9 为例</p><ol><li><p>n &#x3D; cap - 1;</p><p><strong>这里如果直接没有 -1 操作，如果输入的为2的幂，补1之后再+1，就不会返回原值而是 cap*2</strong></p><p>n &#x3D;  00000000 00000000 00000000 00001000</p></li><li><p>n |&#x3D; n &gt;&gt;&gt; 1</p><p>00000000 00000000 00000000 00001000  n</p><p>00000000 00000000 00000000 00000100  n &gt;&gt;&gt; 1</p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>00000000 00000000 00000000 00001100 &#x3D;&gt; n  </p></li><li><p>n |&#x3D; n &gt;&gt;&gt; 2</p><p>00000000 00000000 00000000 00001101  n</p><p>00000000 00000000 00000000 00000011  n &gt;&gt;&gt; 2</p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>00000000 00000000 00000000 00001111 &#x3D;&gt; n  </p></li><li><p>后续操作使得后续全为一</p></li><li><p>最后检查 大于零且小于最大值，将结果加一返回：16</p></li></ol><h3 id="2-负载因子-loadFactor"><a href="#2-负载因子-loadFactor" class="headerlink" title="2. 负载因子 loadFactor"></a>2. 负载因子 loadFactor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment"> * 这里我们可以看到 jdk 默认的负载因子为 0.75。当初始化未指定时就采用此值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure><p>这个值和我们hashmap的扩容有关：<strong>比如说当前的容器容量是16，负载因子是0.75,16*0.75&#x3D;12，也就是说，当容量达到了12的时候就会进行扩容操作</strong></p><p>此处我们可以从时间和空间的角度来考虑：</p><ul><li><strong>当负载因子的值为 1</strong><ul><li>此时只有当 node 数组被填满时才会进行扩容</li><li>既然哈希碰撞是不可避免的，那么此时底层的红黑树结构就会变得异常复杂，明显会降低查询效率</li><li>时间换空间</li></ul></li><li><strong>当负载因子的值为 0.5</strong><ul><li>此时当 node 数组被填充超过一半就会进行扩容</li><li>那么虽然可以降低底层红黑树的结构提高查找效率，也无疑牺牲了一半的存储空间</li><li>空间换时间</li></ul></li></ul><p>所以 0.75 的选择可以说是空间和时间的权衡。但最后的 0.75 也并不是简单的 0.5 和 1 的折中。</p><p>根据源码的注释，里面涉及到一些统计学方面的泊松分布的计算，这里就不展开细说了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Ideally, under random hashCodes, the frequency of</span></span><br><span class="line"><span class="comment">* nodes in bins follows a Poisson distribution</span></span><br><span class="line"><span class="comment">* (http://en.wikipedia.org/wiki/Poisson_distribution) with a</span></span><br><span class="line"><span class="comment">* parameter of about 0.5 on average for the default resizing</span></span><br><span class="line"><span class="comment">* threshold of 0.75, although with a large variance because of</span></span><br><span class="line"><span class="comment">* resizing granularity. Ignoring variance, the expected</span></span><br><span class="line"><span class="comment">* occurrences of list size k are (exp(-0.5) * pow(0.5, k) /</span></span><br><span class="line"><span class="comment">* factorial(k)). The first values are:</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 0:    0.60653066</span></span><br><span class="line"><span class="comment">* 1:    0.30326533</span></span><br><span class="line"><span class="comment">* 2:    0.07581633</span></span><br><span class="line"><span class="comment">* 3:    0.01263606</span></span><br><span class="line"><span class="comment">* 4:    0.00157952</span></span><br><span class="line"><span class="comment">* 5:    0.00015795</span></span><br><span class="line"><span class="comment">* 6:    0.00001316</span></span><br><span class="line"><span class="comment">* 7:    0.00000094</span></span><br><span class="line"><span class="comment">* 8:    0.00000006</span></span><br><span class="line"><span class="comment">* more: less than 1 in ten million</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="四、添加元素和查找元素"><a href="#四、添加元素和查找元素" class="headerlink" title="四、添加元素和查找元素"></a>四、添加元素和查找元素</h2><h3 id="1-put-方法"><a href="#1-put-方法" class="headerlink" title="1. put 方法"></a>1. put 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment"> * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment"> * value is replaced.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment"> *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里贴一张流程图并且附上加了注释的源码</strong></p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210927232504843.png" alt="image-20210927232504843"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 密钥的散列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 键值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 要放置的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent 如果为真，则不更改现有值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict 如果为 false，则表处于创建模式。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 以前的值，如果没有，则为 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line"></span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    Node&lt;K,V&gt; p;</span><br><span class="line">    <span class="type">int</span> n, i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// table数组为空或者长度为零则 调用 resize() 来初始化数组</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算数组下标，如果结点为空则新建结点放入</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        K k;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果和头节点哈希值相等，则直接命中头节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是树节点进行红黑树的操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 剩下的就是链表节点操作</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 走到尾结点则新建节点追加在后面</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 如果链表长度超过阈值则转化为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 当未走到尾结点时，根据哈希值是否相等来判断是否命中</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">// 根据标识位判断是否替换</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 提供给 LinkedHashMap 的回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新修改次数来保证迭代器的快速失败机制</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 超过阈值就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供给 LinkedHashMap 的回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-get-方法-和-containsKey-方法"><a href="#2-get-方法-和-containsKey-方法" class="headerlink" title="2. get 方法 和 containsKey 方法"></a>2. get 方法 和 containsKey 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(hash(key), key) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里我们可以看到底层都是调用了 <code>getNode()</code>这个方法通过哈希值和键值去搜索结点</p><p><code>containsKey</code>：如果找到结点则返回 true，否则返回 false</p><p><code>get</code>：如果找到结点返回结点的 value 值，否则返回 null</p><ul><li>不过要注意的是，这里如果返回了 null 可能有<strong>两种原因</strong>：<ol><li><strong>key 不存在</strong></li><li><strong>key 存在，但是存储的结果为 null</strong></li></ol></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    Node&lt;K,V&gt;[] tab; </span><br><span class="line">    Node&lt;K,V&gt; first, e; </span><br><span class="line">    <span class="type">int</span> n; </span><br><span class="line">    K k;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先对头节点做判断</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果是红黑树结点</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 最后遍历链表</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、扩容和rehash"><a href="#五、扩容和rehash" class="headerlink" title="五、扩容和rehash"></a>五、扩容和rehash</h2><p>这里我们先上<code>resize()</code>函数的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当原结构有数据的时候</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果之前的容量大于最大容量，即将阈值调整到最大并不再扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当新容量小于最大容量 旧容量大于默认初始值时，对阈值 double</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果一开始给定了初始容量，就取初始化时的值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后采取默认值</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过最大容量和负载因子计算阈值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 newCap 创建新的数组</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不为空，搬运之前map的存储内容，遍历每一个数组</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 将链表分成两个组，根据哈希值一部分留在原来数组位置，一部分向前 oldCap</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数一般提供两个功能：</p><ul><li>在构造函数之后，第一次<code>put()</code>发现数组为空则会调用，实现懒加载</li><li>当存储的数据超过阈值时调用，来实现扩容</li></ul><p><strong>经过rehash之后，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置</strong></p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210929231418128.png" alt="image-20210929231418128"></p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210929231439803.png" alt="image-20210929231439803"></p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210929231504675.png" alt="image-20210929231504675"></p><blockquote><ul><li><p>扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。</p></li><li><p>负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。</p></li></ul></blockquote><h2 id="六、头插法和尾插法"><a href="#六、头插法和尾插法" class="headerlink" title="六、头插法和尾插法"></a>六、头插法和尾插法</h2><blockquote><p>JDK8以前是头插法，JDK8后是尾插法</p></blockquote><p>头插法和尾插法，顾名思义就是插入链表的时候插入在链表头部还是尾部。</p><p><strong>由于<code>HashMap</code>在扩容时采用头插法会造成链表死循环，故在JDK8之后调整为尾插法</strong>。</p><p>这里贴一个别人的分析</p><ul><li>前提条件：<ol><li>hash算法为简单的用key mod链表的大小。</li><li>最开始hash表size&#x3D;2，key&#x3D;3,7,5，则都在table[1]中。</li><li>然后进行resize，使size变成4。</li><li>未resize前的数据结构如下：</li></ol></li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfecWQvk4vhdQnUBzictjvKTV8KojY8VrMVmMVK0mT4Ric2icyc3icUzVuQCuLGpzOgZxOeHd8MgfgNuXQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p><p>如果在单线程环境下，最后的结果如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfecWQvk4vhdQnUBzictjvKTVCB9USBX1WYQPWzj7iciaTjlyHZpq2MlWRasFGPLvXEM1zf0tiaictibYSsg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p><p>这里的转移过程，不再进行详述，只要理解transfer函数在做什么，其转移过程以及如何对链表进行反转应该不难。</p><p>然后在多线程环境下，假设有两个线程A和B都在进行put操作。线程A在执行到transfer函数中第11行代码处挂起，因为该函数在这里分析的地位非常重要，因此再次贴出来。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfecWQvk4vhdQnUBzictjvKTVRtdI81vOOgiayBNwiaru5saibodJiaUAxBsic9Clib8qu2SZWQd6MlokUF9g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p><p>此时线程A中运行结果如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfecWQvk4vhdQnUBzictjvKTVCrq6iaOLPVE0kE1zgCQYmWKTUPBGAm1icoUUR8ADvhUwTLoQ0jZzBr1g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p><p>线程A挂起后，此时线程B正常执行，并完成resize操作，结果如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfecWQvk4vhdQnUBzictjvKTVGWwiboVcEoovrdg7qUibUcwrLTuww3rbptiaFoZI11NaTj0tDAxybhwag/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p><p><strong>这里需要特别注意的点：由于线程B已经执行完毕，根据Java内存模型，现在newTable和table中的Entry都是主存中最新值：7.next&#x3D;3，3.next&#x3D;null。</strong></p><p>此时切换到线程A上，在线程A挂起时内存中值如下：e&#x3D;3，next&#x3D;7，newTable[3]&#x3D;null，代码执行过程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newTable[3]=e ----&gt; newTable[3]=3</span><br><span class="line">e=next ----&gt; e=7</span><br></pre></td></tr></table></figure><p>此时结果如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfecWQvk4vhdQnUBzictjvKTVSPJ6RwE1NHxILdUiaIFib3NHncYPI6hfE0NvKWKu0UANfsFsWPicWKOvA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p><p>继续循环：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e=7</span><br><span class="line">next=e.next ----&gt; next=3【从主存中取值】</span><br><span class="line">e.next=newTable[3] ----&gt; e.next=3【从主存中取值】</span><br><span class="line">newTable[3]=e ----&gt; newTable[3]=7</span><br><span class="line">e=next ----&gt; e=3</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfecWQvk4vhdQnUBzictjvKTVlVDoSg5Kvo0maS6h9RNZVRd7sMsZtu5homM7KI9ibEk47WtJXibgXfcg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p><p>再次进行循环：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e=3</span><br><span class="line">next=e.next ----&gt; next=null</span><br><span class="line">e.next=newTable[3] ----&gt; e.next=7 即：3.next=7</span><br><span class="line">newTable[3]=e ----&gt; newTable[3]=3</span><br><span class="line">e=next ----&gt; e=null</span><br></pre></td></tr></table></figure><p>注意此次循环：e.next&#x3D;7，而在上次循环中7.next&#x3D;3，出现环形链表，并且此时e&#x3D;null循环结束。</p><p>结果如下：</p><p><strong><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfecWQvk4vhdQnUBzictjvKTVU7APPu5l0lKpFRwBS0KFISCE1h9iarAQnv7zpXz2k9DnZPIr2AWqhiaw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></strong></p><p>在后续操作中只要涉及轮询hashmap的数据结构，就会在这里发生死循环，造成悲剧。</p>]]></content>
    
    
    <summary type="html">HashMap源码解析</summary>
    
    
    
    <category term="jdk源码" scheme="https://fabian4.site/blog/categories/jdk%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="java" scheme="https://fabian4.site/blog/tags/java/"/>
    
    <category term="源码" scheme="https://fabian4.site/blog/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="jdk" scheme="https://fabian4.site/blog/tags/jdk/"/>
    
    <category term="HashMap" scheme="https://fabian4.site/blog/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>源码环境搭建</title>
    <link href="https://fabian4.site/blog/20209.html"/>
    <id>https://fabian4.site/blog/20209.html</id>
    <published>2021-03-17T16:00:00.000Z</published>
    <updated>2022-08-24T07:47:19.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="源码环境搭建"><a href="#源码环境搭建" class="headerlink" title="源码环境搭建"></a>源码环境搭建</h1><h2 id="为什么要读源码"><a href="#为什么要读源码" class="headerlink" title="为什么要读源码"></a>为什么要读源码</h2><blockquote><p>还记得之前有一次面试，面试官上来就直接开始问：</p><p><strong>你看过 JDK 源码吗</strong></p></blockquote><p>作为一名的开发人员，学习源码是我们在技术成长的道路上不可或缺的一步。在源码的翻阅学习和探究中，你将会</p><ul><li>知晓和熟悉底层的代码逻辑原理</li><li>理解代码的设计思路和设计原因</li><li>培养抽象封装的代码思维</li><li>以此来更好的服务于上层的业务逻辑需求</li><li>面试必问（那不得好好学）</li></ul><p>而作为一份经历过多次的迭代积累以及无数业务场景考验的基石，更是值得我们深入的去学习。</p><p>虽然我们平时也是可以在idea中跟进源码，进行翻阅查看，但是由于做了保护，我们是无法对其修改和添加注释的，所以我们这里将源码单独拿出来作为一个项目工程，可以更方面我们的总结学习。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="获取源码"><a href="#获取源码" class="headerlink" title="获取源码"></a>获取源码</h3><p>其实我们不用去网上下载源码，重要你的电脑下载安装过 JDK 环境，那么你的电脑上就有一份打包好的源码。</p><p>找到你本地的 jdk 安装目录，如果忘记了可以去看一下之前设置的环境变量</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210921122749591.png" alt="image-20210921122749591"></p><p>将这个压缩包<strong>拷贝</strong>出来，解压后导入到idea工程里面就可以了</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210921123147943.png" alt="image-20210921123147943"></p><h3 id="一些常用的包"><a href="#一些常用的包" class="headerlink" title="一些常用的包"></a>一些常用的包</h3><ul><li>java.lang：语言包<ul><li>object类</li><li>数据类型包装类</li><li>数学工具类 Math</li><li>字符串类</li><li>系统和运行时类</li><li>操作类：Class和ClassLoader类</li><li>线程类</li><li>错误和异常类</li></ul></li><li>java.util：实用工具包<ul><li>日期类</li><li>数据结构集合类</li><li>随机数类</li><li>正则表达式</li><li>日志类</li><li>并发安全类</li></ul></li><li>java.awt：抽象窗口工具包</li><li>java.swing：轻量级的窗口工具包，GUI程序设计包</li><li>java.io：输入输出包</li><li>java.net：网络函数包</li></ul><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这个时候我们就可以翻阅源码，并且在源码中做出注释来帮助我们更好的理解和学习。</p><blockquote><p>但是如果需要对我们改了之后的代码进行编译调试，那么目前这个环境是远远不能满足的。</p><p>因为这个时候程序依赖的还是我们之前安装的官方，并不会依赖我们修改后的 JDK。</p><p>所以此时就需要我们去编译一套属于我们自己的 JDK 了。</p></blockquote>]]></content>
    
    
    <summary type="html">源码环境搭建</summary>
    
    
    
    <category term="jdk源码" scheme="https://fabian4.site/blog/categories/jdk%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="java" scheme="https://fabian4.site/blog/tags/java/"/>
    
    <category term="源码" scheme="https://fabian4.site/blog/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="jdk" scheme="https://fabian4.site/blog/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>Spring 中的9种设计模式</title>
    <link href="https://fabian4.site/blog/22066.html"/>
    <id>https://fabian4.site/blog/22066.html</id>
    <published>2021-03-09T16:00:00.000Z</published>
    <updated>2022-08-24T07:47:19.056Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-中的9种设计模式"><a href="#Spring-中的9种设计模式" class="headerlink" title="Spring 中的9种设计模式"></a>Spring 中的9种设计模式</h1><h2 id="一、简单工厂"><a href="#一、简单工厂" class="headerlink" title="一、简单工厂"></a>一、简单工厂</h2><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>BeanFactory。Spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获取Bean对象，但是否在传入参数后创建还是传入参数前创建这个要根据具体情况来定</p><h3 id="实质"><a href="#实质" class="headerlink" title="实质"></a>实质</h3><p>由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="Bean容器的启动阶段"><a href="#Bean容器的启动阶段" class="headerlink" title="Bean容器的启动阶段"></a>Bean容器的启动阶段</h4><ul><li><p>读取bean的xml配置文件,将bean元素分别转换成一个BeanDefinition对象。</p></li><li><p>然后通过BeanDefinitionRegistry将这些bean注册到beanFactory中，保存在它的一个ConcurrentHashMap中。</p></li><li><p>将BeanDefinition注册到了beanFactory之后，在这里Spring为我们提供了一个扩展的接口，允许我们通过实现接口BeanFactoryPostProcessor 在此处来插入我们定义的代码。</p><p>典型的例子就是：PropertyPlaceholderConfigurer，我们一般在配置数据库的dataSource时使用到的占位符的值，就是它注入进去的。</p></li></ul><h4 id="容器中bean的实例化阶段"><a href="#容器中bean的实例化阶段" class="headerlink" title="容器中bean的实例化阶段"></a>容器中bean的实例化阶段</h4><p>实例化阶段主要是通过反射或者CGLIB对bean进行实例化，在这个阶段Spring又给我们暴露了很多的扩展点：</p><ul><li><strong>各种的Aware接口</strong> ，比如 BeanFactoryAware，对于实现了这些Aware接口的bean，在实例化bean时Spring会帮我们注入对应的BeanFactory的实例。</li><li><strong>BeanPostProcessor接口</strong> ，实现了BeanPostProcessor接口的bean，在实例化bean时Spring会帮我们调用接口中的方法。</li><li><strong>InitializingBean接口</strong> ，实现了InitializingBean接口的bean，在实例化bean时Spring会帮我们调用接口中的方法。</li><li><strong>DisposableBean接口</strong> ，实现了BeanPostProcessor接口的bean，在该bean死亡时Spring会帮我们调用接口中的方法。</li></ul><h3 id="设计意义"><a href="#设计意义" class="headerlink" title="设计意义"></a>设计意义</h3><p><strong>松耦合。</strong> 可以将原来硬编码的依赖，通过Spring这个beanFactory这个工厂来注入依赖，也就是说原来只有依赖方和被依赖方，现在我们引入了第三方——spring这个beanFactory，由它来解决bean之间的依赖问题，达到了松耦合的效果.</p><p><strong>bean的额外处理。</strong> 通过Spring接口的暴露，在实例化bean的阶段我们可以进行一些额外的处理，这些额外的处理只需要让bean实现对应的接口即可，那么spring就会在bean的生命周期调用我们实现的接口来处理该bean。<code>[非常重要]</code></p><h2 id="二、工厂方法"><a href="#二、工厂方法" class="headerlink" title="二、工厂方法"></a>二、工厂方法</h2><h3 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h3><p>FactoryBean接口。</p><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p>实现了FactoryBean接口的bean是一类叫做factory的bean。其特点是，spring会在使用getBean()调用获得该bean时，会自动调用该bean的getObject()方法，所以返回的不是factory这个bean，而是这个bean.getOjbect()方法的返回值。</p><p><strong>例子：</strong>典型的例子有spring与mybatis的结合。</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210319082150862.png" alt="image-20210319082150862" style="zoom:50%;" /><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>我们看上面该bean，因为实现了FactoryBean接口，所以返回的不是 SqlSessionFactoryBean 的实例，而是它的 SqlSessionFactoryBean.getObject() 的返回值。</p><h2 id="三、单例模式"><a href="#三、单例模式" class="headerlink" title="三、单例模式"></a>三、单例模式</h2><p>Spring依赖注入Bean实例默认是单例的。</p><p>Spring的依赖注入（包括lazy-init方式）都是发生在AbstractBeanFactory的getBean里。getBean的doGetBean方法调用getSingleton进行bean的创建。</p><p>分析 getSingleton() 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName)</span>&#123;</span><br><span class="line">    <span class="comment">//参数true设置标识允许早期依赖</span></span><br><span class="line">    <span class="keyword">return</span> getSingleton(beanName,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, <span class="type">boolean</span> allowEarlyReference)</span> &#123;</span><br><span class="line">    <span class="comment">//检查缓存中是否存在实例</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="comment">//如果为空，则锁定全局变量并进行处理。</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>.singletonObjects) &#123;</span><br><span class="line">            <span class="comment">//如果此bean正在加载，则不处理</span></span><br><span class="line">            singletonObject = <span class="built_in">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="literal">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                <span class="comment">//当某些方法需要提前初始化的时候则会调用addSingleFactory 方法将对应的ObjectFactory初始化策略存储在singletonFactories</span></span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="built_in">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//调用预先设定的getObject方法</span></span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="comment">//记录在缓存中，earlysingletonObjects和singletonFactories互斥</span></span><br><span class="line">                    <span class="built_in">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="built_in">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (singletonObject != NULL_OBJECT ? singletonObject : <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getSingleton-过程图"><a href="#getSingleton-过程图" class="headerlink" title="getSingleton()过程图"></a>getSingleton()过程图</h3><blockquote><p>spring依赖注入时，使用了 双重判断加锁 的单例模式</p></blockquote><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210319082321016.png" alt="image-20210319082321016" style="zoom:67%;" /><h3 id="单例模式定义"><a href="#单例模式定义" class="headerlink" title="单例模式定义"></a>单例模式定义</h3><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><h3 id="spring对单例的实现"><a href="#spring对单例的实现" class="headerlink" title="spring对单例的实现"></a>spring对单例的实现</h3><p>spring中的单例模式完成了后半句话，即提供了全局的访问点BeanFactory。但没有从构造器级别去控制单例，这是因为spring管理的是任意的java对象。</p><h2 id="四、适配器模式"><a href="#四、适配器模式" class="headerlink" title="四、适配器模式"></a>四、适配器模式</h2><h3 id="实现方式-2"><a href="#实现方式-2" class="headerlink" title="实现方式"></a>实现方式</h3><p>SpringMVC中的适配器HandlerAdatper。</p><h3 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h3><p>HandlerAdatper根据Handler规则执行不同的Handler。</p><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>DispatcherServlet根据HandlerMapping返回的handler，向HandlerAdatper发起请求，处理Handler。</p><p>HandlerAdapter根据规则找到对应的Handler并让其执行，执行完毕后Handler会向HandlerAdapter返回一个ModelAndView，最后由HandlerAdapter向DispatchServelet返回一个ModelAndView。</p><h3 id="实现意义"><a href="#实现意义" class="headerlink" title="实现意义"></a>实现意义</h3><p>HandlerAdatper使得Handler的扩展变得容易，只需要增加一个新的Handler和一个对应的HandlerAdapter即可。</p><p>因此Spring定义了一个适配接口，使得每一种Controller有一种对应的适配器实现类，让适配器代替controller执行相应的方法。这样在扩展Controller时，只需要增加一个适配器类就完成了SpringMVC的扩展了。</p><h2 id="五、装饰器模式"><a href="#五、装饰器模式" class="headerlink" title="五、装饰器模式"></a>五、装饰器模式</h2><h3 id="实现方式-3"><a href="#实现方式-3" class="headerlink" title="实现方式"></a>实现方式</h3><p>Spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。</p><h3 id="实质-1"><a href="#实质-1" class="headerlink" title="实质"></a>实质</h3><p>动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。</p><h2 id="六、代理模式"><a href="#六、代理模式" class="headerlink" title="六、代理模式"></a>六、代理模式</h2><h3 id="实现方式-4"><a href="#实现方式-4" class="headerlink" title="实现方式"></a>实现方式</h3><p>AOP底层，就是动态代理模式的实现。</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>在内存中构建的，不需要手动编写代理类</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>需要手工编写代理类，代理类引用被代理对象。</p><h3 id="实现原理-3"><a href="#实现原理-3" class="headerlink" title="实现原理"></a>实现原理</h3><p>切面在应用运行的时刻被织入。一般情况下，在织入切面时，AOP容器会为目标对象创建动态的创建一个代理对象。SpringAOP就是以这种方式织入切面的。</p><h3 id="织入"><a href="#织入" class="headerlink" title="织入"></a>织入</h3><p>把切面应用到目标对象并创建新的代理对象的过程。</p><h2 id="七、观察者模式"><a href="#七、观察者模式" class="headerlink" title="七、观察者模式"></a>七、观察者模式</h2><h3 id="实现方式-5"><a href="#实现方式-5" class="headerlink" title="实现方式"></a>实现方式</h3><p>spring的事件驱动模型使用的是 观察者模式 ，Spring中Observer模式常用的地方是listener的实现。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p><strong>事件机制的实现需要三个部分,事件源,事件,事件监听器</strong></p><h4 id="ApplicationEvent抽象类-事件"><a href="#ApplicationEvent抽象类-事件" class="headerlink" title="ApplicationEvent抽象类[事件]"></a>ApplicationEvent抽象类<code>[事件]</code></h4><p>继承自jdk的EventObject,所有的事件都需要继承ApplicationEvent,并且通过构造器参数source得到事件源.</p><p>该类的实现类ApplicationContextEvent表示ApplicaitonContext的容器事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ApplicationEvent</span> <span class="keyword">extends</span> <span class="title class_">EventObject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">7099057708183571937L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> timestamp;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ApplicationEvent</span><span class="params">(Object source)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(source);</span><br><span class="line">    <span class="built_in">this</span>.timestamp = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">getTimestamp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.timestamp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ApplicationListener接口-事件监听器"><a href="#ApplicationListener接口-事件监听器" class="headerlink" title="ApplicationListener接口[事件监听器]"></a>ApplicationListener接口<code>[事件监听器]</code></h4><p>继承自jdk的EventListener,所有的监听器都要实现这个接口。</p><p>这个接口只有一个onApplicationEvent()方法,该方法接受一个ApplicationEvent或其子类对象作为参数,在方法体中,可以通过不同对Event类的判断来进行相应的处理。</p><p>当事件触发时所有的监听器都会收到消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationListener</span>&lt;E <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span>&gt; <span class="keyword">extends</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(E event)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ApplicationContext接口-事件源"><a href="#ApplicationContext接口-事件源" class="headerlink" title="ApplicationContext接口[事件源]"></a>ApplicationContext接口<code>[事件源]</code></h4><p>ApplicationContext是spring中的全局容器，翻译过来是”应用上下文”。</p><p>实现了ApplicationEventPublisher接口。</p><p>负责读取bean的配置文档,管理bean的加载,维护bean之间的依赖关系,可以说是负责bean的整个生命周期,再通俗一点就是我们平时所说的IOC容器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationEventPublisher</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(ApplicationEvent event)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(ApplicationEvent event)</span> &#123;</span><br><span class="line">    Assert.notNull(event, <span class="string">&quot;Event must not be null&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">&quot;Publishing event in &quot;</span> + getDisplayName() + <span class="string">&quot;: &quot;</span> + event);</span><br><span class="line">    &#125;</span><br><span class="line">    getApplicationEventMulticaster().multicastEvent(event);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.parent != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.parent.publishEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ApplicationEventMulticaster抽象类-事件源中publishEvent方法需要调用其方法getApplicationEventMulticaster"><a href="#ApplicationEventMulticaster抽象类-事件源中publishEvent方法需要调用其方法getApplicationEventMulticaster" class="headerlink" title="ApplicationEventMulticaster抽象类[事件源中publishEvent方法需要调用其方法getApplicationEventMulticaster]"></a>ApplicationEventMulticaster抽象类<code>[事件源中publishEvent方法需要调用其方法getApplicationEventMulticaster]</code></h4><p>属于事件广播器,它的作用是把Applicationcontext发布的Event广播给所有的监听器.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractApplicationContext</span> <span class="keyword">extends</span> <span class="title class_">DefaultResourceLoader</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">ConfigurableApplicationContext</span>, DisposableBean &#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationEventMulticaster applicationEventMulticaster;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">registerListeners</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Register statically specified listeners first.</span></span><br><span class="line">    <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;</span><br><span class="line">    getApplicationEventMulticaster().addApplicationListener(listener);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Do not initialize FactoryBeans here: We need to leave all regular beans</span></span><br><span class="line">    <span class="comment">// uninitialized to let post-processors apply to them!</span></span><br><span class="line">    String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (String lisName : listenerBeanNames) &#123;</span><br><span class="line">    getApplicationEventMulticaster().addApplicationListenerBean(lisName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="八、策略模式"><a href="#八、策略模式" class="headerlink" title="八、策略模式"></a>八、策略模式</h2><h3 id="实现方式-6"><a href="#实现方式-6" class="headerlink" title="实现方式"></a>实现方式</h3><p>Spring框架的资源访问Resource接口。该接口提供了更强的资源访问能力，Spring 框架本身大量使用了 Resource 接口来访问底层资源。</p><h3 id="Resource-接口介绍"><a href="#Resource-接口介绍" class="headerlink" title="Resource 接口介绍"></a>Resource 接口介绍</h3><p>source 接口是具体资源访问策略的抽象，也是所有资源访问类所实现的接口。</p><h4 id="Resource-接口主要提供了如下几个方法"><a href="#Resource-接口主要提供了如下几个方法" class="headerlink" title="Resource 接口主要提供了如下几个方法:"></a>Resource 接口主要提供了如下几个方法:</h4><ul><li><strong>getInputStream()：</strong> 定位并打开资源，返回资源对应的输入流。每次调用都返回新的输入流。调用者必须负责关闭输入流。</li><li><strong>exists()：</strong> 返回 Resource 所指向的资源是否存在。</li><li><strong>isOpen()：</strong> 返回资源文件是否打开，如果资源文件不能多次读取，每次读取结束应该显式关闭，以防止资源泄漏。</li><li><strong>getDescription()：</strong> 返回资源的描述信息，通常用于资源处理出错时输出该信息，通常是全限定文件名或实际 URL。</li><li><strong>getFile：</strong> 返回资源对应的 File 对象。</li><li><strong>getURL：</strong> 返回资源对应的 URL 对象。</li></ul><p>最后两个方法通常无须使用，仅在通过简单方式访问无法实现时，Resource 提供传统的资源访问的功能。</p><p>Resource 接口本身没有提供访问任何底层资源的实现逻辑，<strong>针对不同的底层资源，Spring 将会提供不同的 Resource 实现类，不同的实现类负责不同的资源访问逻辑。</strong></p><h4 id="Spring-为-Resource-接口提供了如下实现类："><a href="#Spring-为-Resource-接口提供了如下实现类：" class="headerlink" title="Spring 为 Resource 接口提供了如下实现类："></a>Spring 为 Resource 接口提供了如下实现类：</h4><ul><li><strong>UrlResource：</strong> 访问网络资源的实现类。</li><li><strong>ClassPathResource：</strong> 访问类加载路径里资源的实现类。</li><li><strong>FileSystemResource：</strong> 访问文件系统里资源的实现类。</li><li><strong>ServletContextResource：</strong> 访问相对于 ServletContext 路径里的资源的实现类.</li><li><strong>InputStreamResource：</strong> 访问输入流资源的实现类。</li><li><strong>ByteArrayResource：</strong> 访问字节数组资源的实现类。</li></ul><p>这些 Resource 实现类，针对不同的的底层资源，提供了相应的资源访问逻辑，并提供便捷的包装，以利于客户端程序的资源访问。</p><h2 id="九、模版方法模式"><a href="#九、模版方法模式" class="headerlink" title="九、模版方法模式"></a>九、模版方法模式</h2><h3 id="经典模板方法定义"><a href="#经典模板方法定义" class="headerlink" title="经典模板方法定义"></a>经典模板方法定义</h3><p>父类定义了骨架（调用哪些方法及顺序），某些特定方法由子类实现。</p><p>最大的好处：代码复用，减少重复代码。除了子类要实现的特定方法，其他方法及方法调用顺序都在父类中预先写好了。</p><h3 id="所以父类模板方法中有两类方法"><a href="#所以父类模板方法中有两类方法" class="headerlink" title="所以父类模板方法中有两类方法"></a>所以父类模板方法中有两类方法</h3><p><strong>共同的方法：</strong> 所有子类都会用到的代码</p><p><strong>不同的方法：</strong> 子类要覆盖的方法，分为两种：</p><ul><li>抽象方法：父类中的是抽象方法，子类必须覆盖</li><li>钩子方法：父类中是一个空方法，子类继承了默认也是空的</li></ul><p>注：为什么叫钩子，子类可以通过这个钩子（方法），控制父类，因为这个钩子实际是父类的方法（空方法）！</p><h3 id="Spring-模板方法模式实质"><a href="#Spring-模板方法模式实质" class="headerlink" title="Spring 模板方法模式实质"></a>Spring 模板方法模式实质</h3><p>是模板方法模式和回调模式的结合，是Template Method不需要继承的另一种实现方式。Spring几乎所有的外接扩展都采用这种模式。</p><h3 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h3><p>JDBC的抽象和对Hibernate的集成，都采用了一种理念或者处理方式，那就是模板方法模式与相应的Callback接口相结合。</p><p>采用模板方法模式是为了以一种统一而集中的方式来处理资源的获取和释放，以JdbcTempalte为例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">JdbcTemplate</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">final</span> Object execute（String sql）&#123;</span><br><span class="line">        Connection con=<span class="literal">null</span>;</span><br><span class="line">        Statement stmt=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            con=getConnection（）;</span><br><span class="line">            stmt=con.createStatement（）;</span><br><span class="line">            Object retValue=executeWithStatement（stmt,sql）;</span><br><span class="line">            <span class="keyword">return</span> retValue;</span><br><span class="line">        &#125;<span class="keyword">catch</span>（SQLException e）&#123;</span><br><span class="line">             ...</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            closeStatement（stmt）;</span><br><span class="line">            releaseConnection（con）;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Object executeWithStatement（Statement stmt, String sql）;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引入回调原因"><a href="#引入回调原因" class="headerlink" title="引入回调原因"></a>引入回调原因</h3><p>JdbcTemplate是抽象类，不能够独立使用，我们每次进行数据访问的时候都要给出一个相应的子类实现,这样肯定不方便，所以就引入了回调。</p><p>回调代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StatementCallback</span>&#123;</span><br><span class="line">    Object doWithStatement（Statement stmt）;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用回调方法重写JdbcTemplate方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcTemplate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object execute（StatementCallback callback）&#123;</span><br><span class="line">        Connection con=<span class="literal">null</span>;</span><br><span class="line">        Statement stmt=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            con=getConnection（）;</span><br><span class="line">            stmt=con.createStatement（）;</span><br><span class="line">            Object retValue=callback.doWithStatement（stmt）;</span><br><span class="line">            <span class="keyword">return</span> retValue;</span><br><span class="line">        &#125;<span class="keyword">catch</span>（SQLException e）&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            closeStatement（stmt）;</span><br><span class="line">            releaseConnection（con）;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...<span class="comment">//其它方法定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Jdbc使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JdbcTemplate jdbcTemplate=...;</span><br><span class="line">    <span class="keyword">final</span> String sql=...;</span><br><span class="line">    StatementCallback callback=<span class="keyword">new</span> <span class="title class_">StatementCallback</span>()&#123;</span><br><span class="line">    <span class="keyword">public</span> Object=doWithStatement(Statement stmt)&#123;</span><br><span class="line">        <span class="keyword">return</span> ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">jdbcTemplate.execute(callback);</span><br></pre></td></tr></table></figure><h3 id="为什么JdbcTemplate没有使用继承？"><a href="#为什么JdbcTemplate没有使用继承？" class="headerlink" title="为什么JdbcTemplate没有使用继承？"></a>为什么JdbcTemplate没有使用继承？</h3><p>因为这个类的方法太多，但是我们还是想用到JdbcTemplate已有的稳定的、公用的数据库连接，那么我们怎么办呢？</p><p>我们可以把变化的东西抽出来作为一个参数传入JdbcTemplate的方法中。但是变化的东西是一段代码，而且这段代码会用到JdbcTemplate中的变量。怎么办？</p><p>那我们就用回调对象吧。在这个回调对象中定义一个操纵JdbcTemplate中变量的方法，我们去实现这个方法，就把变化的东西集中到这里了。然后我们再传入这个回调对象到JdbcTemplate，从而完成了调用。</p>]]></content>
    
    
    <summary type="html">Spring 中的9种设计模式</summary>
    
    
    
    <category term="Spring" scheme="https://fabian4.site/blog/categories/Spring/"/>
    
    
    <category term="java" scheme="https://fabian4.site/blog/tags/java/"/>
    
    <category term="Spring" scheme="https://fabian4.site/blog/tags/Spring/"/>
    
    <category term="设计模式" scheme="https://fabian4.site/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 排序算法</title>
    <link href="https://fabian4.site/blog/58938.html"/>
    <id>https://fabian4.site/blog/58938.html</id>
    <published>2021-03-07T16:00:00.000Z</published>
    <updated>2022-08-24T07:47:19.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA-排序算法"><a href="#JAVA-排序算法" class="headerlink" title="JAVA 排序算法"></a>JAVA 排序算法</h1><h2 id="一、冒泡排序（Bubble-Sort）"><a href="#一、冒泡排序（Bubble-Sort）" class="headerlink" title="一、冒泡排序（Bubble Sort）"></a>一、冒泡排序（Bubble Sort）</h2><h3 id="1-算法简介"><a href="#1-算法简介" class="headerlink" title="1. 算法简介"></a>1. 算法简介</h3><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 </p><h3 id="2-算法描述"><a href="#2-算法描述" class="headerlink" title="2. 算法描述"></a>2. 算法描述</h3><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><h3 id="3-动态演示"><a href="#3-动态演示" class="headerlink" title="3. 动态演示"></a>3. 动态演示</h3><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/849589-20171015223238449-2146169197.gif" alt="img"></p><h3 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4. 代码实现"></a>4. 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] bubbleSort(<span class="type">int</span>[] array)&#123;</span><br><span class="line">    <span class="keyword">if</span>(array.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;array.length - <span class="number">1</span> - i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(array[j] &gt; array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[j];</span><br><span class="line">                    array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                    array[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-算法分析"><a href="#5-算法分析" class="headerlink" title="5. 算法分析"></a>5. 算法分析</h3><ul><li><strong>最佳情况：T(n) &#x3D; O(n)</strong></li><li><strong>最差情况：T(n) &#x3D; O(n2)</strong></li><li><strong>平均情况：T(n) &#x3D; O(n2)</strong></li></ul><h2 id="二、选择排序（Selection-Sort）"><a href="#二、选择排序（Selection-Sort）" class="headerlink" title="二、选择排序（Selection Sort）"></a>二、选择排序（Selection Sort）</h2><h3 id="1-算法简介-1"><a href="#1-算法简介-1" class="headerlink" title="1. 算法简介"></a>1. 算法简介</h3><p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。</p><p>唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p><p>选择排序(Selection-sort)是一种简单直观的排序算法。</p><p>它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><h3 id="2-算法描述-1"><a href="#2-算法描述-1" class="headerlink" title="2. 算法描述"></a>2. 算法描述</h3><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i&#x3D;1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><h3 id="3-动态演示-1"><a href="#3-动态演示-1" class="headerlink" title="3. 动态演示"></a>3. 动态演示</h3><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/849589-20171015224719590-1433219824.gif" alt="img"></p><h3 id="4-代码实现-1"><a href="#4-代码实现-1" class="headerlink" title="4. 代码实现"></a>4. 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] selectionSort(<span class="type">int</span>[] array)&#123;</span><br><span class="line"><span class="keyword">if</span>(array.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line"><span class="comment">//遍历未剩余未排序元素中继续寻找最小元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;j&lt;array.length;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(array[j] &lt; array[minIndex])&#123;</span><br><span class="line">minIndex = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(minIndex != i)&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[minIndex];</span><br><span class="line">array[minIndex] = array[i];</span><br><span class="line">array[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-算法分析-1"><a href="#5-算法分析-1" class="headerlink" title="5. 算法分析"></a>5. 算法分析</h3><ul><li><strong>最佳情况：T(n) &#x3D; O(n2)</strong></li><li><strong>最差情况：T(n) &#x3D; O(n2)</strong></li><li><strong>平均情况：T(n) &#x3D; O(n2)</strong></li></ul><h2 id="三、插入排序（Insertion-Sort）"><a href="#三、插入排序（Insertion-Sort）" class="headerlink" title="三、插入排序（Insertion Sort）"></a>三、插入排序（Insertion Sort）</h2><h3 id="1-算法简介-2"><a href="#1-算法简介-2" class="headerlink" title="1. 算法简介"></a>1. 算法简介</h3><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。</p><p>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h3 id="2-算法描述-2"><a href="#2-算法描述-2" class="headerlink" title="2. 算法描述"></a>2. 算法描述</h3><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul><h3 id="3-动态演示-2"><a href="#3-动态演示-2" class="headerlink" title="3. 动态演示"></a>3. 动态演示</h3><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/849589-20171015225645277-1151100000.gif" alt="img"></p><h3 id="4-代码实现-2"><a href="#4-代码实现-2" class="headerlink" title="4. 代码实现"></a>4. 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] insertSort(<span class="type">int</span>[] array)&#123;</span><br><span class="line"><span class="keyword">if</span>(array.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ;i&lt;array.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> array[i+<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i;</span><br><span class="line"><span class="keyword">while</span>(index &gt;= <span class="number">0</span> &amp;&amp; current &lt; array[index])&#123;</span><br><span class="line">array[index + <span class="number">1</span>] = array[index]; </span><br><span class="line">index--;</span><br><span class="line">&#125;</span><br><span class="line">array[index+<span class="number">1</span>] = current;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-算法分析-2"><a href="#5-算法分析-2" class="headerlink" title="5. 算法分析"></a>5. 算法分析</h3><ul><li>最佳情况：<strong>T(n) &#x3D; O(n)</strong></li><li>最坏情况：<strong>T(n) &#x3D; O(n2)</strong>  </li><li>平均情况：<strong>T(n) &#x3D; O(n2)</strong></li></ul><h2 id="四、希尔排序（Shell-Sort）"><a href="#四、希尔排序（Shell-Sort）" class="headerlink" title="四、希尔排序（Shell Sort）"></a>四、希尔排序（Shell Sort）</h2><h3 id="1-算法简介-3"><a href="#1-算法简介-3" class="headerlink" title="1. 算法简介"></a>1. 算法简介</h3><p>希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。</p><p>希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。</p><p>它与插入排序的不同之处在于，它会优先比较距离较远的元素。</p><p>希尔排序又叫缩小增量排序。</p><p>希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p><h3 id="2-算法描述-3"><a href="#2-算法描述-3" class="headerlink" title="2. 算法描述"></a>2. 算法描述</h3><p>我们来看下希尔排序的基本步骤，在此我们选择增量gap&#x3D;length&#x2F;2，缩小增量继续以gap &#x3D; gap&#x2F;2的方式，这种增量选择我们可以用一个序列来表示，{n&#x2F;2,(n&#x2F;2)&#x2F;2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk&#x3D;1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h3 id="3-动态演示-3"><a href="#3-动态演示-3" class="headerlink" title="3. 动态演示"></a>3. 动态演示</h3><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/1192699-20180319094116040-1638766271.png" alt="img"></p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/665FDA705E0082F9A8D33BB1C607BEEF6A2866AA_size752_w954_h537.gif" alt="img"></p><h3 id="4-代码实现-3"><a href="#4-代码实现-3" class="headerlink" title="4. 代码实现"></a>4. 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] shellSort(<span class="type">int</span>[] array)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(array.length &gt; <span class="number">0</span>)&#123;    </span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> array.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> len / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(gap &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap;i &lt; len;i++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[i];</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> i - gap;</span><br><span class="line">                <span class="keyword">while</span>(index &gt;= <span class="number">0</span> &amp;&amp; array[index] &gt; temp)&#123;</span><br><span class="line">                    array[index + gap] = array[index];</span><br><span class="line">                    index -= gap;</span><br><span class="line">                &#125;</span><br><span class="line">                array[index + gap] = temp;</span><br><span class="line">            &#125;            </span><br><span class="line">            gap /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h3 id="5-算法分析-3"><a href="#5-算法分析-3" class="headerlink" title="5. 算法分析"></a>5. 算法分析</h3><ul><li><strong>最佳情况：T(n) &#x3D; O(nlog2 n)</strong></li><li><strong>最坏情况：T(n) &#x3D; O(nlog2 n)</strong></li><li><strong>平均情况：T(n) &#x3D;O(nlog2n)</strong></li></ul><h2 id="五、归并排序（Merge-Sort）"><a href="#五、归并排序（Merge-Sort）" class="headerlink" title="五、归并排序（Merge Sort）"></a>五、归并排序（Merge Sort）</h2><h3 id="1-算法简介-4"><a href="#1-算法简介-4" class="headerlink" title="1. 算法简介"></a>1. 算法简介</h3><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。</p><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p><p>归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p><h3 id="2-算法描述-4"><a href="#2-算法描述-4" class="headerlink" title="2. 算法描述"></a>2. 算法描述</h3><ul><li>把长度为n的输入序列分成两个长度为n&#x2F;2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><h3 id="3-动态演示-4"><a href="#3-动态演示-4" class="headerlink" title="3. 动态演示"></a>3. 动态演示</h3><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/849589-20171015230557043-37375010.gif" alt="img"></p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/60585793BABAD3B1DD1E71DBE6CB449818610E2A_size838_w954_h537.gif" alt="img"></p><h3 id="4-代码实现-4"><a href="#4-代码实现-4" class="headerlink" title="4. 代码实现"></a>4. 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] MergeSort(<span class="type">int</span>[] array)&#123;</span><br><span class="line"><span class="keyword">if</span>(array.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> array.length /<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span>[] left = Arrays.copyOfRange(array, <span class="number">0</span>, mid);</span><br><span class="line"><span class="type">int</span>[] right = Arrays.copyOfRange(array, mid, array.length);</span><br><span class="line"><span class="keyword">return</span> merge(MergeSort(left),MergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] merge(<span class="type">int</span>[] left,<span class="type">int</span>[] right)&#123;</span><br><span class="line"><span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[left.length + right.length];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>,i = <span class="number">0</span>, j = <span class="number">0</span>;index &lt; result.length;index++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i &gt;= left.length)&#123;</span><br><span class="line">result[index] = right[j++];</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(j &gt;= right.length)&#123;</span><br><span class="line">result[index] = left[i++];</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(left[i] &gt; right[j])&#123;</span><br><span class="line">result[index] = right[j++];</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">result[index] = left[i++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-算法分析-4"><a href="#5-算法分析-4" class="headerlink" title="5. 算法分析"></a>5. 算法分析</h3><ul><li><strong>最佳情况：T(n) &#x3D; O(n)</strong></li><li>最差情况：<strong>T(n) &#x3D; O(nlogn)</strong></li><li>平均情况：<strong>T(n) &#x3D; O(nlogn)</strong></li></ul><h2 id="六、快速排序（Quick-Sort）"><a href="#六、快速排序（Quick-Sort）" class="headerlink" title="六、快速排序（Quick Sort）"></a>六、快速排序（Quick Sort）</h2><h3 id="1-算法简介-5"><a href="#1-算法简介-5" class="headerlink" title="1. 算法简介"></a>1. 算法简介</h3><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h3 id="2-算法描述-5"><a href="#2-算法描述-5" class="headerlink" title="2. 算法描述"></a>2. 算法描述</h3><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><h3 id="3-动态演示-5"><a href="#3-动态演示-5" class="headerlink" title="3. 动态演示"></a>3. 动态演示</h3><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/849589-20171015230936371-1413523412.gif" alt="img"></p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/2C853E23A97618AAD932A1DA89103646303147A9_size727_w954_h537.gif" alt="img"></p><h3 id="4-代码实现-5"><a href="#4-代码实现-5" class="headerlink" title="4. 代码实现"></a>4. 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> low,<span class="type">int</span> hight)</span>&#123;</span><br><span class="line"><span class="comment">//if (array.length &lt; 1 || low &lt; 0 || hight &gt;= array.length || low &gt; hight) return null;</span></span><br><span class="line"><span class="keyword">if</span>(low &lt; hight)&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">privotpos</span> <span class="operator">=</span> partition(array,low,hight);</span><br><span class="line">QuickSort(array,low,privotpos - <span class="number">1</span>);</span><br><span class="line">QuickSort(array,privotpos + <span class="number">1</span>,hight);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> low,<span class="type">int</span> hight)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">privot</span> <span class="operator">=</span> array[low];</span><br><span class="line"><span class="keyword">while</span>(low &lt; hight)&#123;</span><br><span class="line"><span class="keyword">while</span>(low &lt; hight &amp;&amp; array[hight] &gt;= privot) --hight;</span><br><span class="line">array[low] = array[hight];</span><br><span class="line"><span class="keyword">while</span>(low &lt; hight &amp;&amp; array[low] &lt;= privot) ++low;</span><br><span class="line">array[hight] = array[low];</span><br><span class="line">&#125;</span><br><span class="line">array[low] = privot;</span><br><span class="line"><span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-算法分析-5"><a href="#5-算法分析-5" class="headerlink" title="5. 算法分析"></a>5. 算法分析</h3><ul><li><strong>最佳情况：T(n) &#x3D; O(nlogn)</strong></li><li><strong>最差情况：T(n) &#x3D; O(n2)</strong></li><li><strong>平均情况：T(n) &#x3D; O(nlogn)</strong></li></ul><h2 id="七、堆排序（Heap-Sort）"><a href="#七、堆排序（Heap-Sort）" class="headerlink" title="七、堆排序（Heap Sort）"></a>七、堆排序（Heap Sort）</h2><h3 id="1-算法简介-6"><a href="#1-算法简介-6" class="headerlink" title="1. 算法简介"></a>1. 算法简介</h3><p>堆的定义如下: n个元素的序列{k1, k2, … , kn}当且仅当满足一下条件时，称之为堆。</p><p>​                <img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/20180610110041162" alt="img"></p><p>可以将堆看做是一个完全二叉树。并且，每个结点的值都大于等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于等于其左右孩子结点的值，称为小顶堆。</p><p>堆排序(Heap Sort)是利用堆进行排序的方法。其基本思想为：将待排序列构造成一个大顶堆(或小顶堆)，整个序列的最大值(或最小值)就是堆顶的根结点，将根节点的值和堆数组的末尾元素交换，此时末尾元素就是最大值(或最小值)，然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次大值(或次小值)，如此反复执行，最终得到一个有序序列。</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/70" alt="img"></p><h3 id="2-算法描述-6"><a href="#2-算法描述-6" class="headerlink" title="2. 算法描述"></a>2. 算法描述</h3><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;&#x3D;R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ul><h3 id="3-动态演示-6"><a href="#3-动态演示-6" class="headerlink" title="3. 动态演示"></a>3. 动态演示</h3><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/849589-20171015231308699-356134237.gif" alt="img"></p><h3 id="4-代码实现-6"><a href="#4-代码实现-6" class="headerlink" title="4. 代码实现"></a>4. 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapAdjust</span><span class="params">(<span class="type">int</span>[] array,<span class="type">int</span> index,<span class="type">int</span> length)</span>&#123;</span><br><span class="line"><span class="comment">//保存当前结点的下标</span></span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> index;</span><br><span class="line"><span class="comment">//当前节点左子节点的下标</span></span><br><span class="line"><span class="type">int</span> <span class="variable">lchild</span> <span class="operator">=</span> <span class="number">2</span>*index;</span><br><span class="line"><span class="comment">//当前节点右子节点的下标</span></span><br><span class="line"><span class="type">int</span> <span class="variable">rchild</span> <span class="operator">=</span> <span class="number">2</span>*index + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(length &gt; lchild &amp;&amp; array[max] &lt; array[lchild])&#123;</span><br><span class="line">max = lchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(length &gt; rchild &amp;&amp; array[max] &lt; array[rchild])&#123;</span><br><span class="line">max = rchild;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若此节点比其左右孩子的值小，就将其和最大值交换，并调整堆</span></span><br><span class="line"><span class="keyword">if</span>(max != index)&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[index];</span><br><span class="line">array[index] = array[max];</span><br><span class="line">array[max] = temp;</span><br><span class="line">heapAdjust(array,max,length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] heapSort(<span class="type">int</span>[] array)&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> array.length;</span><br><span class="line"><span class="comment">//初始化堆，构造一个最大堆</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (len/<span class="number">2</span> - <span class="number">1</span>);i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">heapAdjust(array,i,len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将堆顶的元素和最后一个元素交换，并重新调整堆</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>;i &gt; <span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> array[i];</span><br><span class="line">array[i] = array[<span class="number">0</span>];</span><br><span class="line">array[<span class="number">0</span>] = temp;</span><br><span class="line"></span><br><span class="line">heapAdjust(array,<span class="number">0</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-算法分析-6"><a href="#5-算法分析-6" class="headerlink" title="5. 算法分析"></a>5. 算法分析</h3><ul><li><strong>最佳情况：T(n) &#x3D; O(nlogn)</strong></li><li><strong>最差情况：T(n) &#x3D; O(nlogn)</strong></li><li><strong>平均情况：T(n) &#x3D; O(nlogn)</strong></li></ul><h2 id="八、计数排序（Counting-Sort）"><a href="#八、计数排序（Counting-Sort）" class="headerlink" title="八、计数排序（Counting Sort）"></a>八、计数排序（Counting Sort）</h2><h3 id="1-算法简介-7"><a href="#1-算法简介-7" class="headerlink" title="1. 算法简介"></a>1. 算法简介</h3><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p>计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p><h3 id="2-算法描述-7"><a href="#2-算法描述-7" class="headerlink" title="2. 算法描述"></a>2. 算法描述</h3><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ul><h3 id="3-动态演示-7"><a href="#3-动态演示-7" class="headerlink" title="3. 动态演示"></a>3. 动态演示</h3><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/849589-20171015231740840-6968181.gif" alt="img"></p><h3 id="4-代码实现-7"><a href="#4-代码实现-7" class="headerlink" title="4. 代码实现"></a>4. 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] countingSort(<span class="type">int</span>[] array)&#123;</span><br><span class="line"><span class="keyword">if</span>(array.length == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> bias ,min = array[<span class="number">0</span>],max = array[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//找出最小值和最大值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; array.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(array[i] &lt; min)&#123;</span><br><span class="line">min = array[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(array[i] &gt; max)&#123;</span><br><span class="line">max = array[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//偏差</span></span><br><span class="line">bias = <span class="number">0</span> - min;</span><br><span class="line"><span class="comment">//新开辟一个数组</span></span><br><span class="line"><span class="type">int</span>[] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[max - min +<span class="number">1</span>];</span><br><span class="line"><span class="comment">//数据初始化为0</span></span><br><span class="line">Arrays.fill(bucket, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; array.length;i++)&#123;</span><br><span class="line">bucket[array[i] + bias] += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; bucket.length;i++)&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> bucket[i];</span><br><span class="line"><span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">array[index++] = i - bias;</span><br><span class="line">len --;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-算法分析-7"><a href="#5-算法分析-7" class="headerlink" title="5. 算法分析"></a>5. 算法分析</h3><p>当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。</p><ul><li><strong>最佳情况：T(n) &#x3D; O(n+k)</strong></li><li><strong>最差情况：T(n) &#x3D; O(n+k)</strong></li><li><strong>平均情况：T(n) &#x3D; O(n+k)</strong></li></ul><h2 id="九、桶排序（Bucket-Sort）"><a href="#九、桶排序（Bucket-Sort）" class="headerlink" title="九、桶排序（Bucket Sort）"></a>九、桶排序（Bucket Sort）</h2><h3 id="1-算法简介-8"><a href="#1-算法简介-8" class="headerlink" title="1. 算法简介"></a>1. 算法简介</h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p><p>桶排序 (Bucket sort)的工作的原理：<strong>假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排</strong></p><h3 id="2-算法描述-8"><a href="#2-算法描述-8" class="headerlink" title="2. 算法描述"></a>2. 算法描述</h3><ul><li>人为设置一个BucketSize，作为每个桶所能放置多少个不同数值（例如当BucketSize&#x3D;&#x3D;5时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放100个3）；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；</li><li>从不是空的桶里把排好序的数据拼接起来。</li></ul><p><strong>注意，如果递归使用桶排序为各个桶排序，则当桶数量为1时要手动减小BucketSize增加下一循环桶的数量，否则会陷入死循环，导致内存溢出。</strong></p><h3 id="3-动态演示-8"><a href="#3-动态演示-8" class="headerlink" title="3. 动态演示"></a>3. 动态演示</h3><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/849589-20171015232107090-1920702011.png" alt="img"></p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/DD6AB96E7E353C0B72A1068DE59E7B6A297C4EDD_size1514_w954_h537.gif" alt="img"></p><h3 id="4-代码实现-8"><a href="#4-代码实现-8" class="headerlink" title="4. 代码实现"></a>4. 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;Integer&gt; <span class="title function_">BucketSort</span><span class="params">(ArrayList&lt;Integer&gt; array, <span class="type">int</span> bucketSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="literal">null</span> || array.size() &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> array.get(<span class="number">0</span>), min = array.get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 找到最大值最小值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array.get(i) &gt; max)</span><br><span class="line">            max = array.get(i);</span><br><span class="line">        <span class="keyword">if</span> (array.get(i) &lt; min)</span><br><span class="line">            min = array.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">bucketCount</span> <span class="operator">=</span> (max - min) / bucketSize + <span class="number">1</span>;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(bucketCount);</span><br><span class="line">    ArrayList&lt;Integer&gt; resultArr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//构造桶</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class="line">        bucketArr.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//往桶里塞元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.size(); i++) &#123;</span><br><span class="line">        bucketArr.get((array.get(i) - min) / bucketSize).add(array.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bucketCount; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bucketSize == <span class="number">1</span>) &#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; bucketArr.get(i).size(); j++)</span><br><span class="line">                resultArr.add(bucketArr.get(i).get(j));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucketCount == <span class="number">1</span>)</span><br><span class="line">                bucketSize--;</span><br><span class="line">            ArrayList&lt;Integer&gt; temp = BucketSort(bucketArr.get(i), bucketSize);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; temp.size(); j++)</span><br><span class="line">                resultArr.add(temp.get(j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-算法分析-8"><a href="#5-算法分析-8" class="headerlink" title="5. 算法分析"></a>5. 算法分析</h3><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 </p><ul><li><strong>最佳情况：T(n) &#x3D; O(n+k)</strong></li><li><strong>最差情况：T(n) &#x3D; O(n+k)</strong></li><li><strong>平均情况：T(n) &#x3D; O(n2)</strong></li></ul><h2 id="十、基数排序（Radix-Sort）"><a href="#十、基数排序（Radix-Sort）" class="headerlink" title="十、基数排序（Radix Sort）"></a>十、基数排序（Radix Sort）</h2><h3 id="1-算法简介-9"><a href="#1-算法简介-9" class="headerlink" title="1. 算法简介"></a>1. 算法简介</h3><p>基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；</p><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p><h3 id="2-算法描述-9"><a href="#2-算法描述-9" class="headerlink" title="2. 算法描述"></a>2. 算法描述</h3><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li></ul><h3 id="3-动态演示-9"><a href="#3-动态演示-9" class="headerlink" title="3. 动态演示"></a>3. 动态演示</h3><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/849589-20171015232453668-1397662527.gif" alt="img"></p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/0630D517B5FAABFC6609A0EA9BF55F7E89E08215_size1761_w954_h537.gif" alt="img"></p><h3 id="4-代码实现-9"><a href="#4-代码实现-9" class="headerlink" title="4. 代码实现"></a>4. 代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] RadixSort(<span class="type">int</span>[] array) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="literal">null</span> || array.length &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    <span class="comment">// 1.先算出最大数的位数；</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        max = Math.max(max, array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDigit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (max != <span class="number">0</span>) &#123;</span><br><span class="line">        max /= <span class="number">10</span>;</span><br><span class="line">        maxDigit++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">10</span>, div = <span class="number">1</span>;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">    bucketList.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; maxDigit;i++,mod *= <span class="number">10</span> ,div *= <span class="number">10</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; array.length;j++)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (array[j] % mod) / div;</span><br><span class="line">    bucketList.get(num).add(array[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; bucketList.size();j++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;k &lt; bucketList.get(j).size();k++)&#123;</span><br><span class="line">    array[index++] = bucketList.get(j).get(k);</span><br><span class="line">    &#125;</span><br><span class="line">bucketList.get(j).clear();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-算法分析-9"><a href="#5-算法分析-9" class="headerlink" title="5. 算法分析"></a>5. 算法分析</h3><ul><li><strong>最佳情况：T(n) &#x3D; O(n * k)</strong></li><li><strong>最差情况：T(n) &#x3D; O(n * k)</strong></li><li><strong>平均情况：T(n) &#x3D; O(n * k)</strong></li></ul><blockquote><p>基数排序有两种方法：</p><ul><li>MSD 从高位开始进行排序 LSD 从低位开始进行排序</li></ul></blockquote><blockquote><p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶</li><li>计数排序：每个桶只存储单一键值</li><li>桶排序：每个桶存储一定范围的数值</li></ul></blockquote><h2 id="十一、排序算法总结"><a href="#十一、排序算法总结" class="headerlink" title="十一、排序算法总结"></a>十一、排序算法总结</h2><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/849589-20171015233043168-1867817869.png" alt="img"></p><ul><li>稳定：如果a原本在b前面，而a&#x3D;b,排序之后a仍然在b的前面；</li><li>不稳定：如果a原本在b前面，而a&#x3D;b,排序之后a有可能会出现在b的后面；</li><li>内排序：所有排序操作都在内存中完成；</li><li>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li><li>时间复杂度：描述算法运行时间的函数，用大O符号表述；</li><li>空间复杂度：描述算法所需要的内存空间大小。</li><li>n：数据规模</li><li>k：”桶”的个数</li><li>In-place：占用常数内存，不占用额外内存</li><li>Out-place：占用额外内存</li></ul><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/849589-20171015233220637-1055088118.png" alt="img"></p><h3 id="比较和非比较排序的区别"><a href="#比较和非比较排序的区别" class="headerlink" title="比较和非比较排序的区别"></a><strong>比较和非比较排序的区别</strong></h3><p>常见的快速排序、归并排序、堆排序、冒泡排序等属于比较排序。在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。</p><p>在冒泡排序之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在归并排序、快速排序之类的排序中，问题规模通过分治法消减为logN次，所以平均时间复杂度为O(nlogn)。</p><p><strong>比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。</strong></p><p>计数排序、基数排序、桶排序则属于非比较排序。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr,计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。</p><p><strong>非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。</strong></p><p>非比较排序的时间复杂度低，但由于非比较排序需要占用空间来确定唯一的位置。所以对数据规模和数据分布有一定的要求。</p>]]></content>
    
    
    <summary type="html">JAVA 排序算法</summary>
    
    
    
    <category term="算法" scheme="https://fabian4.site/blog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Java" scheme="https://fabian4.site/blog/tags/Java/"/>
    
    <category term="算法" scheme="https://fabian4.site/blog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>使用 frp 搭建内网穿透</title>
    <link href="https://fabian4.site/blog/22217.html"/>
    <id>https://fabian4.site/blog/22217.html</id>
    <published>2021-03-04T16:00:00.000Z</published>
    <updated>2022-08-24T07:47:19.058Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-frp-搭建内网穿透"><a href="#使用-frp-搭建内网穿透" class="headerlink" title="使用 frp 搭建内网穿透"></a>使用 frp 搭建内网穿透</h1><h2 id="一、什么是-frp"><a href="#一、什么是-frp" class="headerlink" title="一、什么是 frp"></a>一、什么是 frp</h2><p>通过在具有公网 IP 的节点上部署 frp 服务端，可以轻松地将内网服务穿透到公网，同时提供诸多专业的功能特性，这包括：</p><ul><li>客户端服务端通信支持 TCP、KCP 以及 Websocket 等多种协议。</li><li>采用 TCP 连接流式复用，在单个连接间承载更多请求，节省连接建立时间。</li><li>代理组间的负载均衡。</li><li>端口复用，多个服务通过同一个服务端端口暴露。</li><li>多个原生支持的客户端插件（静态文件查看，HTTP、SOCK5 代理等），便于独立使用 frp 客户端完成某些工作。</li><li>高度扩展性的服务端插件系统，方便结合自身需求进行功能扩展。</li><li>服务端和客户端 UI 页面。</li></ul><blockquote><ol><li>在办公室访问家里的电脑，反之亦然 </li><li>自己电脑上的项目，方便发给客户朋友演示。比如我做了个小网站，发给朋友看看未上线版本，发个url给他就好了。</li><li>调试一些需要远程调用的程序，远程调用比如微信的API 回调接口。</li></ol></blockquote><h2 id="二、服务端搭建"><a href="#二、服务端搭建" class="headerlink" title="二、服务端搭建"></a>二、服务端搭建</h2><ol><li><p><a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a> 下载对应安装包</p></li><li><p>修改配置文件 <code>frps.ini</code></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span>  </span><br><span class="line"></span><br><span class="line"><span class="attr">max_pool_count</span> = <span class="number">5</span></span><br><span class="line"><span class="attr">max_ports_per_client</span> = <span class="number">0</span></span><br><span class="line"><span class="attr">authentication_timeout</span> = <span class="number">900</span></span><br></pre></td></tr></table></figure></li><li><p>启动项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frps -c ./frps.ini </span><br></pre></td></tr></table></figure></li></ol><h2 id="三、客户端搭建"><a href="#三、客户端搭建" class="headerlink" title="三、客户端搭建"></a>三、客户端搭建</h2><ol><li><p><a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a> 下载对应安装包</p></li><li><p>修改配置文件 <code>frpc.ini</code></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span></span><br><span class="line"><span class="attr">server_addr</span> = 公网ip地址</span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span></span><br><span class="line"><span class="section">[ssh]</span></span><br><span class="line"><span class="attr">type</span> = tcp</span><br><span class="line"><span class="attr">local_ip</span> = 本地地址</span><br><span class="line"><span class="attr">local_port</span> = 本地端口</span><br><span class="line"><span class="attr">remote_port</span> = 远程端口</span><br></pre></td></tr></table></figure><p>common 为通用配置</p><ul><li>server_addr 为公网服务器 IP 地址（云服务器IP）</li><li>server_port 为公网服务器配置的端口</li></ul><p>ssh 用于终端命令行访问</p><ul><li>type 连接类型，默认为 tcp</li><li>local_ip 本地 IP </li><li>local_port 用于 ssh 的端口号，默认 22</li><li>remote_port 映射的服务端端口，访问该端口时默认转发到客户端的 22 端口</li></ul></li><li><p>启动项目</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./frpc -c ./frpc.ini </span><br></pre></td></tr></table></figure></li></ol><h2 id="四、文件结构和配置详情"><a href="#四、文件结构和配置详情" class="headerlink" title="四、文件结构和配置详情"></a>四、文件结构和配置详情</h2><h3 id="1-文件结构"><a href="#1-文件结构" class="headerlink" title="1. 文件结构"></a>1. 文件结构</h3><ul><li>frpc                    # 客户端二进制文件 </li><li>frpc_full.ini           # 客户端配置文件完整示例 </li><li>frpc.ini                # 客户端配置文件 </li><li>frps                    # 服务端二进制文件 </li><li>frps_full.ini           # 服务端配置文件完整示例 </li><li>frps.ini              # 服务端配置文件</li></ul><h3 id="2-服务端配置"><a href="#2-服务端配置" class="headerlink" title="2. 服务端配置"></a>2. 服务端配置</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span>                        <span class="comment"># 通用配置段</span></span><br><span class="line"><span class="attr">bind_addr</span> = <span class="number">0.0</span>.<span class="number">0.0</span>             <span class="comment"># 绑定的IP地址，支持IPv6，不指定默认0.0.0.0；</span></span><br><span class="line"><span class="attr">bind_port</span> = <span class="number">7000</span>                <span class="comment"># 服务端口；</span></span><br><span class="line"><span class="attr">bind_udp_port</span> = <span class="number">7001</span>            <span class="comment"># 是否使用udp端口，不使用删除或注释本行；</span></span><br><span class="line"><span class="attr">kcp_bind_port</span> = <span class="number">7000</span>            <span class="comment"># 是否使用kcp协议，不使用删除或注释本行；</span></span><br><span class="line"><span class="comment"># proxy_bind_addr = 127.0.0.1   # 代理监听地址，默认和bind_addr相同；</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 虚拟主机</span></span><br><span class="line"><span class="attr">vhost_http_port</span> = <span class="number">80</span>            <span class="comment"># 是否启用虚拟主机，端口可以和bind_port相同；</span></span><br><span class="line"><span class="attr">vhost_https_port</span> = <span class="number">443</span></span><br><span class="line"><span class="attr">vhost_http_timeout</span> = <span class="number">60</span>         <span class="comment"># 后端虚拟主机响应超时时间，默认为60s；</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启frps仪表盘可以检查frp的状态和代理的统计信息。</span></span><br><span class="line"><span class="attr">dashboard_addr</span> = <span class="number">0.0</span>.<span class="number">0.0</span>        <span class="comment"># frps仪表盘绑定的地址；</span></span><br><span class="line"><span class="attr">dashboard_port</span> = <span class="number">7500</span>           <span class="comment"># frps仪表盘绑定的端口；</span></span><br><span class="line"><span class="attr">dashboard_user</span> = admin          <span class="comment"># 访问frps仪表盘的用户；     </span></span><br><span class="line"><span class="attr">dashboard_pwd</span> = admin           <span class="comment"># 密码；</span></span><br><span class="line"><span class="attr">assets_dir</span> = ./static           <span class="comment"># 仪表盘页面文件目录，只适用于调试；</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志配置文件</span></span><br><span class="line"><span class="attr">log_file</span> = ./frps.log           <span class="comment"># 日志文件,不指定日志信息默认输出到控制台；</span></span><br><span class="line"><span class="attr">log_level</span> = info                <span class="comment"># 日志等级，可用等级“trace, debug, info, warn, error”；</span></span><br><span class="line"><span class="attr">log_max_days</span> = <span class="number">3</span>                <span class="comment"># 日志保存最大保存时间；</span></span><br><span class="line"></span><br><span class="line"><span class="attr">token</span> = <span class="number">12345678</span>                <span class="comment"># 客户端与服务端通信的身份验证令牌</span></span><br><span class="line"></span><br><span class="line"><span class="attr">heartbeat_timeout</span> = <span class="number">90</span>          <span class="comment"># 心跳检测超时时间，不建议修改默认配置，默认值为90；？</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定允许客户端使用的端口范围，未指定则没有限制；</span></span><br><span class="line"><span class="attr">allow_ports</span> = <span class="number">2000</span>-<span class="number">3000</span>,<span class="number">3001</span>,<span class="number">3003</span>,<span class="number">4000</span>-<span class="number">50000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">max_pool_count</span> = <span class="number">5</span>              <span class="comment"># 每个客户端连接服务端的最大连接数；</span></span><br><span class="line"><span class="attr">max_ports_per_client</span> = <span class="number">0</span>        <span class="comment"># 每个客户端最大可以使用的端口，0表示无限制</span></span><br><span class="line"></span><br><span class="line"><span class="attr">authentication_timeout</span> = <span class="number">900</span>    <span class="comment"># 客户端连接超时时间（秒），默认为900s；</span></span><br><span class="line"></span><br><span class="line"><span class="attr">subdomain_host</span> = frps.com       <span class="comment"># 自定义子域名，需要在dns中将域名解析为泛域名；</span></span><br><span class="line"></span><br><span class="line"><span class="attr">tcp_mux</span> = <span class="literal">true</span>                  <span class="comment"># 是否使用tcp复用，默认为true；</span></span><br><span class="line">                                <span class="comment"># frp只对同意客户端的连接进行复用；</span></span><br></pre></td></tr></table></figure><h3 id="3-客户端配置"><a href="#3-客户端配置" class="headerlink" title="3. 客户端配置"></a>3. 客户端配置</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[common]</span>                        <span class="comment"># 通用配置段</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server_addr</span> = <span class="number">0.0</span>.<span class="number">0.0</span>           <span class="comment"># server的IP地址；支持IPv6</span></span><br><span class="line"><span class="attr">server_port</span> = <span class="number">7000</span>              <span class="comment"># server的端口；</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果要通过http或socks5代理连接frps，可以在此处或在全局环境变量中设置代理，只支持tcp协议；</span></span><br><span class="line"><span class="comment"># http_proxy = http://user:passwd@192.168.1.128:8080</span></span><br><span class="line"><span class="comment"># http_proxy = socks5://user:passwd@192.168.1.128:1080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端日志</span></span><br><span class="line"><span class="attr">log_file</span> = ./frpc.log       <span class="comment"># 指定日志文件；</span></span><br><span class="line"><span class="attr">log_level</span> = info            <span class="comment"># 指定日志等级；</span></span><br><span class="line"><span class="attr">log_max_days</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">token</span> = <span class="number">12345678</span>            <span class="comment"># 客户端与服务端通信的身份验证令牌</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置管理地址，用于通过http api控制frpc的动作，如重新加载；</span></span><br><span class="line"><span class="attr">admin_addr</span> = <span class="number">127.0</span>.<span class="number">0.1</span></span><br><span class="line"><span class="attr">admin_port</span> = <span class="number">7400</span></span><br><span class="line"><span class="attr">admin_user</span> = admin</span><br><span class="line"><span class="attr">admin_passwd</span> = admin</span><br><span class="line"></span><br><span class="line"><span class="attr">pool_count</span> = <span class="number">5</span>              <span class="comment"># 初始连接池的数量，默认为0；</span></span><br><span class="line"></span><br><span class="line"><span class="attr">tcp_mux</span> = <span class="literal">true</span>              <span class="comment"># 是否启用tcp复用，默认为true；</span></span><br><span class="line"></span><br><span class="line"><span class="attr">user</span> = your_name            <span class="comment"># frpc的用户名，用于区别不用frpc的代理；</span></span><br><span class="line"></span><br><span class="line"><span class="attr">login_fail_exit</span> = <span class="literal">true</span>      <span class="comment"># 首次登录失败时退出程序，否则连续重新登录到frps；</span></span><br><span class="line"></span><br><span class="line"><span class="attr">protocol</span> = tcp              <span class="comment"># 用于连接服务器的协议，支持tcp、kcp、websocket;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dns_server</span> = <span class="number">8.8</span>.<span class="number">8.8</span>        <span class="comment"># 为frp 客户端指定一个单独的DNS服务器；</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># start = ssh,dns           # 要启用的代理的名字，默认为空表示所有代理；</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 心跳检查</span></span><br><span class="line"><span class="comment"># heartbeat_interval = 30   # 失败重试次数</span></span><br><span class="line"><span class="comment"># heartbeat_timeout = 90    # 超时时间</span></span><br></pre></td></tr></table></figure><h2 id="五、注册系统服务"><a href="#五、注册系统服务" class="headerlink" title="五、注册系统服务"></a>五、注册系统服务</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@server ~]# vim /usr/lib/systemd/system/frps.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=frp server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line"></span><br><span class="line">ExecStart=/usr/local/frp_server/frps -c /usr/local/frp_server/frps.ini</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line">ExecStop=/bin/kill -s QUIT $MAINPID</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">[root@server ~]# systemctl enable frps</span><br><span class="line">[root@server ~]# systemctl start  frps.service</span><br><span class="line">[root@server ~]# systemctl status frps</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">使用 frp 搭建内网穿透</summary>
    
    
    
    <category term="教程" scheme="https://fabian4.site/blog/categories/%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="frp" scheme="https://fabian4.site/blog/tags/frp/"/>
    
  </entry>
  
  <entry>
    <title>JVM 垃圾回收</title>
    <link href="https://fabian4.site/blog/40208.html"/>
    <id>https://fabian4.site/blog/40208.html</id>
    <published>2021-02-19T16:00:00.000Z</published>
    <updated>2022-08-24T07:47:19.052Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-垃圾回收"><a href="#JVM-垃圾回收" class="headerlink" title="JVM 垃圾回收"></a>JVM 垃圾回收</h1><h2 id="一、垃圾回收概述"><a href="#一、垃圾回收概述" class="headerlink" title="一、垃圾回收概述"></a>一、垃圾回收概述</h2><h3 id="1-简述-Java-垃圾回收机制"><a href="#1-简述-Java-垃圾回收机制" class="headerlink" title="1. 简述 Java 垃圾回收机制"></a>1. 简述 Java 垃圾回收机制</h3><ul><li>在 Java中，我们不需要手动释放对象内存，由于 JVM的垃圾回收线程自动对没有引用的对象进行回收</li><li>创建对象时，GC 开始监控这个对象的地址，大小以及使用情况。</li><li>GC采用的有向图的方式记录和管理堆中的所有对象。通过这种方式确定哪些对象是 “可达的”， 哪些对象是 “不可达的”。当GC确定一些对象为“不可达”时，GC就有责任回收这些内存空间</li></ul><h3 id="2-垃圾回收机制"><a href="#2-垃圾回收机制" class="headerlink" title="2. 垃圾回收机制"></a>2. 垃圾回收机制</h3><ul><li>分代复制垃圾回收</li><li>标记垃圾回收</li><li>增量垃圾回收</li></ul><h3 id="3-什么是-Grabage"><a href="#3-什么是-Grabage" class="headerlink" title="3. 什么是 Grabage"></a>3. 什么是 Grabage</h3><ul><li>垃圾是指在运行程序中没有任何指针指向的这个对象，这个对象就是需要被回收的垃圾</li><li>如果不及时堆内存中的垃圾进行清理，那么这些垃圾对象所占据的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至肯导致内存溢出</li></ul><h3 id="4-为什么需要进行-Grabage-Collection"><a href="#4-为什么需要进行-Grabage-Collection" class="headerlink" title="4. 为什么需要进行 Grabage Collection"></a>4. 为什么需要进行 Grabage Collection</h3><ul><li>不进行垃圾回收，内存会消耗完。</li><li>碎片整理，令新对象获得连续的内存空间</li><li>STW的GC无法满足实际需求，需要对GC进行优化</li></ul><h3 id="5-垃圾回收器"><a href="#5-垃圾回收器" class="headerlink" title="5. 垃圾回收器"></a>5. 垃圾回收器</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>无需手动分配回收内存，降低内存泄漏，内存溢出的风险</li><li>没有垃圾回收器，Java也会和cpp一样，各种悬垂指针，野指针，泄露问题需要资金管理</li><li>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专注于业务开发</li></ul><h4 id="担忧"><a href="#担忧" class="headerlink" title="担忧"></a>担忧</h4><ul><li>对于 Java开发人员而言，自动管理内存就像一个黑匣子，如果过度依赖于“自动”，会弱化 Java开发人员在程序出现内存溢出定位能力和解决问题能力。</li><li>只有在整正了解 JVM 是如果管理内存后，我们才能够在遇见 OutOfMemoryError 时，快速地根据错误异常日志定位问题和解决问题</li><li>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节</li></ul><h3 id="6-GC-的作用域"><a href="#6-GC-的作用域" class="headerlink" title="6. GC 的作用域"></a>6. GC 的作用域</h3><ul><li><p>垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收，其中，Java堆是垃圾回收器的工作重点</p></li><li><p>次数层面</p><ul><li>频繁收集年轻代</li><li>较少收集老年代</li><li>基本不收集永久代（元空间 matespace）</li></ul></li><li><p>GC 主要关注于方法区和堆中的垃圾收集</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210313163015243.png" alt="image-20210313163015243" style="zoom:50%;" /></li></ul><h2 id="二、垃圾回收相关算法"><a href="#二、垃圾回收相关算法" class="headerlink" title="二、垃圾回收相关算法"></a>二、垃圾回收相关算法</h2><h3 id="1-标记阶段what：判断对象是否存活"><a href="#1-标记阶段what：判断对象是否存活" class="headerlink" title="1. 标记阶段what：判断对象是否存活"></a>1. 标记阶段what：判断对象是否存活</h3><ul><li>堆存放：几乎所有的Java对象实例</li><li>GC执行只回收死亡对象，释放其所占用的内存空间</li><li>标记死亡对象：当一个对象不再被存活对象引用时</li><li>两种方式：引用计数算法、可达性分析</li></ul><h3 id="2-引用计数法"><a href="#2-引用计数法" class="headerlink" title="2. 引用计数法"></a>2. 引用计数法</h3><p>每个对象上保证整形的引用计数属性，有对象引用计数器加一，减少引用计数器减一。计数器为零时，进行垃圾回收。</p><ul><li><p>优点：实现简单、垃圾对象易识别、判定效率高、回收没有延迟性</p></li><li><p>缺点：循环引用问题</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210313164046996.png" alt="image-20210313164046996"></p></li></ul><h3 id="3-标记阶段：可达性分析算法（根据搜索算法、追踪性垃圾收集）"><a href="#3-标记阶段：可达性分析算法（根据搜索算法、追踪性垃圾收集）" class="headerlink" title="3. 标记阶段：可达性分析算法（根据搜索算法、追踪性垃圾收集）"></a>3. 标记阶段：可达性分析算法（根据搜索算法、追踪性垃圾收集）</h3><ul><li>解决循环引用问题，防止内存溢出</li></ul><blockquote><p>跟对象集合为起点，向下搜索直接或间接连接的对象为存活对象</p><p>无法建立连接，即不可达对象标记为可回收对象</p></blockquote><h4 id="GC-Roots-可以是哪些元素"><a href="#GC-Roots-可以是哪些元素" class="headerlink" title="GC Roots 可以是哪些元素"></a>GC Roots 可以是哪些元素</h4><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210313170717208.png" alt="image-20210313170717208" style="zoom:50%;" /><ul><li>虚拟机栈中引用的对象，比如：各个线程被调用的方法中使用到的参数，局部变量等</li><li>本地方法栈内 JNI（通常说本地方法）引用的对象方法区中类静态属性引用的对象，比如：Java类的引用类型静态变量</li><li>方法区中常量引用的对象，比如：字符串常量池（StringTable）里的引用</li><li>所有被同步锁 synchronized 持有的对象</li><li>Java 虚拟机内部的引用</li><li>基本数据类型对应的 Class 对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器</li><li>反映 Java 虚拟机内部情况的 JMXBean、JVMTI中注册的回调、本地代码缓存</li></ul><h4 id="关于-GC-Roots"><a href="#关于-GC-Roots" class="headerlink" title="关于 GC Roots"></a>关于 GC Roots</h4><ul><li>除了堆空间外的一些结构，比如：虚拟机栈、本地方法栈、方法区、字符串常量池等地方堆堆空间的引用，都可以作为GC Roots进行可达性分析</li><li>除了这些固定的GC Roots集合以外，根据用户所选的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收</li><li>如果只针对 Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己实现细节，更不是孤立封闭，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才有可能保证可达性分析的准确性</li></ul><blockquote><p>由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root</p></blockquote><h4 id="可达性分析算法的注意事项"><a href="#可达性分析算法的注意事项" class="headerlink" title="可达性分析算法的注意事项"></a>可达性分析算法的注意事项</h4><ul><li>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结构的准确性就无法保证</li><li>一致性 –&gt; 准确性</li><li>这点也是导致 GC 进行时必须 “Stop the World”的一个重要原因。即使号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的</li><li>枚举根节点停顿</li></ul><h4 id="关于永生代"><a href="#关于永生代" class="headerlink" title="关于永生代"></a>关于永生代</h4><ul><li>垃圾回收不会发生在永久代</li><li>如果永久代满或超过设定阈值，会触发 Full GC （堆+方法区）</li><li>查看垃圾回收器的输出信息，也发现永久代也是被回收的</li><li>避免Full GC：设置永久代大小，Java8：从永久代到元数据区（本地内存区）</li></ul><h4 id="对象的-finalization-机制"><a href="#对象的-finalization-机制" class="headerlink" title="对象的 finalization 机制"></a>对象的 finalization 机制</h4><ul><li><p>对象销毁前的回调函数</p><ol><li>Java语言提供了对象终止机制来运行开发人员提供对象被销毁之前的自定义处理逻辑</li><li>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize() 方法</li><li>finalize() 方法允许在子类被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理工作，比如关闭文件，套接字和数据库连接等</li></ol></li><li><p>finalize() 方法使用的注意事项</p><ol><li>永远不要主动调用某个对象的 finalize() 方法，应该交给垃圾回收机制调用<ul><li>在 finalize()时可能会导致对象复活</li><li>finalize() 方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则 finalize() 方法将没有执行机会</li><li>因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收</li></ul></li><li>一个糟糕的 finalize() 会验证影响 GC 性能</li><li>从功能上来说，finalize() 方法与 C++ 中的析构函数比较相似，但是 Java采用的是基于垃圾回收器的自动内存管理机制，所以 finalize() 方法在本质上不同于 C++ 中的析构函数</li></ol></li><li><p>由于 finalize() 方法的存在，虚拟机中的对象有三种可能的状态</p><ol><li>可触及：从根节点开始，可以到达这个对象</li><li>可复活：对象的所有引用都被释放，但是对象有可能在 finalize() 中复活</li><li>不可触及：对象的 finalize() 被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为 finalize() 只会被调用一次</li></ol></li><li><p>finalize() 具体执行过程</p><ol><li><p>判定一个对象 objA 是否可回收，至少要经过两次标记过程</p></li><li><p>如果对象 objA 到 GC Roots 没有引用链，则进行一次标记</p></li><li><p>进行筛选，判断此对象是否有必要执行 finalize() 方法</p><ul><li>如果没有重写 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA 被判定为不可触及的</li><li>如果对象 objA 重写了 finalize() 方法，且还未执行过，那么 objA 会被插入到 F-Queue 队列中，由一个虚拟机自动创建的、低优先级的 Finalizer 线程触发其 finalize() 方法执行</li></ul></li><li><p>finalize() 方法是对象逃脱死亡的最后机会，稍后 GC 会对 F-Queue 队列中的对象进行第二次标记。如果 objA 在 finalize() 方法中与引用链上任何一个对象建立了联系，那么在第二次标记时，objA 会被移除 “即将回收”集合</p></li><li><p>之后，对象会再次出现没有引用内存的情况，在这个情况下，finalize() 方法不会被再次调用，对象会直接变成不可触及的状态</p><blockquote><p>一个对象的 finalize() 方法只会被调用一次</p></blockquote></li></ol></li><li><p>GC Roots 溯源</p><ul><li>MAT (Memory Analyzer)：一款功能强大的 Java堆内存分析器，用于查找内存泄漏以及查看内存消耗情况。基于Eclipse开发，是一款免费的性能分析工具</li><li>使用 JVisualVM 捕捉 heap dump</li><li>使用 JProfiler 进行 GC Roots 溯源</li><li>JProfiler 分析 OOM</li></ul></li><li><p>清除阶段：当成功区分出内存中存活对象和死亡对象后，GC 接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够可用的内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法</p><ul><li>标记-清除算法</li><li>复制算法</li><li>标记压缩算法</li><li>(分代算法)</li></ul></li><li><p>清除阶段：标记-清除算法</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210313203841538.png" alt="image-20210313203841538" style="zoom: 67%;" /><ul><li><p>执行过程</p><p>当堆中的有效内存空间被耗尽时，就会停止整个程序，然后进行两项工作：标记、清除</p><ol><li>标记：Collector从根节点开始遍历，标记所有被引用的对象，一般是在对象的 Header 中记录为可达对象</li><li>清除：Collector对堆内存从头到尾进行线性遍历，如果发现某个对象在其 Header 中没有标记为可达对象，则将其回收</li></ol></li><li><p>清除对象的方式</p><ol><li><p>把需要清除的对象地址保存在空闲地址列表。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够就存放并覆盖原有地址</p></li><li><p>如果内存规整，采用指针碰撞的方式</p><blockquote><p>如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新分配在第一个空闲内存的位置上，这种分配方式叫做指针碰撞</p></blockquote></li><li><p>如果内存不规整，虚拟机需要维护一个空闲列表，采用空闲列表分配内存</p></li></ol></li><li><p>标记-清除算法缺点</p><ol><li>效率不高</li><li>在进行 GC 时，需要停止整个应用程序，用户体验差</li><li>空闲内存不连续，产生内碎片</li><li>需要维护一个空闲列表</li></ol></li></ul></li><li><p>清除阶段：复制算法</p><ul><li><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</p></li><li><p>Eden区，from区，to区的复制算法</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210313205517137.png" alt="image-20210313205517137" style="zoom: 50%;" /></li><li><p>复制算法优点</p><ol><li>没有标记和清除过程，实现简单，运行高效</li><li>复制过去以后保证空间连续性，不会出现碎片问题</li></ol></li><li><p>复制算法缺点</p><ol><li>需要两倍内存空间</li><li>对于G1这种分拆成大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，内存占用，时间开销都很大</li></ol></li><li><p>综上：<strong>适合垃圾对象多，存活对象很少的场景</strong>， 例如：Young区的Survivor0和Survivor1区</p></li></ul></li><li><p>清除阶段：标记-压缩算法（标记-整理、Mark-Compact）</p><ul><li><p>标记-清除算法：老年代，会产生大量碎片</p></li><li><p>复制算法针对：新生代，存活对象少，垃圾对象多。不适于老年代，大量存活对象</p></li><li><p>标记-压缩算法的执行流程</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210313210404445.png" alt="image-20210313210404445" style="zoom: 67%;" /><ul><li>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</li><li>第二阶段将所有存活对象压缩到内存一端，按顺序排放。之后，清理边界外所有空间</li></ul></li><li><p>优点</p><ol><li>消除了标记-清除算法当中，内存区域分散的特点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li><li>消除了复制算法当中，内存减半的高额代价</li></ol></li><li><p>缺点</p><ol><li>从效率上来说，标记-整理算法要低于复制算法。</li><li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</li><li>移动过程中，需要全暂停用户应用程序。即STW</li></ol></li></ul></li><li><p>对比三种清除阶段算法（没有最好的，只有最适合的算法）</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210313211045543.png" alt="image-20210313211045543" style="zoom:50%;" /></li><li><p>分代收集算法</p><ul><li><p>年轻代</p><ul><li>区域相对老年代较小，对象生命周期短、存活率低，回收频繁</li><li>这种情况复制算法时回收整理，速度是最快的。复制算法的效率之和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解</li></ul></li><li><p>老年代</p><ul><li>区域较大，对象生命周期长，存活率高，回收不及年轻代频繁</li><li>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-整理的混合实现<ul><li>Mark 阶段的开销与存活对象的数量成正比</li><li>Sweep 阶段的开销与所管理区域的大小成正比</li><li>Compact 阶段的开销与存活对象的数据成正比</li></ul></li></ul></li><li><p>HotSpot CMS 回收器</p><ul><li>以 HotSpot 中的CMS回收器为例，CMS是基于Mark-Sweep实现，对于对象的回收效率很高</li><li>对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致 Concurrent Mode Failure时），将采用 Serial Old执行 Full GC 以达到堆老年代内存的整理</li></ul></li><li><p>增量收集算法</p><ul><li>上述现有的算法，在垃圾回收过程中，应用软件将处于一种 Stop The World 的状态。在 STW 状态下，应用程序所有线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成</li><li>如果垃圾回收时间过长，应用程序就会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集算法的诞生</li><li>基本思想<ul><li>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成</li><li>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</li></ul></li><li>优缺点<ul><li>使用这种方式，由于在垃圾回收的过程中，间接性还执行了应用程序代码，所以能减少系统的停顿时间</li><li>但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量下降</li></ul></li></ul></li><li><p>分区算法</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210313214651632.png" alt="image-20210313214651632" style="zoom:67%;" /><ul><li>一般来说，在相同条件下，堆空间越大，一次 GC 时所需要的时间就越长，有关 GC 产生的停顿也越长</li><li>为了更好的控制GC产生的停顿时间，将一块大的区域风格成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿</li><li>分代算法间按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间</li></ul></li></ul></li></ul><h2 id="三、垃圾回收相关概念"><a href="#三、垃圾回收相关概念" class="headerlink" title="三、垃圾回收相关概念"></a>三、垃圾回收相关概念</h2><h3 id="1-System-gc-的理解"><a href="#1-System-gc-的理解" class="headerlink" title="1. System.gc() 的理解"></a>1. System.gc() 的理解</h3><ul><li>在默认情况下，通过 System.gc() 或者 Runtime.getRuntime().gc() 的调用会显式触发 Full GC，同时对新生代老年代进行回收，尝试释放被丢弃对象的占用空间</li><li>System.gc() 调用无法保证对垃圾收集器的调用（不能确保立即生效）</li><li>JVM 实现者可以通过 System.gc() 调用来决定 JVM 的 GC 行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦</li><li>在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用 System.gc()</li></ul><h3 id="2-内存溢出-OutOfMemoryError"><a href="#2-内存溢出-OutOfMemoryError" class="headerlink" title="2. 内存溢出 OutOfMemoryError"></a>2. 内存溢出 OutOfMemoryError</h3><ul><li><p>应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度</p></li><li><p>GC 年轻代老年代的垃圾回收 –&gt; 内存不足 –&gt; 独占式 Full GC 操作 –&gt; 回收大量内存 –&gt; 供应用程序继续使用</p></li><li><p>Javadoc中对OOM的解释：没有空闲的内存，并且垃圾收集器也无法提供更多内存</p><ul><li><p>Java虚拟机的堆内存设置不够</p><ul><li>可能存在内存泄漏问题；也可能是堆的大小设计不合理，比如要处理比较可观的数量，但没有显式指定 JVM 堆大小或指定数值偏小</li><li>调整参数 -Xms、-Xmx</li></ul></li><li><p>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</p><ul><li>对于老版本 Oracle JDK，因为永久代大小有限，并且 JVM 对永久代垃圾回收非常不积极，所以当我们不断添加新类型时，永久代出现OutOfMemoryError</li><li>运行时存在大量动态类型生成的场合：类似 intern 字符串缓存占用太多空间，也会导致 OOM 问题</li><li>异常信息，会标记出永久代相关：java.lang.OutOfMemoryError:PermGenspace</li><li>元数据区，本地内存，异常信息：java.lang.OutOfMemoryError:Metaspace。直接内存不足，也会导致 OOM</li></ul></li></ul></li></ul><h3 id="3-内存泄漏"><a href="#3-内存泄漏" class="headerlink" title="3. 内存泄漏"></a>3. 内存泄漏</h3><ul><li><p>不再被使用的对象或变量一直占据在内存中，但GC又不能回收</p></li><li><p>内存泄漏，程序不会立即崩溃，耗尽内存，最终出现 OutOfMemory 异常，导致程序崩溃</p></li><li><p>存储空间：虚拟内存大小，取决于磁盘交换区设定的大小</p></li><li><p>导致内存泄漏的原因：长生命周期对象持有短生命周期对象的引用</p></li><li><p>内存泄漏举例</p>  <img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210314104850907.png" alt="image-20210314104850907" style="zoom:50%;" /><ul><li><p>左边的图：Java使用可达性分析算法，最上面的数据不可达，需要被回收</p><p>右边的图：后期一些短生命周期对象不用，应断开引用，但长生命周期对象持有引用，导致短生命周期对象无法回收</p></li><li><p>单例模式：单例的生命周期和应用程序一样长，所以在单例程序中，若持有对外部对象的引用，那么这个外部对象不能被回收，导致内存泄漏</p></li><li><p>一些提供部分 close() 的资源未关闭导致内存泄漏</p></li></ul></li></ul><h3 id="4-Stop-The-World"><a href="#4-Stop-The-World" class="headerlink" title="4. Stop The World"></a>4. Stop The World</h3><ul><li>GC 事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为 STW</li><li>可达性分析算法中枚举根节点 会导致所有 Java执行线程停顿<ul><li>分析工作必须在一个能确保一致性的快照中进行</li><li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li><li>如果出现分析过程中对象引用关系还在不断变化，则分析结构的准确性无法保证</li></ul></li><li>被STW中断的应用程序会在完成GC之后恢复，频繁中断令用户体验差，需要减少STW的发生</li><li>STW事件和采用哪款GC无关，所有的GC都有这个事件</li><li>哪怕时G1也不能完全避免STW，只能说回收效率越来越高，尽可能缩短了暂停时间</li><li>STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的线程全部停掉</li><li>开发中不要用 System.gc()，会导致 STW的发生</li></ul><h3 id="5-垃圾回收的并行与并发"><a href="#5-垃圾回收的并行与并发" class="headerlink" title="5. 垃圾回收的并行与并发"></a>5. 垃圾回收的并行与并发</h3><ul><li><p>并发</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210314110439921.png" alt="image-20210314110439921" style="zoom:50%;" /><ul><li>在操作系统中，是指一个时间段有几个常响都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行</li><li>并发不是真正意义上的 同时进行，只是CPU把一个时间段划分成几个时间片段，然后在这几个时间片段之间来回切换</li><li>由于 CPU 处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应该程序同时正在进行</li></ul></li><li><p>并行</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210314111651774.png" alt="image-20210314111651774" style="zoom:50%;" /><ul><li>当一个系统有两个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程不抢占CPU资源，可以同时进行，我们称之为并行</li><li>决定并行的因素不是CPU的数量，而是CPU核心数量，比如一个CPU多个核也可以并行</li></ul></li><li><p>并行与并发对比</p><ul><li>并发的是多个任务相互抢占资源，并行的多个任务之前不相互抢占资源</li><li>只有在多CPU或者一个CPU多核的情况中才会发生并行，否则，看似同时发生是事情其实都是并发执行</li></ul></li><li><p>垃圾回收的并行与串行</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210314112807100.png" alt="image-20210314112807100" style="zoom:50%;" /><ul><li>并行：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态</li><li>串行：相比较于并行概念，单线程执行，如果内存不够，则程序暂停，启动 JVM 垃圾回收器进行垃圾回收</li></ul></li><li><p>垃圾回收的并发</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210314113025875.png" alt="image-20210314113025875" style="zoom:50%;" /><ul><li>指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行</li><li>比如用户程序在继续运行，而垃圾收集器线程运行于另一个CPU上</li><li>典型垃圾回收器：CMS、G1</li></ul></li></ul><h3 id="6-安全点与安全区域"><a href="#6-安全点与安全区域" class="headerlink" title="6. 安全点与安全区域"></a>6. 安全点与安全区域</h3><h4 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h4><ul><li>程序执行时并非在所有地方都能停下来GC，只有在特定位置才能停顿下来开始 GC，这些位置称为 安全点</li><li>安全点的选择很重要，如果太少可能会导致GC等待时间太长，如果太频繁可能导致运行时的性能问题</li><li>大部分指令执行时间都非常短暂，通常会根据 **是否具有让程序长时间执行的特征 **为标准，如：选择一些执行时间较长的指令作为 安全点，如方法调用、循环跳转和异常跳转</li></ul><h4 id="安全点中断实现方式"><a href="#安全点中断实现方式" class="headerlink" title="安全点中断实现方式"></a>安全点中断实现方式</h4><ul><li>主动式中断：设置一个中断标志，各个线程运行到安全点的适合就会主动轮询这个标志，如果标志为真，则将自己进行中断挂起</li></ul><h4 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h4><ul><li>安全点 机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的 安全点，但是程序不执行的时候呢？</li><li>例如线程处于 Sleep状态或者 Blocked状态，这时候线程无法响应 JVM 的中断请求，走到安全点区挂起中断，JVM也不太可能等待线程被唤醒</li><li>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域的任何位置开始 GC 都是安全的。我们也可以把 安全区看作是被扩展了的 安全点</li></ul><h4 id="安全区域是执行流程"><a href="#安全区域是执行流程" class="headerlink" title="安全区域是执行流程"></a>安全区域是执行流程</h4><ul><li>当线程运行到 安全区域 的代码时，首先标识已经进入了 安全区，如果这段时间内发生GC，JVM会忽略标识为安全区状态的线程</li><li>当线程即将离开 安全区时，会检查 JVM 是否已经完成 GC，如果完成了，则继续运行。否则线程必须等待直到收到可以安全离开安全区的信号为止</li></ul><h2 id="四、垃圾回收器"><a href="#四、垃圾回收器" class="headerlink" title="四、垃圾回收器"></a>四、垃圾回收器</h2><h3 id="1-垃圾回收器分类"><a href="#1-垃圾回收器分类" class="headerlink" title="1. 垃圾回收器分类"></a>1. 垃圾回收器分类</h3><ul><li><p>按线程数分（垃圾回收线程数），可以分为串行垃圾回收器和并行垃圾回收器</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210314115156102.png" alt="image-20210314115156102" style="zoom:50%;" /><ul><li><p>串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。</p></li><li><p>并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-the-World”机制。</p><blockquote><p>适用场景</p><ul><li>在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的Client模式下的JVM中</li><li>在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器</li></ul></blockquote></li></ul></li><li><p>按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210314115510806.png" alt="image-20210314115510806" style="zoom:50%;" /><ul><li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间</li><li>独占式垃圾回收器（Stop the World）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束</li></ul></li><li><p>按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器。</p><ul><li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片，分配对象空间使用指针碰撞</li><li>非压缩式的垃圾回收器不进行这步操作，分配对象空间使用空闲列表</li></ul></li><li><p>按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器。</p></li></ul><h3 id="2-评估-GC-的性能指标"><a href="#2-评估-GC-的性能指标" class="headerlink" title="2. 评估 GC 的性能指标"></a>2. 评估 GC 的性能指标</h3><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>运行用户代码的时间占总运行时间的比例（总运行时间 &#x3D; 程序的运行时间 + 内存回收的时间）</p><ul><li><p>虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%</p></li><li><p>吞吐量优先，意味着在单位时间内，STW的时间最短</p></li><li><p>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快</p></li><li><p>因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致GC需要更长的暂停时间来执行内存回收</p></li><li><p>若吞吐量低，50%用于执行程序，50%用于垃圾回收，程序执行会很久</p><h4 id="暂停时间"><a href="#暂停时间" class="headerlink" title="暂停时间"></a>暂停时间</h4><p>是指一个时间段内应用程序线程暂停，让GC线程执行的状态</p><ul><li>GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的</li><li>暂停时间优先，意味着尽可能让单次STW的时间最短</li><li>低暂停时间（低延迟）较好，因为从最终用户的角度来看，不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此，具有较低的暂停时间是非常重要的，特别是对于一个交互式应用程序。</li><li>如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</li></ul></li></ul><blockquote><p>一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。现在标准：在最大吞吐量优先的情况下，降低停顿时间</p></blockquote><blockquote><ul><li>内存占用：Java堆区所占的内存大小。</li><li>垃圾收集开销：垃圾收集所用时间与总运行时间的比例。</li><li>收集频率：相对于应用程序的执行，收集操作发生的频率。</li><li>快速：一个对象从诞生到被回收所经历的时间。</li></ul></blockquote><h3 id="3-7种经典的垃圾收集器"><a href="#3-7种经典的垃圾收集器" class="headerlink" title="3. 7种经典的垃圾收集器"></a>3. 7种经典的垃圾收集器</h3><ul><li><p>串行回收器：Serial、Serial old</p></li><li><p>并行回收器：ParNew、Parallel Scavenge、Parallel old</p></li><li><p>并发回收器：CMS、G1</p></li><li><p>分代</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210314120149313.png" alt="image-20210314120149313" style="zoom:50%;" /></li><li><p>如何选择垃圾回收器</p></li><li><p>针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</p></li><li><p>如何查看默认垃圾收集器</p><ul><li>-XX:+PrintCommandLineFlags：查看命令行相关参数（包含使用的垃圾收集器）</li><li>使用命令行指令：jinfo -flag 相关垃圾回收器参数 进程ID</li></ul></li></ul><h4 id="串行垃圾回收器"><a href="#串行垃圾回收器" class="headerlink" title="串行垃圾回收器"></a>串行垃圾回收器</h4><ul><li><p>Serial  GC（年轻代  Client模式）：复制算法、串行回收、”Stop-the-World”机制</p></li><li><p>Serial Old GC（老年代 Client模式）：标记-压缩算法、串行回收和”Stop the World”机制</p><ul><li>Server模式下</li><li>与新生代的Parallel Scavenge配合使用</li><li>作为老年代CMS收集器的后备垃圾收集方案</li></ul></li><li><p>特点</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210314120716108.png" alt="image-20210314120716108" style="zoom:50%;" /><ul><li>它只会使用一个CPU或一条收集线程去完成垃圾收集工作<br>限定单个CPU环境：省去切换线程的开销</li><li>在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（STW）</li></ul></li><li><p>-XX:+UseSerialGC：指定年轻代和老年代都使用串行收集器</p></li></ul><h4 id="ParNew-回收器：年轻代（Parallel-New）复制、并行、STW"><a href="#ParNew-回收器：年轻代（Parallel-New）复制、并行、STW" class="headerlink" title="ParNew 回收器：年轻代（Parallel New）复制、并行、STW"></a>ParNew 回收器：年轻代（Parallel New）复制、并行、STW</h4><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210314120737438.png" alt="image-20210314120737438" style="zoom:50%;" /><ul><li>区别Serial GC：是否并行</li><li>新生代：回收次数频繁，使用并行方式高效</li><li>老年代：回收次数少，使用串行方式节省资源（切换线程）</li><li>适用范围<ul><li>ParNew收集器运行在多CPU的环境下，可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</li><li>单CPU：Serial GC</li></ul></li><li>设置 ParNew 垃圾回收器<ul><li>-XX:+UseParNewGC：指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代</li><li>-XX:ParallelGCThreads：限制线程数量，默认开启和CPU相同线程数</li></ul></li></ul><h4 id="Parallel-Scavenge-回收器：吞吐量优先、复制并行STW、server模式、Java8默认"><a href="#Parallel-Scavenge-回收器：吞吐量优先、复制并行STW、server模式、Java8默认" class="headerlink" title="Parallel Scavenge 回收器：吞吐量优先、复制并行STW、server模式、Java8默认"></a>Parallel Scavenge 回收器：吞吐量优先、复制并行STW、server模式、Java8默认</h4><ul><li><p>区别ParNew</p><ul><li>Parallel Scavenge收集器的目标：达到一个可控制的吞吐量</li><li>自适应调节策略</li></ul></li><li><p>适用范围</p><ul><li>高吞吐量可以高效率利用CPU时间，尽快完成程序的运算任务，主要适用于后台运算而不需要太多交互任务。因此，常见在服务器环境中使用。例如，执行批量处理、订单处理、工资支付、科学计算的应用程序。</li></ul></li><li><p>Parallel Old GC：标记-压缩、并行、STW、Java8默认</p>  <img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210314121144215.png" alt="image-20210314121144215" style="zoom:50%;" /></li><li><p>Parallel Scavenge 回收器参数设置</p><ul><li>-XX:+UseParallelGC ：指定年轻代使用Parallel并行收集器执行内存回收任务</li><li>-XX:+UseParallelOldGC：指定老年代使用并行回收收集器</li><li>默认jdk8开启。默认开启一个，另一个也会被开启。（互相激活）</li><li>-XX:ParallelGCThreads：设置年轻代并行收集器的线程数<ul><li>默认情况下，当CPU数量小于8个，ParallelGCThreads的值等于CPU数量</li><li>当CPU数量大于8个，ParallelGCThreads的值等于3+[5*CPU_Count]&#x2F;8]</li><li>避免过多的线程数影响垃圾收集性能</li></ul></li></ul></li><li><p>-XX:MaxGCPauseMillis：设置垃圾收集器最大停顿时间（即STW的时间）单位：毫秒</p><ul><li>为了尽可能地把停顿时间控制在XX:MaxGCPauseMillis 以内，收集器在工作时会调整Java堆大小或者其他一些参数</li><li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。该参数使用需谨慎</li></ul></li><li><p>-XX:GCTimeRatio：垃圾收集时间占总时间的比例，用于衡量吞吐量的大小</p><ul><li>取值范围(0, 100)。默认值99，也就是垃圾回收时间占比不超过1。等于 1 &#x2F; (N+1) </li><li>与前一个-XX:MaxGCPauseMillis参数有一定矛盾性</li><li>STW暂停时间越长，Radio参数就容易超过设定的比例</li></ul></li><li><p>-XX:+UseAdaptiveSizePolicy ：设置Parallel Scavenge收集器具有自适应调节策略</p><ul><li>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，来达到在堆大小、吞吐量和停顿时间之间的平衡点。</li><li>在手动调优比较困难的场合，可以直接使用这种自适应方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMillis），让虚拟机自己完成调优工作</li></ul></li></ul><h4 id="CMS-垃圾回收器"><a href="#CMS-垃圾回收器" class="headerlink" title="CMS 垃圾回收器"></a>CMS 垃圾回收器</h4><ul><li><p>CMS 回收器（Concurrent-Mark-Sweep）：标记-清除、并发、低延迟（STW）、老年代、客户端</p><ul><li><p>第一次实现了让垃圾收集线程与用户线程同时工作</p></li><li><p>匹配：ParNew、Serial GC 无法匹配：Parallel Scavenge</p></li><li><p>CMS 工作原理</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210314122244430.png" alt="image-20210314122244430" style="zoom:50%;" /><ul><li>初始标记（Initial-Mark）阶段：STW<br>程序中所有的工作线程都将会因为“Stop-the-World”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出GC Roots能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</li><li>并发标记（Concurrent-Mark）阶段<br>从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</li><li>重新标记（Remark）阶段：STW<br> 由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，并且也会导致“Stop-the-World”的发生，但也远比并发标记阶段的时间短</li><li>并发清除（Concurrent-Sweep）阶段<br>此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</li></ul></li></ul></li></ul><h4 id="CMS-特点与弊端分析"><a href="#CMS-特点与弊端分析" class="headerlink" title="CMS 特点与弊端分析"></a>CMS 特点与弊端分析</h4><ul><li>最耗时：并发标记、并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的</li><li>由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用–&gt;堆内存使用率达到某一阈值时，便开始进行回收</li><li>CMS运行期间预留的内存无法满足程序需求：出现“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用Serial old收集器来重新进行老年代的垃圾收集，这样停顿时间更长</li><li>并发清楚阶段：标记-清除算法、内存碎片、×指针碰撞技术、空闲列表执行内存分配</li><li>未用标签-压缩算法原因：<ul><li>并发清除时，用Compact整理内存，原来的用户线程使用的内存无法使用</li><li>需要 STW</li></ul></li></ul><blockquote><p>缺点总结：</p><ul><li>内存碎片–&gt;分配大对象–&gt;提前触发 Full GC</li><li>占用一部分线程–&gt;导致应用程序变慢，总吞吐量降低</li><li>无法处理浮动垃圾–&gt;Concurrent Mode Failure–&gt;Full GC<ul><li>在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</li></ul></li></ul></blockquote><h4 id="CMS-参数配置"><a href="#CMS-参数配置" class="headerlink" title="CMS 参数配置"></a>CMS 参数配置</h4><ul><li>-XX:+UseConcMarkSweepGC：手动指定使用CMS收集器执行内存回收任务。<br>开启该参数后会自动将-XX:+UseParNewGC打开。即：ParNew（Young区）+CMS（Old区）+Serial Old（Old区备选方案）的组合。</li><li>-XX:CMSInitiatingOccupanyFraction：设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。<ul><li>JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次CMS回收。JDK6及以上版本默认值为92%</li><li>如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。</li><li>反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Full GC的执行次数。</li></ul></li><li>-XX:+UseCMSCompactAtFullCollection：用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</li><li>-XX:CMSFullGCsBeforeCompaction：设置执行多少次Full GC后对内存空间进行压缩整理</li><li>-XX:ParallelCMSThreads：设置CMS的线程数</li></ul><blockquote><p>如何选择垃圾回收器？</p><ul><li>最小化地使用内存和并行开销：Serial GC</li><li>最大化应用程序的吞吐量：Parallel Scavenge GC</li><li>最小化GC的中断或停顿时间：CMS  GC</li></ul></blockquote><h4 id="G1-回收器"><a href="#G1-回收器" class="headerlink" title="G1 回收器"></a>G1 回收器</h4><p>区域化分代式（Garbage-First）复制算法、并行并发兼具、面向服务端</p><ul><li><p>目标：在延迟可控的情况下获得尽可能高的吞吐量</p></li><li><p>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW</p></li><li><p>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</p></li><li><p>分代收集</p><ul><li><p>区分年轻代和老年代，年轻代依然有Eden区和Survivor区</p></li><li><p>但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是物理连续的，也不再坚持固定大小和固定数量。</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210314122915131.png" alt="image-20210314122915131" style="zoom:50%;" /></li></ul></li><li><p>可预测的停顿时间模型</p><ul><li>设定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</li><li>G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li><li>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率</li></ul></li><li><p>G1 回收器的缺点</p><ul><li>用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（overload）都要比CMS要高。</li><li>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</li></ul></li><li><p>G1 参数配置</p><ul><li>-XX:+UseG1GC：手动指定使用G1垃圾收集器执行内存回收任务</li><li>-XX:G1HeapRegionSize：设置每个Region的大小<br>​值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1&#x2F;2000</li><li>-XX:MaxGCPauseMillis：设置期望达到的最大GC停顿时间指标，默认值：200ms</li><li>-XX:+ParallelGCThread：设置STW工作线程数。最多设置为8</li><li>-XX:ConcGCThreads：设置并发标记的线程数<br>​将n设置为并行垃圾回收线程数（ParallelGcThreads）的1&#x2F;4左右</li><li>-XX:InitiatingHeapOccupancyPercent：设置触发并发GC周期的Java堆占用率阈值<br>超过此值，触发GC。默认值：45</li></ul></li><li><p>G1 收集器的常见操作步骤</p><ul><li>G1的设计原则：简化JVM性能调优。开发人员只需要简单的三步即可完成调优</li><li>第一步：开启G1垃圾收集器</li><li>第二步：设置堆的最大内存</li><li>第三步：设置最大的停顿时间</li></ul></li><li><p>G1收集器的适用场景</p><ul><li>面向服务端应用，针对具有大内存、多处理器的机器</li><li>要低GC延迟，并具有大堆的应用程序提供解决方案<br>​在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）</li><li>用来替换掉JDK1.5中的CMS收集器；在下面的情况时，使用G1可能比CMS好<ul><li>超过50%的Java堆被活动数据占用</li><li>对象分配频率或年代提升频率变化很大</li><li>GC停顿时间过长（长于0.5至1秒）</li></ul></li><li>HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器均使用内置的JVM线程执行GC的多线程操作，而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程</li></ul></li><li><p>分区 Region：化整为零</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210314123150627.png" alt="image-20210314123150627" style="zoom:50%;" /><ul><li><p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。</p></li><li><p>XX:G1HeapRegionSize设定。所有的Region大小相同，且在JVM生命周期内不会被改变。</p></li><li><p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。</p></li><li><p>一个Region有可能属于Eden，Survivor或者Old&#x2F;Tenured内存区域。但是一个Region只可能属于一个角色。图中的E表示该Region属于Eden内存区域，S表示属于Survivor内存区域，O表示属于Old内存区域。图中空白的表示未使用的内存空间。</p></li><li><p>G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过0.5个Region，就放到H。</p><blockquote><p>设置 H 的原因</p><ul><li>对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。</li><li>为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。</li><li>如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。</li></ul></blockquote></li><li><p>Region的内部结构</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210314123454051.png" alt="image-20210314123454051" style="zoom:50%;" /><ul><li>每个Region都是通过指针碰撞来分配空间</li><li>每个Region都有TLAB，提高对象分配的效率</li></ul></li></ul></li></ul><h4 id="G1-垃圾回收流程"><a href="#G1-垃圾回收流程" class="headerlink" title="G1 垃圾回收流程"></a>G1 垃圾回收流程</h4><ul><li><p>G1 GC的垃圾回收过程主要包括如下三个环节</p></li><li><p>年轻代GC（Young GC）</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210314131011898.png" alt="image-20210314131011898" style="zoom: 50%;" /><ul><li><p>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</p></li><li><p>YGC时，首先G1停止应用程序的执行（Stop-The-World），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</p></li><li><p>然后开始如下回收过程</p><ol><li><p>第一阶段，扫描根</p><ul><li>根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等</li><li>根引用连同RSet记录的外部引用作为扫描存活对象的入口</li></ul></li><li><p>第二阶段，更新RSet</p><ul><li>处理dirty card queue（见备注）中的card，更新RSet。</li><li>此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用。</li></ul></li><li><p>第三阶段，处理RSet</p><ul><li>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</li></ul><p></p></li><li><p>第四阶段，复制对象</p><ul><li>此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象</li><li>如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到Old区中空的内存分段。</li><li>如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</li></ul><p></p></li><li><p>第五阶段，处理引用</p><ul><li>处理Soft，Weak，Phantom，Final，JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</li></ul></li></ol><ul><li><p>备注</p><ol><li>对于应用程序的引用赋值语句 oldObject.field&#x3D;new Object()，JVM会在之前和之后执行特殊的操作以在dirty card queue中入队一个保存了对象引用信息的card。</li><li>在年轻代回收的时候，G1会对Dirty Card Queue中所有的card进行处理，以更新RSet，保证RSet实时准确的反映引用关系。</li><li>那为什么不在引用赋值语句处直接更新RSet呢？这是为了性能的需要，RSet的处理需要线程同步，开销会很大，使用队列性能会好很多。</li></ol></li></ul></li></ul></li><li><p>老年代并发标记过程（Concurrent Marking）</p><ol><li>初始标记阶段<ul><li>标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC</li><li>正是由于该阶段时STW的，所以我们只扫描根节点可达的对象，以节省时间</li></ul><p></p></li><li>根区域扫描（Root Region Scanning）<ul><li>G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象</li><li>这一过程必须在Young GC之前完成，因Young GC会使用复制算法对Survivor区进行GC</li></ul></li><li>并发标记（Concurrent Marking）</li></ol><ul><li>在整个堆中进行并发标记（和应用程序并发执行），此过程可能被Young GC中断<ul><li>在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收</li><li>同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）</li></ul></li></ul><ol start="4"><li>重新标记（Remark）<ul><li>由于应用程序持续进行，需要修正上一次的标记结果。STW</li><li>G1中采用了比CMS更快的初始快照算法：Snapshot-At-The-Beginning（SATB）</li></ul></li><li>独占清理（cleanup，STW）</li></ol><ul><li>计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域</li><li>为下阶段做铺垫。是STW的。这个阶段并不会实际上去做垃圾的收集</li></ul><ol start="6"><li>并发清理阶段</li></ol><ul><li>识别并清理完全空闲的区域</li></ul></li><li><p>混合回收过程（Mixed GC）</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210315095509303.png" alt="image-20210315095509303" style="zoom:50%;" /><ul><li>当越来越多的对象晋升到老年代Old Region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了回收整个Young Region，还会回收一部分的Old Region</li><li>这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些Old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC</li><li>混合回收细节<ol><li>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算出来</li><li>默认情况下，这些老年代的内存分段会分8次（可以通过-XX:G1MixedGCCountTarget设置）被回收</li><li>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程</li><li>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收</li><li>XX:G1MixedGCLiveThresholdPercent，默认65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间</li><li>混合回收并不一定要进行8次。有一个阈值-XX:G1HeapWastePercent，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但回收到的内存却很少</li></ol></li></ul></li></ul><blockquote><p>（如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</p></blockquote><ul><li><p>顺时针，Young GC –&gt; Young GC+Concurrent Marking –&gt; Mixed GC，进行垃圾回收</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210315100135783.png" alt="image-20210315100135783" style="zoom:50%;" /></li><li><p>大致的回收流程</p><ol><li><p>应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；G1的年轻代收集阶段是一个并行的独占式收集器。</p></li><li><p>在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</p></li><li><p>当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。标记完成马上开始混合回收过程。</p></li><li><p>对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。</p></li><li><p>和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描&#x2F;回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起被回收的。</p><blockquote><p>举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p></blockquote></li></ol></li></ul><h4 id="G1-回收器垃圾回收过程：Remembered-Set（记忆集）"><a href="#G1-回收器垃圾回收过程：Remembered-Set（记忆集）" class="headerlink" title="G1 回收器垃圾回收过程：Remembered Set（记忆集）"></a>G1 回收器垃圾回收过程：Remembered Set（记忆集）</h4><ul><li><p>存在问题</p><ol><li>一个对象被不同区域引用的问题</li><li>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？</li><li>在其他的分代收集器，也存在这样的问题（而G1更突出，因为G1主要针对大堆）</li><li>回收新生代也不得不同时扫描老年代？这样的话会降低Minor GC的效率</li></ol></li><li><p>解决方法</p><ol><li>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描</li><li>每个Region都有一个对应的Remembered Set</li><li>每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作</li><li>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）</li><li>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中</li><li>当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏</li></ol></li><li><p>总结</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210315100435152.png" alt="image-20210315100435152" style="zoom:50%;" /><ul><li>在回收 Region 时，为了不进行全堆的扫描，引入了 Remembered Set</li><li>Remembered Set 记录了当前 Region 中的对象被哪个对象引用了</li><li>这样在进行 Region 复制时，就不要扫描整个堆，只需要去 Remembered Set 里面找到引用了当前 Region 的对象</li><li>Region 复制完毕后，修改 Remembered Set 中对象的引用即可</li></ul></li><li><p>G1 的注意事项</p><ul><li>G1 回收可选的过程四：Full GC<ol><li>G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（Stop-The-World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长</li><li>要避免Full GC的发生，一旦发生Full GC，需要对JVM参数进行调整。什么时候会发生Ful1GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到Full GC，这种情况可以通过增大内存来解决</li></ol></li><li>导致G1 Full GC的原因可能有两个<ol><li>回收Evacuation的时候没有足够的to-space来存放晋升的对象</li><li>并发处理过程完成之前空间耗尽</li></ol></li><li>G1 回收器的补充<ol><li>从Oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回一部分Region，停顿时间是用户可控制的，所以并不迫切去实现，而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中</li><li>另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案</li></ol></li><li>G1 回收器的优化建议<ul><li>年轻代大小<ol><li>避免使用-Xmn或-XX:NewRatio等相关选项显式设置年轻代大小</li><li>固定年轻代的大小会覆盖暂停时间目标</li></ol></li><li>暂停时间目标不要太过严苛<ol><li>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</li><li>评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量</li></ol></li></ul></li></ul></li></ul><h4 id="新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？"><a href="#新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？" class="headerlink" title="新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？"></a>新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？</h4><ul><li>新生代回收器：Serial、ParNew、Parallel Scavenge<ul><li>采用：复制算法，优点：效率高，缺点：内存利用率低（to区永远是空）；适用生命周期短的对象收集</li></ul></li><li>老年代回收器：Serial Old、Parallel Old、CMS<ul><li>采用：标记-清除-压缩算法</li></ul></li><li>整堆回收器：G1</li></ul><h2 id="五、垃圾回收器总结"><a href="#五、垃圾回收器总结" class="headerlink" title="五、垃圾回收器总结"></a>五、垃圾回收器总结</h2><h3 id="7-种垃圾回收器的比较"><a href="#7-种垃圾回收器的比较" class="headerlink" title="7 种垃圾回收器的比较"></a>7 种垃圾回收器的比较</h3><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210315102127059.png" alt="image-20210315102127059" style="zoom:50%;" /><h3 id="怎么选择垃圾回收器？"><a href="#怎么选择垃圾回收器？" class="headerlink" title="怎么选择垃圾回收器？"></a>怎么选择垃圾回收器？</h3><ol><li>优先调整堆的大小让JVM自适应完成</li><li>如果内存小于100M，使用串行收集器</li><li>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</li><li>如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择</li><li>如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器</li><li>官方推荐G1，性能高。现在互联网的项目，基本都是使用G1</li></ol><ul><li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li></ul><h3 id="GC-日志分析"><a href="#GC-日志分析" class="headerlink" title="GC 日志分析"></a>GC 日志分析</h3><ul><li><p>GC 日志参数设置：通过阅读GC日志，我们可以了解Java虚拟机</p><p>内存分配与回收策略</p></li><li><p>内存分配与垃圾回收的参数列表</p><ul><li><p>-XX:+PrintGC ：输出GC日志，类似：-verbose:gc</p><ul><li><p>输出信息</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210315102213052.png" alt="image-20210315102213052" style="zoom: 67%;" /></li><li><p>参数解析</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210315102243513.png" alt="image-20210315102243513" style="zoom:50%;" /></li></ul></li><li><p>-XX:+PrintGCDetails ：输出GC的详细日志</p><ul><li><p>输出信息</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210315102319597.png" alt="image-20210315102319597" style="zoom:50%;" /></li><li><p>参数解析</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210315102342532.png" alt="image-20210315102342532" style="zoom:50%;" /></li></ul></li><li><p>-XX:+PrintGCTimestamps ：输出GC的时间戳（以基准时间的形式）</p></li><li><p>-XX:+PrintGCDatestamps ：输出GC的时间戳</p><ul><li>以日期的形式，如2013-05-04T21: 53: 59.234 +0800</li><li>输出信息（日志带上了日期和时间）</li></ul></li><li><p>-XX:+PrintHeapAtGC ：在进行GC的前后打印出堆的信息</p>   <img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210315102416837.png" alt="image-20210315102416837" style="zoom:50%;" /></li><li><p>-XLoggc:.&#x2F;Logs&#x2F;gc.Log：日志文件的输出路径</p><ul><li>.&#x2F; 表示当前目录，在 IDEA中程序运行的当前目录是工程的根目录，而不是模块的根目录</li></ul></li></ul></li><li><p>日志分析的补充说明</p><ul><li>“[GC”和”[Full GC”说明了这次垃圾收集的停顿类型，如果有”Full”则说明GC发生了STW</li><li>使用Serial收集器在新生代的名字是Default New Generation，因此显示的是”[DefNew”</li><li>使用ParNew收集器在新生代的名字会变成”[ParNew”，意思是”Parallel New Generation”</li><li>使用Parallel scavenge收集器在新生代的名字是”[PSYoungGen”</li><li>老年代的收集和新生代道理一样，名字也是收集器决定的</li><li>使用G1收集器的话，会显示为”garbage-first heap”</li><li>Allocation Failure表明本次引起GC的原因是在年轻代中没有足够的空间能够存储新的数据</li><li>[ PSYoungGen: 5986K-&gt;696K(8704K) ] 5986K-&gt;704K (9216K)<ul><li>中括号内：GC回收前年轻代大小，回收后大小，（年轻代总大小）</li><li>括号外：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</li></ul></li><li>user代表用户态回收耗时，sys内核态回收耗时，real实际耗时。由于多核线程切换的原因，时间总和可能会超过real时间</li></ul></li><li><p>Young GC 图例</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210315102648003.png" alt="image-20210315102648003" style="zoom:50%;" /></li><li><p>Full GC 图例</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210315102706396.png" alt="image-20210315102706396" style="zoom:50%;" /></li><li><p>日志分析工具</p><ul><li>GCViewer</li><li>GCEasy</li></ul></li></ul>]]></content>
    
    
    <summary type="html">JVM 垃圾回收</summary>
    
    
    
    <category term="Java" scheme="https://fabian4.site/blog/categories/Java/"/>
    
    
    <category term="Java" scheme="https://fabian4.site/blog/tags/Java/"/>
    
    <category term="JVM" scheme="https://fabian4.site/blog/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM 运行时数据区</title>
    <link href="https://fabian4.site/blog/41789.html"/>
    <id>https://fabian4.site/blog/41789.html</id>
    <published>2021-02-14T16:00:00.000Z</published>
    <updated>2022-08-24T07:47:19.052Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-运行时数据区"><a href="#JVM-运行时数据区" class="headerlink" title="JVM 运行时数据区"></a>JVM 运行时数据区</h1><h2 id="一、-内存模型"><a href="#一、-内存模型" class="headerlink" title="一、 内存模型"></a>一、 内存模型</h2><ul><li>程序计数器：记录下一条字节码执行指令，实现分支循环跳转，异常处理，线程恢复等功能</li><li>虚拟机栈：存储局部变量表、操作数栈、动态链接、方法返回地址等信息。Java方法就调用</li><li>本地方法栈：本地方法调用</li><li>堆：所有线程共享，几乎所有对象示例都在堆中分配</li><li>方法区：用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据</li></ul><h2 id="二、栈和堆区别"><a href="#二、栈和堆区别" class="headerlink" title="二、栈和堆区别"></a>二、栈和堆区别</h2><ol><li><p>物理地址</p><ul><li><p>堆：对象分配物理地址不连续，性能相对栈弱些</p><p>GC考虑分配不连虚，产生算法提升性能：标记—消除、复制、标记—压缩、分代</p></li><li><p>栈：先进后出，物理地址连续，性能相对堆好些</p></li></ul></li><li><p>内存分配</p><ul><li>堆：在运行时分配，大小不固定</li><li>栈：局部变量，操作数，动态链接，方法返回地址等信息，<strong>程序方法的执行</strong></li></ul></li><li><p>程序可见性</p><ul><li>堆：所有线程共享，可见</li><li>栈：线程私有，只对线程可见，生命周期和线程相同</li></ul></li></ol><blockquote><ul><li>浅拷贝：增加一个指针指向已有的内存地址</li><li>深拷贝：增加一个指针指向新开辟的一块内存空间</li></ul><p><strong>原内存发生变化，浅拷贝也随之变化；深拷贝则不会随之改变</strong></p></blockquote><p><strong>静态变量—&gt;方法区</strong></p><p><strong>静态对象—&gt;堆</strong></p><h2 id="三、程序计数器PC寄存器"><a href="#三、程序计数器PC寄存器" class="headerlink" title="三、程序计数器PC寄存器"></a>三、程序计数器PC寄存器</h2><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><ul><li>运行时数据区中唯一不会出现OOM的区域，没有垃圾回收</li><li>每个线程有一个私有程序计数器，线程之间互不影响</li><li>程序计数器会存储当前线程正在执行的 Java 方法的 JVM 指令地址</li><li>如果正在执行的本地方法，这个计数器值应为空</li></ul><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210311171622548.png" alt="image-20210311171622548" style="zoom: 50%;" /><h3 id="PC寄存器存储字节码指令地址的作用"><a href="#PC寄存器存储字节码指令地址的作用" class="headerlink" title="PC寄存器存储字节码指令地址的作用"></a>PC寄存器存储字节码指令地址的作用</h3><ul><li>因为线程是一个个的顺序执行流，CPU需要不停的切换各个线程，这时候切换回来以后就知道从哪里开始执行</li><li>JVM 的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样子的字节码指令</li><li>记录下一条字节码执行的指令，实现分支循环跳转，异常处理，线程恢复等功能</li></ul><h3 id="PC寄存器被设定为私有原因："><a href="#PC寄存器被设定为私有原因：" class="headerlink" title="PC寄存器被设定为私有原因："></a>PC寄存器被设定为私有原因：</h3><ol><li>CPU 为每个线程分配时间片，多线程在一个特定的时间段只会执行某一个线程的方法，CPU会不停的进行任务切换，线程需要中断、恢复</li><li>CPU，多线程，分配时间片，只执行一个线程，CPU任务切换，线程中断恢复</li><li>各个线程，PC寄存器记录。当前字节码指令地址，各个线程之间可进行独立计算，防止相互干扰</li></ol><h2 id="四、虚拟机栈"><a href="#四、虚拟机栈" class="headerlink" title="四、虚拟机栈"></a>四、虚拟机栈</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><ul><li>Java 虚拟机栈，原先也叫 Java栈，每个线程创建都会创建一个虚拟机栈，内部保存一个个栈帧，对应着一次次的 Java方法调用</li><li>生命周期和线程的一致</li><li>主管 Java程序的运行，保存方法的局部变量（8种基本数据类型），对象的引用地址，部分结果，并参与方法的调用和返回</li></ul><blockquote><ol><li><p>快使有效的存储方式，访问速度仅次于程序计数器</p></li><li><p>JVM 直接对 Java栈的操作有两个</p><ul><li>每个方法执行，伴随着进栈</li><li>执行结束的出栈</li></ul></li><li><p>栈不存在垃圾回收，当时存在OOM、栈溢出</p><p>Java栈大小是动态或者固定不变的</p><ul><li>动态扩展、无法申请到足够的内存OOM</li><li>如果是固定，线程请求的栈容量超过固定值，则StackOverFlowError</li></ul></li></ol></blockquote><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210311171636514.png" alt="image-20210311171636514" style="zoom: 50%;" /><h3 id="2-栈的存储单位"><a href="#2-栈的存储单位" class="headerlink" title="2. 栈的存储单位"></a>2. 栈的存储单位</h3><ul><li>每个线程都有自己的栈，栈中的数据以栈帧格式存储</li><li>线程上正在执行的每个方法都各自对应一个栈帧</li><li>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各个数据信息</li><li>先进后出，后进先出</li><li>一条活动的线程中，一个时间点上，只会有一个活动的栈帧，只有当前正在执行的方法的栈顶栈帧是有效的，这个称为当前栈帧，对应的方法是当前方法，对应类是当前类</li><li>执行引擎运行的所有字节码指令只针对当前栈帧进行操作</li><li>如果方法中调用了其他方法，对应的新的栈帧会被创建出来，放在顶端，成为新的当前帧</li></ul><h3 id="3-栈运行原理"><a href="#3-栈运行原理" class="headerlink" title="3. 栈运行原理"></a>3. 栈运行原理</h3><ol><li>不同线程中包含的栈帧不允许存在相互引用</li><li>当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为新的栈帧</li></ol><blockquote><p>Java方法有两种返回方式</p><ul><li>正常函数返回，使用 return 指令</li><li>抛出异常，导致栈帧被弹出</li></ul></blockquote><h3 id="4-栈的内部结构"><a href="#4-栈的内部结构" class="headerlink" title="4. 栈的内部结构"></a>4. 栈的内部结构</h3><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210311171648585.png" alt="image-20210311171648585" style="zoom:50%;" /><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><ul><li><p>定义为一个数字数组，主要用于存储方法参数，定义在方法体内部的局部变量，数据类型包括各类基本数据类型，对象引用，以及 return address 类型</p></li><li><p>局部变量表建立在线程的栈上，是线程私有的，因此不存在数据安全问题</p></li><li><p>局部变量表容量个数，大小是在编译器确定下来的</p></li><li><p>存放编译器可知的 8种基本数据类型、引用类型， return address 类型</p></li><li><p>最基本的存储单元是 slot</p><p>32位占一个，64位占两个slot</p></li><li><p>表中变量只在当前方法调用中有效，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程</p></li><li><p>方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁</p></li></ul><blockquote><p>在栈帧中，与性能调优关系最密切的部分，就是局部变量表，方法执行时，虚拟机使用局部变量表完成方法的传递</p><p>局部变量表中的变量也是重要垃圾回收根节点，只要被局部变量表中直接或间接应用的对象都不会被回收</p></blockquote><h4 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h4><ul><li><p>计算过程中变量临时存储空间，保证计算过程的中间结果</p></li><li><p>当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的</p></li><li><p>每个操作数栈都会有一个明确的栈深度，用于存储数值，最大深度在编译器就定义好</p></li><li><p>栈中，32bit类型占用一个栈单位深度，64bit类型占用两个栈单位深度</p></li><li><p>操作数栈并非采用访问索引方式进行数据访问，而只能通过标准的入栈、出栈操作完成一次数据访问</p></li><li><p>如果被调用方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新程序计数器中下一条需要执行的字节码指令</p></li><li><p>Java 虚拟机的解释引擎是基于栈的执行引擎，其中栈就是操作数栈</p><blockquote><p>i++：先将 i 的值加载到操作数栈，再将 i 的值加 1</p><p>++i：先将 i 的值加 1，再将 i 的值加载到操作数栈</p></blockquote></li><li><p>栈顶缓存技术</p><ul><li>由于操作数是存储在内尺寸中，频繁的进行内存读写影响执行速度，将栈顶元素全部缓存到物理CPU的寄存器中，依次降低对内存的读写次数，提升执行引擎的执行效率，指令更少，执行速度更快</li><li>操作数栈顶元素缓存于寄存器</li></ul></li></ul><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><h5 id="指向运行时常量池的方法引用"><a href="#指向运行时常量池的方法引用" class="headerlink" title="指向运行时常量池的方法引用"></a><strong>指向运行时常量池的方法引用</strong></h5><ul><li>每个栈帧内部都包含一个指向运行时常量池中，改帧所属方法引用</li><li>包含引用目的：支持当前方法的代码实现动态链接，如invokrdynamic指令</li><li>在 java 源文件被编译成字节码文件中时，所有的变量、方法引用都作为符合引用，保存在class文件的常量池中</li><li>描述一个方法调用了其他方法：用常量池中指向方法的符合引用来表示。将符合引用转换为调用方法的直接引用</li></ul><h5 id="常量池、运行时常量池"><a href="#常量池、运行时常量池" class="headerlink" title="常量池、运行时常量池"></a><strong>常量池、运行时常量池</strong></h5><ul><li>常量池在字节码文件中，运行时常量池在运行时的方法区中</li><li>存储多一份，供多个方法调用、需记录索引、节省空间</li><li>提供符合、常量便于指令识别</li></ul><h4 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h4><ul><li>存放调用该方法的pc寄存器的值</li><li>方法的结束<ul><li>正常执行完成</li><li>出现未处理异常，非正常退出</li></ul></li><li>无论哪种方式退出，方法退出后，都会返回该方法被调用的位置。方法正常退出时，调用者的PC计数器的值作为返回地址，即调用改方法的指令的下一条指令地址</li><li>异常退出的，返回地址是通过异常表来确定，栈帧一般不会保存这部分信息</li><li>执行引擎遇到任意一个方法返回的字节码指令，会有返回值传递给上层的方法调用者，简称正常完成出口</li><li>本质上，方法的退出就是当前栈帧出栈的过程，此时需要恢复上层方法的局部变量表，操作数栈，将返回值压入调用者栈帧的操作数栈，设置PC寄存器值等，让调用者方法继续执行下去</li><li>正常完成出口和异常完成出口的区别在于：<strong>通过异常完成出口退出的不会给他的上层调用者产生任何返回值</strong></li></ul><blockquote><p>允许携带与 Java 虚拟机实现相关的一些附加信息，例如对程序调试提供支持的信息</p></blockquote><h3 id="5-本地方法栈"><a href="#5-本地方法栈" class="headerlink" title="5. 本地方法栈"></a>5. 本地方法栈</h3><ul><li>Java 虚拟机栈：Java方法调用；本地方法栈：本地方法调用</li><li>本地方法栈，线程私有。</li><li>允许被实现成固定或者是可动态扩展的内存大小<ul><li>内存溢出情况和 Java虚拟机栈相同</li></ul></li><li>使用 C 语言实现</li><li>具体做法是 Native Method Stack 中登记 native 方法，在Execution Engine执行时加载到本地方法库</li><li>当某个线程调用一个本地方法时，就会进入一个全新，不受虚拟机限制的世界，它和虚拟机拥有同样的权限</li><li>并不是所有的 JVM 都支持本地方法，因为 Java 虚拟机规范并没有明确要求本地方法栈的使用语言，具体实现方式，数据结构等</li><li>Hotspot JVM 中，直接将本地方法栈和虚拟机合二为一</li></ul><h2 id="五、堆"><a href="#五、堆" class="headerlink" title="五、堆"></a>五、堆</h2><ul><li><p>一个 JVM实例只存在一个堆内存</p></li><li><p>JVM 启动就创建，空间大小确定，可调节，参数 -Xms、-Xmx</p><ul><li>Java堆区在 JVM 启动的时候即被创建，其空间大小也就确认了。堆内存的大小是可调节的</li></ul></li><li><p>堆内存物理可以不联系，逻辑要连虚</p></li><li><p>所有线程共享 Java 堆，单个线程可以有 TLAB</p></li><li><p>所有对象实例、数组应该在运行时分配在堆上</p></li><li><p>几乎所有的对象实例都在堆分配另外内存。有些对象可能栈上分配：逃逸分析，标量替换</p></li><li><p>栈帧：保存引用，引用指向对象或数组在堆中的位置</p></li><li><p>方法结束后，堆中的对象不会马上被移除，<strong>仅仅在垃圾回收的时候才会被移除</strong></p><ul><li>eden区满，出发GC，进行垃圾回收</li><li>如果堆中对象马上被回收，用户线程会受影响</li></ul></li><li><p>堆是GC执行垃圾回收的重点区域</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210311171701695.png" alt="image-20210311171701695" style="zoom: 67%;" /></li><li><p>堆空间细分为</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210311171713126.png" alt="image-20210311171713126" style="zoom: 67%;" /><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210312154302127.png" alt="image-20210312154302127" style="zoom:50%;" /><p>-XX:+PrintGCDetails 可开启打印查看方法区实现</p><p><strong>设置堆内存的大小与 OOM</strong></p><ul><li><p>-Xms9m：堆空间的起始内存。X执行 memory start</p></li><li><p>-Xmx9m：堆空间的最大内存。X执行 memory max 超过最大内存将抛出 OOM</p></li><li><p>通常将 -Xms 和 -Xmx 两个参数配置相同的值</p><p>在 Java垃圾回收机制清理完堆区后不需要重新分配计算堆区的大小，从而提高性能</p></li><li><p>默认情况下</p><ul><li>初始内存大小：物理电脑内存大小的 1&#x2F;64</li><li>最大内存大小：物理电脑内存大小的 1&#x2F;4</li></ul></li><li><p>jps命令：查看当前程序运行的进程</p></li><li><p>jstat 查看 JVM 在 gc 时的统计信息</p><p>jstat -gc 进程号</p></li></ul><p><strong>新生代与老年代</strong></p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210312154336682.png" alt="image-20210312154336682" style="zoom: 67%;" /><ul><li><p>为什么要有新生代和老年代——优化 gc 性能</p><ul><li>根据不同区的特点使用不一样的垃圾回收算法</li></ul></li><li><p>新生代和老年代空间默认比例：1:2</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210312154400781.png" alt="image-20210312154400781" style="zoom:50%;" /><ul><li>-XX:NewPatio &#x3D; 2，表示新生代占 1，老年代占 2，新生代占整个堆的 1&#x2F;3</li></ul></li><li><p>jinfo -flag NewRatio 进程号，查看参数设定值</p></li><li><p>在HotSpot中，Eden空间和另外两个 Survivor 空间缺省所占的比如时：8:1:1</p><ul><li>-XX:SurvivorRatio调整这个空间比例</li></ul></li><li><p>为什么新生代划分 Eden和survivor</p><ul><li>如果没有 survivor区，Eden区进行溢出 MinorGC：存活对象 -&gt; 老年代–满 -&gt; MajorGC</li><li>MajorGC 消耗时间更长，影响程序执行和响应速度</li><li>survivor存在意义：增加进入老年代的筛选条件，减少送到老年代的对象，减少FullGC的次数</li></ul></li><li><p>为什么设置两个 survivor区</p><ul><li><p>只有一个survivor区，在第一次Eden区满进行MinorGC，存活对象放到survivor区；第二次Eden区满MinorGC -&gt; survivor区，会产生不连续的内存，无法存放更多的对象</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210312154527005.png" alt="image-20210312154527005"></p></li><li><p>设置三个四个 survivor 区，则每个被分配的 survivor 空间相对较小，很快被填满。</p></li><li><p>设置两个 survivor 区，在MinorGC时，可以将Eden区和非空的survivor区中存活的对象以连续存储的方式存入空的survivor区。减少碎片化</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210312154552247.png" alt="image-20210312154552247"></p></li><li><p>复制算法也是减少碎片化的过程</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210312154609558.png" alt="image-20210312154609558"></p></li><li><p><strong>几乎所有的 Java 对象都是在Eden区被 new 出来的</strong></p><ul><li>Eden 放不了的大对象，直接进入老年区了</li></ul></li><li><p>IBM 研究表明：新生代 80%的对象都是朝生夕死</p></li><li><p>-Xmn：设置新生代最大内存大小 memory new</p></li><li><p>新生区的对象默认什么周期超过 15，就会去养老区养老</p></li></ul></li><li><p>对象分配一般过程</p><ol><li><p>new 的对象先放 Eden区，放得下直接放入（此区有大小限制 参数 -Xmn 一般默认）</p></li><li><p>当创建新对象，Eden空间填满，会出发一次Minor GC&#x2F;YGC，将Eden不在被其他对象引用的对象进行销毁。将Eden中未销毁的对象移到 survive0 区。survive0区每个对象都有一个年龄计数器，一次回收还存在的对象，年龄加1</p></li><li><p>如果Eden有空间，加载的新对象放到 Eden区（超大对象放不下放入老年代）</p></li><li><p>再次eden区满，触发垃圾回收，回收eden+survive0，幸存下来的放在 survivor1 区，年龄加1</p></li><li><p>再垃圾回收，又会将幸存者放回 survive0 区，依此类推</p></li><li><p>超大对象放入老年代，老年代满或放不下，触发majorGC，再放不下，OOM</p></li><li><p>可以设置存活次数，默认15次，超过15次，对象将从年轻区步入老年区</p><p>-XX:MaxTenuringThreshold&#x3D;N 进行设置</p></li></ol><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210312154643215.png" alt="image-20210312154643215"></p><blockquote><p>新生代采用复制算法的目的：为了减少内碎片</p><p>频繁在新生区收集，很少在养老区收集，几乎不在永久区&#x2F;元空间搜集</p></blockquote></li><li><p>对象分配特殊过程</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210312154700719.png" alt="image-20210312154700719" style="zoom:50%;" /></li><li><p>触发YGC，幸存者区就会进行回收，不会主动进行回收</p></li><li><p>幸存区满了咋办</p><ul><li>Eden区满了才会触发YGC，幸存区满了不会</li><li>如果幸存区满了，新对象可能直接晋升老年代</li></ul></li></ul></li><li><p>JVM 调优工具</p><ul><li>Visual VM 实时监控</li><li>Jprofiler</li><li>Java Flight Recorder</li><li>jconsole 对内存、线程和类监控</li><li>jvisualvm<ul><li>JDK 自带的全能分析工具：内存快照、线程快照、程序死锁、监控内存变化、gc变化</li></ul></li></ul></li><li><p>MinorGC触发</p><ul><li>Eden区满触发，Survivor区满不触发，清理Eden+Survivor内存</li><li>Java对象大多朝生夕灭，MinorGC非常频繁</li><li>MinorGC会引发 STW</li></ul></li><li><p>老年代GC（MajorGC&#x2F;FullGC）触发</p><ul><li><p>老年代空间不足，会触发MinorGC，空间还不足，触发MajorGC或FullGC。还不足OOM</p></li><li><p>出现MajorGC，经常会伴随至少一次MinorGC</p><p>非绝对，在Parallel Scavenge收集器的收集策略里就直接进行MajorGC的策略选择过程</p></li><li><p>MajorGC速度比MinorGC慢10倍以上，STW时间更长</p></li></ul></li><li><p>FullGC触发机制</p><ol><li>调用System.gc()时，系统建议执行FullGC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>MinorGC后进入老年代的平均大小，大于老年代的可用内存</li><li>由Eden区，Survivor 0区向Survivor 1区复制时，对象的大小大于ToSpace可用内存，则把改对象转存到老年代，且老年代的可用内存小于该对象的大小</li><li>FullGC是开发或调优中尽量要避免的，这样暂停时间会短一些。</li></ol></li><li><p>Minor GC 针对于新生区，Major GC 针对于老年区，Full GC 针对于整个堆空间和方法区</p></li><li><p>为对象分配内存TLAB</p><ul><li>Thread Local Allocation Buffer</li><li>堆区是线程共享区域，任何线程都可以访问到堆区的共享数据</li><li>由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的。</li><li>为避免多个线程操作（指针碰撞方式分配内存）同一地址，需要使用加锁等机制，进而影响分配速度</li></ul></li><li><p>TLAB</p><ul><li><p>从内存模型而不是垃圾收集的角度，对Eden区域进行划分，JVM为每个线程分配了一个私有缓存区域，包含在Eden空间中</p></li><li><p>多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们将这种内存分配方式成为快速分配策略</p></li><li><p>openjdk衍生出来的JVM都提供了TLAB的设计</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210312154726045.png" alt="image-20210312154726045" style="zoom:50%;" /></li><li><p>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但是JVM确实是将TLAB作为内存分配的首选</p></li><li><p>开发人员通过-XX:UseTLAB设置是否开启TLAB空间</p></li><li><p>默认情况下，TLAB空间内存非常小，仅占有整个Eden空间的1%，通过-XX:TLABWasteTargetPercent设置TLAB空间所占用Eden空间的百分比大小</p></li><li><p>一旦对象在TLAB空间分配内存失败，JVM就会尝试通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存</p></li></ul></li><li><p>常用 JVM 调优参数</p><ul><li>-Xms2g：初始化堆大小为2g</li><li>-Xmx2g：最大堆内存为2g</li><li>-Xmn：设置新生区内存大小</li><li>-Xx:NewRatio&#x3D;2：设置新生代与老年代内存比例为1:2</li><li>-Xx:SurviveRatio&#x3D;8：设置eden区与survivor区内存比例为8:1:1</li><li>-XX:MaxTenuringThreshold：设置分代年龄阈值</li><li>-XX:+UseParNewGC：指定使用 ParNew + Serial Old垃圾回收器组合</li><li>-XX:+UseParallelGC：指定年轻代使用Parallel scavenge+parallel Old并行收集器执行内存回收任务</li><li>-XX:+UseParallelOldGC：默认jdk8开启。默认开启一个，另一个也会被开启（互相激活）</li><li>-XX:+PrintGC：开启打印 gc 信息</li><li>-XX:+PrintGCDetails：打印 gc 详细信息</li></ul></li></ul><h2 id="六、方法区"><a href="#六、方法区" class="headerlink" title="六、方法区"></a>六、方法区</h2><h3 id="栈、堆、方法区交互关系"><a href="#栈、堆、方法区交互关系" class="headerlink" title="栈、堆、方法区交互关系"></a>栈、堆、方法区交互关系</h3><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210312154759083.png" alt="image-20210312154759083" style="zoom:50%;" /><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210312154825595.png" alt="image-20210312154825595" style="zoom:50%;" /><h3 id="方法区定位"><a href="#方法区定位" class="headerlink" title="方法区定位"></a>方法区定位</h3><ul><li>《Java虚拟机规范》：尽管所有方法区在逻辑上属于堆一部分，但一些简单实现，可能不会进行垃圾收集或进行压缩。</li><li>对于HotSpot，方法区又名：Non0Heap（非堆），目的：区分堆。</li><li>方法区看作是一块独立于 Java堆的内存空间</li></ul><h3 id="方法和堆的异同"><a href="#方法和堆的异同" class="headerlink" title="方法和堆的异同"></a>方法和堆的异同</h3><ul><li>方法区主要存放 Class，堆中主要存放实例化对象</li><li>各个线程共享</li><li>物理内存空间可以不连续，逻辑空间要连续</li><li>可以选择固定大小或者可扩展</li><li>方法区大小决定了系统可以保存多少个类，如果类定义太多，导致方法区溢出，JVM同样抛出内存溢出异常 OOM<ul><li>java.lang.OutofMemoryError:PermGen space</li><li>java.lang.OutofMemoryError:Metaspace</li></ul></li><li>关闭 JVM 就会释放这个区域的内存</li></ul><blockquote><p>可能会 OOM：</p><ol><li>加载大量的第三方 jar 包</li><li>Tomcat 部署的工程过多 （30-50个）</li><li>大量动态的生成反射类</li></ol></blockquote><h3 id="HotSpot中方法区的演进"><a href="#HotSpot中方法区的演进" class="headerlink" title="HotSpot中方法区的演进"></a>HotSpot中方法区的演进</h3><ul><li>HostSpot可看作方法区永久代等价，本质不等价，《Java虚拟机规范》对如何实现方法区，不做统一要求。</li><li>在jdk7及以前：方法区 -&gt; 永久代，jdk8开始：永久代 -&gt; 元空间<ul><li>元空间永久代都是对 JVM 规范中方法区的实现</li><li>元空间永久代区别：元空间不在虚拟机中设置内存，使用本地内存（堆外内存）</li><li>根据 JVM 规范，如果方法区无法满足新的内存分配需求，将抛出 OOM 异常</li></ul></li><li>永久代更容易导致 Java程序 OOM （超过 -XX:Max:Permsize上限）</li></ul><h3 id="方法区的内部结构"><a href="#方法区的内部结构" class="headerlink" title="方法区的内部结构"></a>方法区的内部结构</h3><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210312154915917.png" alt="image-20210312154915917" style="zoom:50%;" /><p><strong>方法区存储什么</strong></p><ul><li><p>用于存储已被虚拟机加载的类型信息，常量，静态变量，即时编译器编译后的代码缓存</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210312154930976.png" alt="image-20210312154930976" style="zoom:50%;" /></li><li><p>对于每个加载的类型（类、接口、枚举、注解）JVM 必须在方法区存储以下信息</p><ul><li>这个类的修饰符（public、abstract..）</li><li>这个类的完整有效名称</li><li>这个类型直接父类的完整有效名称（接口则为 Object 类）</li><li>这个类型直接接口的一个有序列表</li><li>例如：public class MethodInnerStrucTest extends Object implements Comparable&lt;String&gt; Serializable</li></ul></li><li><p>域 Field 信息</p><ul><li>域修饰符</li><li>域类型</li><li>域名称</li><li>例如：public int num &#x3D; 10；</li></ul></li><li><p>域信息特殊情况</p><ul><li>类变量</li><li>全局常量</li></ul></li><li><p>方法信息</p><ul><li>方法修饰符</li><li>返回类型 void对应 void.class</li><li>方法名称</li><li>方法参数的数量和类型</li><li>方法的字节码、操作数栈、局部变量表及大小（native、和abstract除外）</li><li>异常表，记录每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址，被捕获的异常类的常量池索引</li></ul></li><li><p>运行时常量池和常量池</p><ul><li>方法区内部包含了运行时常量池</li><li>字节码文件内部包含了常量池<ul><li>运行时将常量池加载到方法区，就是运行时常量池</li><li>执行时，将常量池中的符号引用转换为直接引用</li></ul></li><li>加载类的信息在方法区，需要理解字节码文件</li><li>要弄清方法区的运行时常量池，需要理解字节码文件中的常量池</li><li>运行时常量池，相对class文件常量池：具备动态性</li></ul></li><li><p>常量池</p><ul><li>字节码文件包含：类的版本信息、字段、方法以及接口等描述信息</li><li>还包含常量池表，包括编译生成各个字面量和对类型、域和方法的符号引用</li><li>为什么要用常量池<ul><li>一个 java源文件中的类、接口、编译后产生字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大，以至于不能直接存到字节码里</li><li>可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接会用到运行时常量池</li><li>编译产生字节码文件需要大量数据支持，不能存在字节码文件中，存到常量池里，字节码包含指向常量池的引用</li></ul></li><li>常量池存什么<ul><li>数量值</li><li>字符串值</li><li>类引用</li><li>字段引用</li><li>方法引用</li></ul></li></ul></li></ul><blockquote><p>常量池，可以看做一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等指令</p></blockquote><ul><li><p>运行时常量池</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210312155000151.png" alt="image-20210312155000151" style="zoom:50%;" /><ul><li>是方法区的一部分</li><li>常量池表是 class 字节码文件一部分，用于存放编译生成各个字面量和对类型、域和方法的符号引用。这部分内容将在类加载后存放到方法区的运行时常量池中</li><li>创建：在加载类和接口到虚拟机后，就会创建对应的运行时常量池</li><li>当创建类或接口的运行时常量池，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值。则 JVM 会抛出OOM异常</li><li>JVM 为每个已加载的类好了接口都维护一个运行常量池，池中的数据像数组项引用，通过索引访问</li><li>运行时常量池，相对于 class 文件常量池：具备动态性</li></ul></li></ul><h3 id="HotSpot虚拟机对象"><a href="#HotSpot虚拟机对象" class="headerlink" title="HotSpot虚拟机对象"></a>HotSpot虚拟机对象</h3><h4 id="对象的实例化"><a href="#对象的实例化" class="headerlink" title="对象的实例化"></a>对象的实例化</h4><ul><li><p>创建对象的方式</p><ol><li>new<ul><li>最常见的方式</li><li>变形：Xxx的静态方法</li><li>XxxBuilder&#x2F;XxxFactory的静态方法</li></ul></li><li>Class 的 newInstance<ul><li>JDK 9标记过，反射的反射之类调用空参的构造器，权限必须是public</li></ul></li><li>Constructor 的 newInstance<ul><li>反射的方式，可以调用带参的构造器，权限没有要求</li></ul></li><li>使用 clone<ul><li>不调用任何构造器，当前类需要实现 Cloneable 接口，实现 cloen 方法</li></ul></li><li>使用反序列化<ul><li>从文件、网络等获取一个对象的二进制流</li></ul></li><li>第三方库 Objenesis</li></ol></li><li><p>创建对象的步骤</p><ol><li><p>判断对像对应的类是否被常量池加载</p><p>当虚拟机遇到一条字节码new指令时。首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否被加载解析初始化过。如果没有，在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为key值进行查找对应的.class文件，如果没有找到文件，则抛出ClassNotFoundException异常</p></li><li><p>（类加载通过后）为对象分配内存</p><ul><li><p>首先计算对象占用空间大小，接着在堆中划分一块内存给新对象</p><ul><li>如果实例成员变量是引用变量，仅分配引用变量空间，即4个字节大小</li><li>如果Java堆内存中不规整，虚拟机就必须维护一个列表，记录哪些内存可用，哪些不可用。分配的时候在列表中找一个足够大的空间分配，然后更新列表。这种分配方式叫空闲列表(Free List)。–&gt;标记-清除算法</li><li>假设Java 堆中内存是规整的，所有被使用过的内存放在一边，空闲的内存放在另一边，中间放一个指针作为分界点指示器。那么内存分配就是指针指向空闲的方向，挪动一段与对象大小相等的距离。指针碰撞（Bump The Pointer）。–&gt;标记-清除-压缩算法</li></ul></li><li><p>选择哪种由 Java堆是否规整决定，Java堆是否规整由所采用的垃圾收集器是否带有空间压缩整理的能力决定</p><ul><li>当使用Serial、ParNew等带有压缩整理过程的收集器，指针碰撞简单高效</li><li>当使用CMS基于清除（Sweep）算法收集器时，只能采用空闲列表来分配内存；（CMS为了能在多数情况下分配内存更快，设计了一个Linear Allocatioin Buffer的分配缓冲区，通过空闲列表拿到一大块分配缓冲区后，在它里面仍可使用指针碰撞方式分配）</li></ul></li></ul></li><li><p>处理并发安全问题</p><ul><li><p>对象创建是非常频繁的行为，还需要考虑并发情况下，仅仅修改一个指针所指向的位置也是不安全的，例如正在给对象A分配内存，指针还未修改，对象B又使用原来的指针分配内存。解决问题有两种可选方案：: CAS同步处理、本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)</p><ul><li>对分配内存空间的动作进行同步处理。实际上虚拟机采取CAS配上失败重试的方式保证更新操作的原子性。</li><li>把内存分配的动作按照线程划分到不同的空间中进行，每个线程在Java堆中，预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。</li></ul></li><li><p>虚拟机是否使用TLAB，可以通过-XX: +&#x2F;-UseTLAB参数来设定。</p></li></ul></li><li><p>初始化分配到空间</p><p>内存分配完成后，虚拟机将分配到的内存空间（不包括对象头）都初始化为零值。如果使用了TLAB，这个工作可以提前到TLAB分配时进行。这步操作保证对象的实例字段在Java代码中，可以不赋初始值就直接使用，程序可以访问到字段对应数据类型所对应的零值。</p></li><li><p>设置对象的对象头</p><p>接下来Java虚拟机还要对对象进行必要的设置，例如对象是哪个类的实例、如何才能找到类的元数据信息，对象的哈希码（实际上对象的HashCode会延后真正调用Object::hashCode()方法时才计算）、对象的GC分代年龄等信息。这些信息存放到对象的对象头（Object Header）</p></li><li><p>执行init方法初始化</p><p>上面工作完成后，从虚拟机角度来说，一个新的对象已经产生了，但是从Java程序的视角来说，对象创建才刚刚开始，对象的构造方法（Class文件中init()方法）还未执行，所有字段都是默认的零值。new指令之后接着执行init方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全构造出来</p></li></ol></li></ul><h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h4><ol><li><p>对象头</p><ul><li>包括两个部分<ul><li>这部分数据的长度在32位和64位的虚拟机（未开启指针压缩中）分别是32bit和64bit，【Mark Word】运行时元数据<ul><li>哈希值</li><li>GC分代年龄</li><li>锁状态标志</li><li>线程持有的锁</li><li>偏向线程ID</li><li>偏向时间戳</li><li>对象头里的信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，根据对象状态的不同，Markword可以复用自己的空间</li></ul></li><li>类型指针 Klass Word<ul><li>即对象执行它的类型元数据的指针，Java虚拟机通过这个指针来确认该对象属于哪个类的实例</li></ul></li><li>说明：如果是数组，还需要记录数组的长度</li></ul></li></ul></li><li><p>实例数据</p><p>对象的实例数据部分，是对象的真正存储的有效信息，即我们在程序代码中定义的各种类型的字段内容，无论是父类继承下来，还是子类中定义的字段都要记录下来。</p><ol><li>这部分的存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。</li><li>分配策略参数-XX:FieldsAllocationStyle</li><li>HotSpot虚拟机默认的分配顺序为longs&#x2F;doubles、ints、shorts&#x2F;chars、bytes&#x2F;booleans、oops（Ordinary Object Pointers）</li><li>从默认的分配策略中可以看出，相同宽度的字段总被分配到一起存放。</li><li>在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。</li><li>如果HotSpot虚拟机的+XX：CompactFields参数值为true（默认也是true），那么子类中较窄的变量也允许插入父类变量的空隙之间，以节省空间。</li></ol></li><li><p>对齐填充</p><p>仅起占位符作用</p><ul><li>因为 HotSpot 虚拟机字段内存管理系统，要对对象的起始地址要求8字节的整数倍</li><li>对象头已经精心设计为8字节的整数倍，1倍或者2倍</li><li>对象实例数据部分若未对齐，需对齐填充</li></ul></li></ol><h4 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h4><p>Java程序需要通过 JVM 栈上的引用访问堆中的具体对象</p><ul><li><p>直接指针：指向对象，代表一个对象在内存中的起始地址</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210312155036755.png" alt="image-20210312155036755" style="zoom:50%;" /></li><li><p>句柄：可以理解为指向指针的指针，维护着对象的指针。句柄不直接指向对象，而是指向对象的指针（句柄不发生变化，指向固定内存地址），再由对象的指针指向对象的证书内存地址</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210312155052962.png" alt="image-20210312155052962" style="zoom:50%;" /></li></ul><blockquote><ul><li>使用句柄最大好处：reference中存放稳定句柄地址，在对象被移动时（垃圾收集）只改变句柄中实例数据指针，reference本身不改变。</li><li>使用指针最大好处：速度快，节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，所以积少成多也是一项可观的执行成本。(HotSpot所采用)</li></ul></blockquote><h2 id="七、直接内存"><a href="#七、直接内存" class="headerlink" title="七、直接内存"></a>七、直接内存</h2><ul><li>不是虚拟机运行时数据区的一部分，也不是 Java虚拟机规范中定义的内存区域</li><li>直接内存是在 Java堆外的，直接向系统申请的内存区间</li><li>来源于 NIO （non-blocking IO），通过存在堆中的 DirectByteBuffer操作Native内存</li><li>通常，访问直接内存的速度会优于 Java堆，即读写性能高<ul><li>因此处于性能考虑，读写频繁的场合可能会考虑使用直接内存</li><li>Java 的 NIO库允许使用 Java程序直接使用内存，用于数据缓冲区</li></ul></li><li>也可能导致 OOM 异常<ul><li>直接内存在堆外，所以大小不受限与 -Xmx 指定的最大堆大小</li><li>当时内存系统是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存</li></ul></li><li>缺点<ol><li>分配回收成本较高</li><li>不受 JVM 内存回收管理</li></ol></li><li>直接内存大小可以通过 MaxDirectMemorySize设置</li><li>如果不指定，默认与堆的最大值 -Xmx 参数一致</li></ul>]]></content>
    
    
    <summary type="html">JVM 运行时数据区</summary>
    
    
    
    <category term="Java" scheme="https://fabian4.site/blog/categories/Java/"/>
    
    
    <category term="Java" scheme="https://fabian4.site/blog/tags/Java/"/>
    
    <category term="JVM" scheme="https://fabian4.site/blog/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM 架构、类加载子系统和执行引擎</title>
    <link href="https://fabian4.site/blog/41489.html"/>
    <id>https://fabian4.site/blog/41489.html</id>
    <published>2021-02-09T16:00:00.000Z</published>
    <updated>2022-08-24T07:47:19.052Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-架构、类加载子系统和执行引擎"><a href="#JVM-架构、类加载子系统和执行引擎" class="headerlink" title="JVM 架构、类加载子系统和执行引擎"></a>JVM 架构、类加载子系统和执行引擎</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><ol><li>jvm是一种用于计算设备的规范，它是一个虚构出来的机器，是通过在实际的计算机上仿真模拟各种功能实现的。</li><li>jvm包含一套字节码指令集，一组寄存器，一个栈，一个垃圾回收堆和一个存储方法域。</li><li>jvm屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码）,就可以在多种平台上不加修改地运行。</li></ol><blockquote><p>JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。</p></blockquote><ul><li>JDK(Java Development Kit)，是开发者用来编译、调试程序用的开发包。JDK也是JAVA程序需要在JRE上运行。</li><li>JRE(Java Runtime Environment)，也就是java平台。所有的java程序都要在JRE环境下才能运行。</li><li>JVM(Java Virtual Machine)，是JRE的一部分。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。</li></ul><blockquote><p>JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。<br>Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。</p></blockquote><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210312154041273.png" alt="image-20210312154041273" style="zoom: 50%;" /><ol><li><p>编译型语言(C++以及Fortran)的优缺点：</p><ul><li>速度快：因为在编译的时候它们能够获取到更多的有关程序结构的信息，从而有机会对它们进行优化。</li><li>适用性差：它们编译得到的二进制代码往往是CPU相关的，在需要适配多种CPU时，可能需要编译多次。</li></ul></li><li><p>解释型语言(PHP以及Perl)的优缺点：</p><ul><li>适应性强：只需要安装正确的解释器，程序在任何CPU上都能够被运行</li><li>速度慢：因为程序需要被逐行翻译，导致速度变慢。同时因为缺乏编译这一过程，执行代码不能通过编译器进行优化。</li></ul></li><li><p>Java的做法是找到编译型语言和解释性语言的一个中间点：</p><ul><li>Java代码会被编译：被编译成Java字节码，而不是针对某种CPU的二进制代码。</li><li>Java代码会被解释：Java字节码需要被java程序解释执行，此时，Java字节码被翻译成CPU相关的二进制代码。</li><li>JIT编译器的作用：在程序运行期间，将Java字节码编译成平台相关的二进制代码。正因为此编译行为发生在程序运行期间，所以该编译器被称为Just-In-Time编译器。</li></ul></li></ol><h2 id="二、架构设计图"><a href="#二、架构设计图" class="headerlink" title="二、架构设计图"></a>二、架构设计图</h2><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210311171429408.png" alt="image-20210311171429408" style="zoom:50%;" /><ul><li>类加载子系统：加载字节码文件到运行数据区的方法区</li><li>执行引擎：执行字节码文件中的指令</li><li>本地方法接口：java调用其他语言的接口，与本地资源交互</li><li>运行时数据区：JVM的内存</li></ul><h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a><strong>执行流程</strong></h3><ol><li>首先通过编译器把Java代码转换成字节码</li><li>类加载器再把字节码加载到内存中，将其放在运行时数据区的方法区内</li><li>执行引擎将字节码翻译成底层系统指令，再交由CPU去执行</li><li>这个过程需要调用其他语言的本地库接口来实现整个程序的功能</li></ol><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210311171521971.png" alt="image-20210311171521971" style="zoom: 50%;" /><h3 id="JVM-架构模型-基于栈式（虚拟机栈）"><a href="#JVM-架构模型-基于栈式（虚拟机栈）" class="headerlink" title="JVM 架构模型  基于栈式（虚拟机栈）"></a><strong>JVM 架构模型  基于栈式（虚拟机栈）</strong></h3><ul><li><p>优点</p><ol><li><p>设计和实现简单，适用于资源受限的系统</p></li><li><p>避开了寄存器的分配难题：使用零地址指令方式分配</p><p>操作栈顶元素不需要地址</p></li><li><p>指令流中大部分都是零地址指令，执行过程依赖操作栈，指令集更小，编译器容易实现。</p><p>8位字节码，指令集更小，但完成一项操作花费的指令相对多</p></li><li><p>不需要硬件支持，可移植性更好，更好实现跨平台</p></li></ol></li><li><p>缺点</p><p>性能下降，实现同样的功能需要更多的指令，毕竟还要入栈出栈等操作</p></li></ul><blockquote><p>javap 查看字节码</p><ul><li>-v 输出附加信息</li><li>-l 输出行号和本地变量表</li><li>-p 显示所有类和成员</li><li>-c 对代码进行反汇编</li></ul></blockquote><h3 id="JVM-生命周期"><a href="#JVM-生命周期" class="headerlink" title="JVM 生命周期"></a><strong>JVM 生命周期</strong></h3><ol><li>虚拟机启动<ul><li>通过引导类加载器 bootstrap class loader 创建一个初始类来完成，这个类是由虚拟机的具体实现指定的</li></ul></li><li>虚拟机执行<ul><li>执行一个所谓的 Java 程序的实现，真正执行的是一个叫 Java 虚拟机的进程</li></ul></li><li>虚拟的推出<ul><li>程序正常执行结束</li><li>执行过程遇到异常或错误而异常终止</li><li>操作系统错误导致Java虚拟机进程终止</li><li>Runtime类或者System类的exit方法、runtime类的halt方法，并且Java安全管理器允许这次exit或halt操作<ul><li>halt停止、停下、阻止</li><li>exit方法</li></ul></li><li>JNI规范描述了用JNI Invocation API 来加载或卸载 Java虚拟机时，Java虚拟机退出的情况</li></ul></li></ol><h2 id="三、类加载子系统"><a href="#三、类加载子系统" class="headerlink" title="三、类加载子系统"></a>三、类加载子系统</h2><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h3><ul><li><p>负责从文件系统或者网络中加载Class文件，Class文件开头有特定文件标识</p></li><li><p>Classloader只负责class文件的加载，是否可以运行，由执行引擎决定</p></li><li><p>加载类信息存到内存</p><p>方法区除了类信息，方法区还会存放运行时常量池信息，还可能包括字符串字面量和数字常量</p><p>常量池运行时加载到内存中，即运行时常量池</p></li><li><p>类加载器加载字节码文件到内存</p></li></ul><h3 id="2-角色"><a href="#2-角色" class="headerlink" title="2. 角色"></a>2. 角色</h3><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210311171534145.png" alt="image-20210311171534145" style="zoom:50%;" /><h3 id="3-加载过程"><a href="#3-加载过程" class="headerlink" title="3. 加载过程"></a>3. 加载过程</h3><ol><li><p>加载：根据查找路径找到相应的class文件然后导入</p><ul><li>通过一个类的全限定类名获取定义此类的二进制字节流<ul><li>本地系统获取</li><li>网络获取，Web Applet</li><li>zip压缩包获取，jar，war</li><li>运行时计算生成，动态代理</li><li>有其他文件生成，jsp</li><li>专有数据库提取 .class 文件，比较少见</li><li>加密文件中获取，防止Class文件被反编译的保护措施</li></ul></li><li>将这个字节流所代表的静态存储结果转化为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据访问入口</li></ul></li><li><p>验证：检查加载的 class 文件的正确性，确保被加载类的正确性，不会危害虚拟机自身安全</p><ul><li>文件格式验证<ol><li>是否以 0xCAFEBABE 开头</li><li>主次版本号</li><li>常量池的常量中是否有不被支持的常量类型</li><li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量</li></ol></li><li>元数据验证<ol><li>对字节码描述的信息进行语义分析，保证符号Java规范</li><li>类是否有父类，除了Object类之外，所有类都应该有父类</li><li>类的父类是否继承了不允许被继承的类（ 被final修饰的类 ）</li><li>如果这个类不是抽象类，是否实现了其父类或接口中要求实现的所有方法</li><li>类的字段，方法是否与父类的产生矛盾。例如方法参数都一样，返回值不用。</li></ol></li><li>字节码验证<ol><li>通过数据流分析和控制流分析，确定程序语义是合法的，符合逻辑的</li><li>对类的方法体，进行校验分析，保证在运行时不会做出危害虚拟机的行为</li><li>保证任意时刻操作数栈的数据类型与指令代码都能配合工作</li><li>保障任何跳转指令都不会跳转到方法体之外的字节码指令上</li></ol></li><li>符合引用验证<ol><li>通过字符串描述的全限定类名是否能找到对应的类</li><li>符合引用的类、字段、方法的可访问性是否可被当前类访问</li></ol></li></ul></li><li><p>准备：给类中的静态变量分配内存空间</p><ul><li><p>为类变量（静态变量）分配内存，并且设置该类变量的初始值，即零值</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210311171549757.png" alt="image-20210311171549757"></p></li><li><p>不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显示初始化</p></li><li><p>不会为实例变量分配初始化，类变量会分配在方法区中，示例变量会随着对象一起分配到Java堆中</p></li></ul></li><li><p>解析：虚拟机将常量池中的符号引用替换成直接引用的过程</p><p>解析动作主要针对类，或接口，字段，类方法，接口方法，方法类型等。</p></li><li><p>初始化：对静态变量和静态代码块执行初始化工作</p><ul><li><p>执行类的构造器方法 clinit 的过程</p></li><li><p>此方法不需要定义，是 Javac 编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来</p><p>如果没有类变量和静态代码块，也不会有 clinit</p></li><li><p>构造器方法中指令按照语句在源文中出现的顺序执行</p></li><li><p>clinit 不同于类的构造器</p><p>构造器是虚拟机视角下的 init</p></li><li><p>若该类有父类，JVM 会保证子类的 clinit 执行前，父类的 clinit 已经执行完毕</p></li><li><p>虚拟机必须保证一个类的 clinit 方法在多线程下被同步加锁</p></li></ul></li></ol><blockquote><p>JVM 把描述类的数据从Class文件加载到内存(方法区)，并对数据进行校验，解析和初始化</p></blockquote><h3 id="4-类加载器"><a href="#4-类加载器" class="headerlink" title="4. 类加载器"></a>4. 类加载器</h3><p><strong>通过类的全限定类名获取该类的二进制字节流的代码块叫做类加载器</strong></p><h4 id="四种类加载器"><a href="#四种类加载器" class="headerlink" title="四种类加载器"></a>四种类加载器</h4><ul><li><p>启动类加载器 <code>Bootstrap ClassLoader</code>：用来加载java核心类库，无法被java程序直接引用</p></li><li><p>扩展类加载器 <code>extensions class loader</code>：它用来加载 Java 的扩展库。JVM 的实现会提供一个扩展库目录。该类会在此目录里面查找并加载 Java 类</p></li><li><p>系统类加载器 <code>system class loader</code>：它根据 Java 应用的类路径 （CLASSPATH）来加载 Java 类。</p><p>一般来说，Java 应用的类都是由它类完成加载的。可用通过 <code>ClassLoader.getSystemClassLoader()</code> 来获取它</p></li><li><p>用户自定义类加载器，通过继承 <code>java.lang.ClassLoader</code> 类的方式实现</p></li></ul><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210311171601073.png" alt="image-20210311171601073" style="zoom:50%;" /><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>Java虚拟机对Class文件采用的是按需加载，而且加载Class文件时，Java虚拟机使用的是双亲委派模型，即把请求交由父类处理，它是异种任务委派模式</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210311171611359.png" alt="image-20210311171611359" style="zoom:50%;" /><ol><li>如果一个类加载器收到了类加载请求，它并不会自己先去加载。而是把这个请求委托给父类加载器去执行</li><li>如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器</li><li>如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式</li></ol><p><strong>优势：</strong></p><ul><li>避免类加载重复</li><li>保护程序安全，防止核心API被篡改</li><li>保证对 Java 核心源代码的保护</li></ul><blockquote><p>在 JVM 中表示两个 class 对象，是否为同一个类存在的两个必要条件：</p><ul><li>类的完整类名必须一致、包括包名</li><li>加载这个类的 ClassLoader 必须相同</li></ul></blockquote><p>JVM 必须知道一个类型是由启动类加载器加载的，还是由用户加载器加载的。<strong>如果是用户类加载器加载的，JVM 会将这个类加载器的一个引用作为类型信息的一部分，保存到方法区中</strong></p><h2 id="四、执行引擎"><a href="#四、执行引擎" class="headerlink" title="四、执行引擎"></a>四、执行引擎</h2><h3 id="1-执行引擎概述"><a href="#1-执行引擎概述" class="headerlink" title="1. 执行引擎概述"></a>1. 执行引擎概述</h3><ul><li>执行引擎是Java虚拟机核心的组成部分之一</li><li>虚拟机的执行引擎由软件自行实现。物理机的执行引擎是操作系统层面上的</li><li>能够执行不被硬件直接支持的指令格式</li><li>工作过程<ol><li>执行引擎在执行过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器</li><li>每执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址</li><li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息</li></ol></li></ul><h3 id="2-Java代码编译和执行过程"><a href="#2-Java代码编译和执行过程" class="headerlink" title="2. Java代码编译和执行过程"></a>2. Java代码编译和执行过程</h3><p>大部分的程序代码转化成物理机的目标代码或者虚拟机能执行的指令集之前，都需要经过以下步骤</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210312155153541.png" alt="image-20210312155153541" style="zoom:50%;" /><blockquote><p>为什么说 Java是半编译半解释型语言</p><ul><li>JVM 在执行Java代码的时候，通常会见将结束执行与编译执行二者结合起来</li></ul></blockquote><h3 id="3-机器码、指令、汇编语言"><a href="#3-机器码、指令、汇编语言" class="headerlink" title="3. 机器码、指令、汇编语言"></a>3. 机器码、指令、汇编语言</h3><h4 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h4><p>各种采用二进制编码方式表示的指令，叫做机器指令码。机器语言。机器指令和CPU紧密相关，不同种类的CPU所对应的机器指令也就不同</p><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><ul><li><h4 id="由于机器码由-01-组成，可读性太差。于是人们发明了指令"><a href="#由于机器码由-01-组成，可读性太差。于是人们发明了指令" class="headerlink" title="由于机器码由 01 组成，可读性太差。于是人们发明了指令"></a>由于机器码由 01 组成，可读性太差。于是人们发明了指令</h4></li><li><p>指令就是把机器码特定的0和1序列化，简化成对应的指令，一般为英文编写如mov、inc等，可读性稍好</p></li><li><p>由于不同的硬件平台，执行同一个操作，对应的机器码也可能不同。所以不同的硬件平台的同一种指令，对应的机器码也可能不同</p></li></ul><h4 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h4><ul><li>不同硬件平台，各种支持的指令是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集</li><li>x86指令集，对应的是x86架构的平台</li><li>ARM指令集，对应的是ARM架构的平台</li></ul><h4 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h4><ul><li>由于指令的可读性太差了，于是又有了汇编语言</li><li>汇编语言用助记符代替机器指令的操作码，用地址符合或标号，代替指令或操作数地址</li><li>汇编语言要翻译成机器指令码，计算机才能识别和执行</li></ul><h4 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h4><ul><li><p>当 Java虚拟机启动时，会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容翻译为赌赢平台的本地机器指令执行</p></li><li><p>解释器真正意义上所承担的角色就是一个运行时翻译器，将字节码文件中的内容翻译为对应的本地机器指令执行</p></li><li><p>当一条字节码指令被解释执行完成后，接着在根据PC寄存器中的记录下一条需要被执行的字节码执行解释执行</p></li><li><p>普遍使用的解释器模板</p><p>模板解释器将每一条字节码和一个模板函数相关联，模板函数直接产生这条字节码执行时的字节码，提高解释器的性能</p></li><li><p>HotSpot中</p><ul><li>Interpreter模块实现了解释器的核心功能</li><li>Code模块用于管理HotSpot在运行时生成的本地机器指令</li></ul></li></ul><h4 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h4><ul><li>就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言</li><li>JVM平台支持一种叫做即使编译的技术，目的时避免解释执行，而是将整个函数体编译成机器码，每次函数执行时，只执行编译后的机器码即可。使执行效率大幅提升</li></ul><blockquote><p>为什么两种方式？</p><ul><li>首先程序启动后，解释器可以马上发挥作用，省去编译时间，立即执行</li><li>编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后执行效率更高</li><li>对于服务端应用，启动时间并非关注重点，但是对于看重启动时间的应用场景，就需要找到一个平衡点</li><li>当 Java虚拟机启动时，解释器可以首先发挥作用，而不是等到即使编译器全部编译完成后再执行，这样可以省去很多不必要的编译时间，随着时间的推移，把越来越多的代码编译成本地代码，获得更高的执行效率</li></ul></blockquote><blockquote><ul><li><p>前端编译器：把 .java 文件转化为 .class文件的过程</p><p>sun 的 Javac</p></li><li><p>后端运行期编译器：把字节码转为机器码的过程</p><p>JIT编译器：hotSpot的C1、C2编译器</p></li><li><p>静态提前编译器：直接把 .java 文件编译成本地代码的过程</p><p>GNU Compiler for the Java（GCJ）</p></li></ul></blockquote>]]></content>
    
    
    <summary type="html">JVM 架构、类加载子系统和执行引擎</summary>
    
    
    
    <category term="Java" scheme="https://fabian4.site/blog/categories/Java/"/>
    
    
    <category term="Java" scheme="https://fabian4.site/blog/tags/Java/"/>
    
    <category term="JVM" scheme="https://fabian4.site/blog/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 8 新特性</title>
    <link href="https://fabian4.site/blog/62781.html"/>
    <id>https://fabian4.site/blog/62781.html</id>
    <published>2021-02-01T16:00:00.000Z</published>
    <updated>2022-08-24T07:47:19.050Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA-8-新特性"><a href="#JAVA-8-新特性" class="headerlink" title="JAVA 8 新特性"></a>JAVA 8 新特性</h1><h2 id="一、Lambda-表达式"><a href="#一、Lambda-表达式" class="headerlink" title="一、Lambda 表达式"></a>一、Lambda 表达式</h2><blockquote><p>Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。</p></blockquote><p>Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。使用 Lambda 表达式可以使代码变的更加简洁紧凑。</p><p><strong>lambda表达式的重要特征:</strong></p><ul><li><strong>可选类型声明：</strong>不需要声明参数类型，编译器可以统一识别参数值。</li><li><strong>可选的参数圆括号：</strong>一个参数无需定义圆括号，但多个参数需要定义圆括号。</li><li><strong>可选的大括号：</strong>如果主体包含了一个语句，就不需要使用大括号。</li><li><strong>可选的返回关键字：</strong>如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 不需要参数,返回值为 5  </span></span><br><span class="line">() -&gt; <span class="number">5</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 2. 接收一个参数(数字类型),返回其2倍的值  </span></span><br><span class="line">x -&gt; <span class="number">2</span> * x  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 3. 接受2个参数(数字),并返回他们的差值  </span></span><br><span class="line">(x, y) -&gt; x – y  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 4. 接收2个int型整数,返回他们的和  </span></span><br><span class="line">(<span class="type">int</span> x, <span class="type">int</span> y) -&gt; x + y  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  </span></span><br><span class="line">(String s) -&gt; System.out.print(s)</span><br></pre></td></tr></table></figure><p>比如在多线程编程中，我们使用Lambda表达式来开启新的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.使用匿名内部类  </span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world !&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;).start();  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 2.使用 lambda 表达式</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;Hello world !&quot;</span>)).start();  </span><br></pre></td></tr></table></figure><ol><li>Lambda表达式可以理解为一种匿名函数：它没有名称，但有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常的列表</li><li>Lambda表达式让你可以简洁地传递代码</li><li>函数式接口就是仅仅声明了一个抽象方法的接口</li><li>只有在接受函数式接口的地方才可以使用Lambda表达式</li><li>Lambda表达式允许你直接内联，为函数式接口的抽象方法提供实现，并且将整个表达式作为函数式接口的一个实例</li></ol><h2 id="二、函数式接口"><a href="#二、函数式接口" class="headerlink" title="二、函数式接口"></a>二、函数式接口</h2><ul><li>只包含一个抽象方法的接口，称为<strong>函数式接口</strong>。</li><li>你可以通过Lambda表达式来创建该接口的对象。（若Lambda表达式抛出一个受检异常，那么该异常需要在目标接口的抽象方法上进行声明）。</li><li>我们可以在任意函数式接口上使用<code>@FunctionalInterface</code>注解，这样做可以检查它是否是一个函数式接口，同时javadoc也会包含一条声明，说明这个接口是一个函数式接口。</li></ul><p>函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。</p><p>函数式接口可以被隐式转换为 lambda 表达式。</p><p>Lambda 表达式和方法引用（实际上也可认为是Lambda表达式）上。</p><p>如定义了一个函数式接口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">GreetingService</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayMessage</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么就可以使用Lambda表达式来表示该接口的一个实现(注：JAVA 8 之前一般是用匿名类实现的)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">GreetingService</span> <span class="variable">greetService1</span> <span class="operator">=</span> message -&gt; System.out.println(<span class="string">&quot;Hello &quot;</span> + message);</span><br></pre></td></tr></table></figure><p><strong>函数式接口可以对现有的函数友好地支持 lambda。</strong></p><p>目前的函数式接口：</p><ul><li>java.lang.Runnable</li><li>java.util.concurrent.Callable</li><li>java.security.PrivilegedAction</li><li>java.util.Comparator</li><li>java.io.FileFilter</li><li>java.nio.file.PathMatcher</li><li>java.lang.reflect.InvocationHandler</li><li>java.beans.PropertyChangeListener</li><li>java.awt.event.ActionListener</li><li>javax.swing.event.ChangeListener</li><li>java.util.function</li></ul><h3 id="四大函数式接口"><a href="#四大函数式接口" class="headerlink" title="四大函数式接口"></a>四大函数式接口</h3><h4 id="1-Consumer-lt-T-gt-消费型接口，void-accept-T-t"><a href="#1-Consumer-lt-T-gt-消费型接口，void-accept-T-t" class="headerlink" title="1. Consumer&lt;T&gt; : 消费型接口，void accept(T t);"></a>1. Consumer&lt;T&gt; : 消费型接口，void accept(T t);</h4><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/pTNkc6lAUCiIVwj.png" alt="image-20210209152805992" style="zoom: 50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; consumer = s -&gt; &#123;</span><br><span class="line">    s = s.toUpperCase();</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;;</span><br><span class="line">consumer.accept(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">// TEST</span></span><br></pre></td></tr></table></figure><h4 id="2-Supplier-lt-T-gt-供给型接口，T-get"><a href="#2-Supplier-lt-T-gt-供给型接口，T-get" class="headerlink" title="2. Supplier&lt;T&gt; : 供给型接口，T get();"></a>2. Supplier&lt;T&gt; : 供给型接口，T get();</h4><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/nwliEdcvCqItV2J.png" alt="image-20210209153222393" style="zoom: 50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;String&gt; supplier = () -&gt; &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(supplier.get());</span><br></pre></td></tr></table></figure><h4 id="3-Function-lt-T-R-gt-函数型接口，R-apply-T-t"><a href="#3-Function-lt-T-R-gt-函数型接口，R-apply-T-t" class="headerlink" title="3. Function&lt;T, R&gt; : 函数型接口，R apply(T t);"></a>3. Function&lt;T, R&gt; : 函数型接口，R apply(T t);</h4><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/fouHtDVOSB19k2E.png" alt="image-20210209153650946" style="zoom: 50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Integer&gt; function = s -&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> s + <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> ++result;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(function.apply(<span class="number">3</span>));</span><br></pre></td></tr></table></figure><h4 id="4-Predicate-lt-T-gt-断言型接口，boolean-test-T-t"><a href="#4-Predicate-lt-T-gt-断言型接口，boolean-test-T-t" class="headerlink" title="4. Predicate&lt;T&gt; : 断言型接口，boolean test(T t);"></a>4. Predicate&lt;T&gt; : 断言型接口，boolean test(T t);</h4><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/8yaiMRhTtqkAQx9.png" alt="image-20210209154226464" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;Integer&gt; predicate = s -&gt; &#123;</span><br><span class="line">    s = s * <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> s &gt; <span class="number">43</span>;</span><br><span class="line">&#125;;</span><br><span class="line">System.out.println(predicate.test(<span class="number">8</span>));</span><br></pre></td></tr></table></figure><h2 id="三、Stream-流"><a href="#三、Stream-流" class="headerlink" title="三、Stream 流"></a>三、Stream 流</h2><blockquote><p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。</p><p>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。</p><p>Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p><p>这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。</p><p>元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。</p></blockquote><p>Stream（流）是一个来自数据源的元素队列并支持聚合操作</p><ul><li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li><li><strong>数据源</strong> 流的来源。 可以是集合，数组，I&#x2F;O channel， 产生器generator 等。</li><li><strong>聚合操作</strong> 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。</li></ul><p>和以前的Collection操作不同， Stream操作还有两个基础的特征：</p><ul><li><strong>Pipelining</strong>: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li><li><strong>内部迭代</strong>： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。</li></ul><h3 id="生成流"><a href="#生成流" class="headerlink" title="生成流"></a>生成流</h3><p>在 Java 8 中, 集合接口有两个方法来生成流：</p><ul><li><strong>stream()</strong> − 为集合创建串行流。</li><li><strong>parallelStream()</strong> − 为集合创建并行流。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;efg&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>Stream 提供了新的方法 ‘forEach’ 来迭代流中的每个数据。以下代码片段使用 forEach 输出了10个随机数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 获取对应的平方数</span></span><br><span class="line">List&lt;Integer&gt; squaresList = numbers.stream().map( i -&gt; i*i).distinct().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>filter 方法用于通过设置的条件过滤出元素。以下代码片段使用 filter 方法过滤出空字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;efg&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line"><span class="comment">// 获取空字符串的数量</span></span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> strings.stream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure><h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p>limit 方法用于获取指定数量的流。 以下代码片段使用 limit 方法打印出 10 条数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><p>sorted 方法用于对流进行排序。以下代码片段使用 sorted 方法对输出的 10 个随机数进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="并行（parallel）程序"><a href="#并行（parallel）程序" class="headerlink" title="并行（parallel）程序"></a>并行（parallel）程序</h3><p>parallelStream 是流并行处理程序的代替方法。以下实例我们使用 parallelStream 来输出空字符串的数量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;efg&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line"><span class="comment">// 获取空字符串的数量</span></span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure><h3 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h3><p>Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors 可用于返回列表或字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;bc&quot;</span>, <span class="string">&quot;efg&quot;</span>, <span class="string">&quot;abcd&quot;</span>,<span class="string">&quot;&quot;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">&quot;筛选列表: &quot;</span> + filtered);</span><br><span class="line"><span class="type">String</span> <span class="variable">mergedString</span> <span class="operator">=</span> strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(<span class="string">&quot;, &quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;合并字符串: &quot;</span> + mergedString);</span><br></pre></td></tr></table></figure><h3 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h3><p>另外，一些产生统计结果的收集器也非常有用。它们主要用于int、double、long等基本类型上，它们可以用来产生类似如下的统计结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line"><span class="type">IntSummaryStatistics</span> <span class="variable">stats</span> <span class="operator">=</span> numbers.stream().mapToInt((x) -&gt; x).summaryStatistics();</span><br><span class="line"> </span><br><span class="line">System.out.println(<span class="string">&quot;列表中最大的数 : &quot;</span> + stats.getMax());</span><br><span class="line">System.out.println(<span class="string">&quot;列表中最小的数 : &quot;</span> + stats.getMin());</span><br><span class="line">System.out.println(<span class="string">&quot;所有数之和 : &quot;</span> + stats.getSum());</span><br><span class="line">System.out.println(<span class="string">&quot;平均数 : &quot;</span> + stats.getAverage());</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">JAVA 8 新特性</summary>
    
    
    
    <category term="Java" scheme="https://fabian4.site/blog/categories/Java/"/>
    
    
    <category term="Java" scheme="https://fabian4.site/blog/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 线程安全集合</title>
    <link href="https://fabian4.site/blog/12941.html"/>
    <id>https://fabian4.site/blog/12941.html</id>
    <published>2021-01-30T16:00:00.000Z</published>
    <updated>2022-08-24T07:47:19.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA-线程安全集合"><a href="#JAVA-线程安全集合" class="headerlink" title="JAVA 线程安全集合"></a>JAVA 线程安全集合</h1><h2 id="一、线程安全"><a href="#一、线程安全" class="headerlink" title="一、线程安全"></a>一、线程安全</h2><ul><li><p>线程安全</p><p>就是当多线程访问时，采用了加锁的机制；即当一个线程访问该类的某个数据时，会对这个数据进行保护，其他线程不能对其访问，直到该线程读取完之后，其他线程才可以使用。防止出现数据不一致或者数据被污染的情况。</p></li><li><p>线程不安全</p><p>就是不提供数据访问时的数据保护，多个线程能够同时操作某个数据，从而出现数据不一致或者数据污染的情况。</p></li><li><p>线程安全 工作原理： </p><p>jvm中有一个main memory对象，每一个线程也有自己的working memory，一个线程对于一个变量variable进行操作的时候， 都需要在自己的working memory里创建一个copy,操作完之后再写入main memory。<br>当多个线程操作同一个变量variable，就可能出现不可预知的结果。<br>而用synchronized的关键是建立一个监控monitor，这个monitor可以是要修改的变量，也可以是其他自己认为合适的对象(方法)，然后通过给这个monitor加锁来实现线程安全，每个线程在获得这个锁之后，要执行完加载load到working memory 到 use &amp;&amp; 指派assign 到 存储store 再到 main memory的过程。才会释放它得到的锁。这样就实现了所谓的线程安全。</p></li></ul><h2 id="二、相关对象集合比较"><a href="#二、相关对象集合比较" class="headerlink" title="二、相关对象集合比较"></a>二、相关对象集合比较</h2><h3 id="Vector、ArrayList、LinkedList"><a href="#Vector、ArrayList、LinkedList" class="headerlink" title="Vector、ArrayList、LinkedList"></a><code>Vector、ArrayList、LinkedList</code></h3><ol><li><strong>Vector</strong> 线程安全<br>Vector与ArrayList一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性，<strong>但实现同步需要很高的花费，因此，访问它比访问ArrayList慢</strong>。 </li><li><strong>ArrayList</strong> <ol><li>当操作是在一列数据的后面添加数据而不是在前面或者中间，并需要随机地访问其中的元素时，使用ArrayList性能比较好</li><li>ArrayList是最常用的List实现类，内部是通过数组实现的，它允许对元素进行快速随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力，就要讲已经有数组的数据复制到新的存储空间中。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。</li></ol></li><li><strong>LinkedList</strong> <ol><li>当对一列数据的前面或者中间执行添加或者删除操作时，并且按照顺序访问其中的元素时，要使用LinkedList。 </li><li>LinkedList是用链表结构存储数据的，很适合数据的动态插入和删除，随机访问和遍历速度比较慢。另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。</li></ol></li></ol><blockquote><p>Vector和ArrayList在使用上非常相似，都可以用来表示一组数量可变的对象应用的集合，并且可以随机的访问其中的元素。</p></blockquote><h3 id="HashTable、HashMap、HashSet"><a href="#HashTable、HashMap、HashSet" class="headerlink" title="HashTable、HashMap、HashSet"></a><code>HashTable、HashMap、HashSet</code></h3><ul><li><strong>HashMap</strong><ol><li>采用数组方式存储key-value构成的Entry对象，无容量限制；</li><li>基于key hash查找Entry对象存放到数组的位置，对于hash冲突采用链表的方式去解决； </li><li>在插入元素时，可能会扩大数组的容量，在扩大容量时须要重新计算hash，并复制对象到新的数组中； </li><li><strong>是非线程安全的</strong>； </li><li>遍历使用的是Iterator迭代器；</li></ol></li><li><strong>HashTable</strong>     线程安全<ol><li><strong>是线程安全的</strong>； </li><li>无论是key还是value都不允许有null值的存在；在HashTable中调用Put方法时，如果key为null，直接抛出NullPointerException异常； </li><li>遍历使用的是Enumeration列举；</li></ol></li><li><strong>HashSet</strong> <ol><li>基于HashMap实现，无容量限制； </li><li><strong>是非线程安全的</strong>； </li><li>不保证数据的有序；</li></ol></li></ul><h3 id="TreeSet、TreeMap"><a href="#TreeSet、TreeMap" class="headerlink" title="TreeSet、TreeMap"></a><code>TreeSet、TreeMap</code></h3><p>TreeSet和TreeMap都是完全基于Map来实现的，并且都不支持get(index)来获取指定位置的元素，需要遍历来获取。另外，TreeSet还提供了一些排序方面的支持，例如传入Comparator实现、descendingSet以及descendingIterator等。 </p><ul><li><strong>TreeSet</strong><ol><li>基于TreeMap实现的，支持排序； </li><li><strong>是非线程安全的</strong>；</li></ol></li><li><strong>TreeMap</strong> <ol><li>典型的基于红黑树的Map实现，因此它要求一定要有key比较的方法，要么传入Comparator比较器实现，要么key对象实现Comparator接口； </li><li><strong>是非线程安全的</strong>；</li></ol></li></ul><h3 id="StringBuffer、StringBulider"><a href="#StringBuffer、StringBulider" class="headerlink" title="StringBuffer、StringBulider"></a><code>StringBuffer、StringBulider</code></h3><p>StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串。</p><p>　　 1、在执行速度方面的比较：StringBuilder &gt; StringBuffer ；<br>　　 2、他们都是字符串变量，是可改变的对象，每当我们用它们对字符串做操作时，实际上是在一个对象上操作的，不像String一样创建一些对象进行操作，所以速度快；<br>　 　3、<strong>StringBuilder：线程非安全的</strong>；<br>　　 4、<strong>StringBuffer：线程安全的</strong>； </p><blockquote><p>　<strong>对于String、StringBuffer和StringBulider三者使用的总结：</strong><br>　　 1.如果要操作少量的数据用 &#x3D; String<br>　 　2.单线程操作字符串缓冲区 下操作大量数据 &#x3D; StringBuilder<br>　　 3.多线程操作字符串缓冲区 下操作大量数据 &#x3D; StringBuffer</p></blockquote><h2 id="三、JUC-包下的三个数据集合"><a href="#三、JUC-包下的三个数据集合" class="headerlink" title="三、JUC 包下的三个数据集合"></a>三、JUC 包下的三个数据集合</h2><h3 id="ConcurrentHashMap-lt-K-V-gt"><a href="#ConcurrentHashMap-lt-K-V-gt" class="headerlink" title="ConcurrentHashMap&lt;K,V&gt;"></a><code>ConcurrentHashMap&lt;K,V&gt;</code></h3><p><strong>为什么要使用ConcurrentHashMap</strong></p><ol><li>在多线程环境下，使用HashMap，有可能会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环。</li><li>虽然可以使用HashTable来应对多线程环境，但是当线程访问HashTable同步方法时，其他线程将进入阻塞或者轮询，所以HashTable的效率十分低下。并且HashTable已经慢慢被淘汰了。</li><li>所有访问HashTable的线程都必须竞争同一把锁来获得访问HashTable的权利，但是ConcurrentHashMap使用分段锁技术，将所有数据分段，每段数据配备一把锁，那么当一段数据的锁被获得的时候，其他段的数据依然能够被访问，有效的提高了并发的效率。</li></ol><h3 id="CopyOnWriteArrayList-lt-E-gt-和-CopyOnWriteArraySet-lt-E-gt"><a href="#CopyOnWriteArrayList-lt-E-gt-和-CopyOnWriteArraySet-lt-E-gt" class="headerlink" title="CopyOnWriteArrayList&lt;E&gt; 和  CopyOnWriteArraySet&lt;E&gt;"></a><code>CopyOnWriteArrayList&lt;E&gt;</code> 和  <code>CopyOnWriteArraySet&lt;E&gt;</code></h3><p>一个Set使用内部CopyOnWriteArrayList其所有操作。 因此，它具有相同的基本属性：</p><ul><li>它最适合于集合大小通常保持较小，只读操作大大超过突变操作的应用程序，并且您需要防止遍历期间线程之间的干扰。</li><li>它是线程安全的。</li><li>可变操作（ add ， set ， remove ，等）是昂贵的，因为它们通常意味着复制整个底层数组。</li><li>迭代器不支持突变remove操作。</li><li>遍历遍历迭代器是快速的，不能遇到来自其他线程的干扰。 迭代器构建时迭代器依赖于数组的不变快照。</li></ul><h2 id="四、阻塞队列-BlockingQueue"><a href="#四、阻塞队列-BlockingQueue" class="headerlink" title="四、阻塞队列 BlockingQueue"></a>四、阻塞队列 BlockingQueue</h2><p><strong>一个线程往里边放，另外一个线程从里边取的一个 BlockingQueue。</strong></p><ul><li>一个线程将会持续生产新对象并将其插入到队列之中，直到队列达到它所能容纳的临界点。也就是说，它是有限的。如果该阻塞队列到达了其临界点，负责生产的线程将会在往里边插入新对象时发生阻塞。它会一直处于阻塞之中，直到负责消费的线程从队列中拿走一个对象。</li><li>负责消费的线程将会一直从该阻塞队列中拿出对象。如果消费线程尝试去从一个空的队列中提取对象的话，这个消费线程将会处于阻塞之中，直到一个生产线程把一个对象丢进队列。</li></ul><p><strong>BlockingQueue 的方法</strong></p><p>BlockingQueue 具有 4 组不同的方法用于插入、移除以及对队列中的元素进行检查。如果请求的操作不能得到立即执行的话，每个方法的表现也不同。这些方法如下：</p><table><thead><tr><th align="left"></th><th align="left">抛异常</th><th align="left">特定值</th><th align="left">阻塞</th><th align="left">超时</th></tr></thead><tbody><tr><td align="left">插入</td><td align="left">add(o)</td><td align="left">offer(o)</td><td align="left">put(o)</td><td align="left">offer(o, timeout, timeunit)</td></tr><tr><td align="left">移除</td><td align="left">remove(o)</td><td align="left">poll(o)</td><td align="left">take(o)</td><td align="left">poll(timeout, timeunit)</td></tr><tr><td align="left">检查</td><td align="left">element(o)</td><td align="left">peek(o)</td><td align="left"></td><td align="left"></td></tr></tbody></table><p>四组不同的行为方式解释：</p><ol><li><strong>抛异常</strong>：如果试图的操作无法立即执行，抛一个异常。</li><li><strong>特定值</strong>：如果试图的操作无法立即执行，返回一个特定的值(常常是 true &#x2F; false)。</li><li><strong>阻塞</strong>：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。</li><li><strong>超时</strong>：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是 true &#x2F; false)。</li></ol><blockquote><p>无法向一个 BlockingQueue 中插入 null。如果你试图插入 null，BlockingQueue 将会抛出一个 NullPointerException。</p></blockquote><p>可以访问到 BlockingQueue 中的所有元素，而不仅仅是开始和结束的元素。比如说，你将一个对象放入队列之中以等待处理，但你的应用想要将其取消掉。那么你可以调用诸如 remove(o) 方法来将队列之中的特定对象进行移除。但是这么干效率并不高(译者注：基于队列的数据结构，获取除开始或结束位置的其他对象的效率不会太高)，因此你尽量不要用这一类的方法，除非你确实不得不那么做。</p>]]></content>
    
    
    <summary type="html">JAVA 线程安全集合</summary>
    
    
    
    <category term="Java" scheme="https://fabian4.site/blog/categories/Java/"/>
    
    
    <category term="Java" scheme="https://fabian4.site/blog/tags/Java/"/>
    
    <category term="多线程" scheme="https://fabian4.site/blog/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 并发相关</title>
    <link href="https://fabian4.site/blog/43332.html"/>
    <id>https://fabian4.site/blog/43332.html</id>
    <published>2021-01-28T16:00:00.000Z</published>
    <updated>2022-08-24T07:47:19.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA-并发相关"><a href="#JAVA-并发相关" class="headerlink" title="JAVA 并发相关"></a>JAVA 并发相关</h1><h2 id="一、乐观锁和悲观锁"><a href="#一、乐观锁和悲观锁" class="headerlink" title="一、乐观锁和悲观锁"></a>一、乐观锁和悲观锁</h2><ul><li><p>悲观锁：</p><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。</p><blockquote><p>传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。</p></blockquote></li><li><p>乐观锁：</p><p>顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。</p><blockquote><p>乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p></blockquote></li></ul><p>Java在JDK1.5之前都是靠 synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有共享变量的锁，都采用独占的方式来访问这些变量。这就是一种独占锁，独占锁其实就是一种悲观锁，所以可以说 <strong>synchronized 是悲观锁。</strong></p><p>悲观锁机制存在以下问题：　　</p><ol><li>在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。</li><li>一个线程持有锁会导致其它所有需要此锁的线程挂起。</li><li>如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。</li></ol><p><strong>对比于悲观锁的这些问题，另一个更加有效的锁就是乐观锁。其实乐观锁就是：每次不加锁而是假设没有并发冲突而去完成某项操作，如果因为并发冲突失败就重试，直到成功为止。</strong></p><h2 id="二、java-util-concurrent-atomic"><a href="#二、java-util-concurrent-atomic" class="headerlink" title="二、java.util.concurrent.atomic"></a>二、<code>java.util.concurrent.atomic</code></h2><p>在我们 JUC 包下面有个 <code>atomic</code> 中的一些类可以确保我们的<strong>原子操作</strong></p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/NzgiAur2FWCc5Rk.png" alt="image-20210205143737342"></p><p>我们可以通过以下程序对其进行一个简单的测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger atomicInteger= <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;  ============================== &quot;</span>+atomicInteger.incrementAndGet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">AtomicDemo</span> <span class="variable">atomicDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicDemo</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(atomicDemo::add).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/Kw5EbiUZJ3LC4n7.png" alt="image-20210205144251148" style="zoom: 50%;" /><h2 id="三、乐观锁的实现：CAS"><a href="#三、乐观锁的实现：CAS" class="headerlink" title="三、乐观锁的实现：CAS"></a>三、乐观锁的实现：CAS</h2><blockquote><p>上面提到的乐观锁的概念中其实已经阐述了它的具体实现细节：主要就是两个步骤：<strong>冲突检测和数据更新。</strong></p></blockquote><p>CAS（Compare and swap）比较和替换是设计并发算法时用到的一种技术。简单来说，比较和替换是使用一个期望值和一个变量的当前值进行比较，如果当前变量的值与我们期望的值相等，就使用一个新值替换当前变量的值。</p><p>而 <code>atomic</code> 包中也为我们提供了相应的方法</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/Urd59WG4MBCmJPZ.png" alt="image-20210205150723972"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">atomicInteger.compareAndSet(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">atomicInteger.weakCompareAndSet(<span class="number">0</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="四、ABA问题"><a href="#四、ABA问题" class="headerlink" title="四、ABA问题"></a>四、ABA问题</h2><p>线程1准备用CAS将变量的值由A替换为C，在此之前，线程2将变量的值由A替换为B，又由B替换为A，然后线程1执行CAS时发现变量的值仍然为A，所以CAS成功。但实际上这时的现场已经和最初不同了，尽管CAS成功，但可能存在潜藏的问题。</p><p><strong>ABA问题的根本在于在修改变量的时候，无法记录变量的状态，比如修改的次数，是否修改过这个变量。这样就很容易在一个线程将A修改成B时，另一个线程又会把B修改成A，造成多次执行的问题。</strong></p><p><strong>解决方法</strong>：</p><p>Java并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/ZJQhsumCXdVqlge.png" alt="image-20210205153138400"></p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/STjrQE8zvo9WLyP.png" alt="image-20210205153155828"></p><h2 id="五、JNI-和-native-关键字"><a href="#五、JNI-和-native-关键字" class="headerlink" title="五、JNI  和 native 关键字"></a>五、JNI  和 native 关键字</h2><blockquote><p>JNI是Java Native Interface的缩写，通过使用 Java本地接口书写程序，可以确保代码在不同的平台上方便移植。 从Java1.1开始，JNI标准成为java平台的一部分，它允许Java代码和其他语言写的代码进行交互。JNI一开始是为了本地已编译语言，尤其是C和C++而设计的，但是它并不妨碍你使用其他编程语言，只要调用约定受支持就可以了。使用java与本地已编译的代码交互，通常会丧失平台可移植性。但是，有些情况下这样做是可以接受的，甚至是必须的。例如，使用一些旧的库，与硬件、操作系统进行交互，或者为了提高程序的性能。JNI标准至少要保证本地代码能工作在任何Java 虚拟机环境。</p></blockquote><p>原因是Java很好，使用的人很多、应用极广，但是Java不是完美的。Java的不足体现在运行速度要比传统的C++慢上许多之外，还有Java无法直接访问到操作系统底层如硬件系统。为此Java提供了JNI来实现对于底层的访问。JNI，Java Native Interface，它是Java的SDK一部分，JNI允许Java代码使用以其他语言编写的代码和代码库，本地程序中的函数也可以调用Java层的函数，即JNI实现了Java和本地代码间的双向交互。</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/xMbgpu6ZLFQw379.png" alt="image-20210205154317174" style="zoom:50%;" /><h3 id="JAVA-调用-C-流程"><a href="#JAVA-调用-C-流程" class="headerlink" title="JAVA 调用 C 流程"></a>JAVA 调用 C 流程</h3><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/hJ2FqxpzMUaTPWv.png" alt="image-20210205154418616" style="zoom: 50%;" /><h3 id="native-关键字"><a href="#native-关键字" class="headerlink" title="native 关键字"></a>native 关键字</h3><blockquote><p><strong>java语言是运行在虚拟机上的，java又是不允许直接访问硬件的（也就是java安全性的体现），而java想要做一些例如绘图、画线之类的要去操作硬件的事情的话，必然要用到底层一些的调用。这就引出了native的关键字。</strong></p></blockquote><p><strong>native关键字说明其修饰的方法是一个原生态方法，方法对应的实现不是在当前文件，而是在用其他语言（如C和C++）实现的文件中。Java语言本身不能对操作系统底层进行访问和操作，但是可以通过JNI接口调用其他语言来实现对底层的访问。</strong></p><p>如在 java.lang.Object 源码中的一个hashCode方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>; </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">JAVA 并发相关</summary>
    
    
    
    <category term="Java" scheme="https://fabian4.site/blog/categories/Java/"/>
    
    
    <category term="Java" scheme="https://fabian4.site/blog/tags/Java/"/>
    
    <category term="多线程" scheme="https://fabian4.site/blog/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 线程并发和安全</title>
    <link href="https://fabian4.site/blog/8531.html"/>
    <id>https://fabian4.site/blog/8531.html</id>
    <published>2021-01-26T16:00:00.000Z</published>
    <updated>2022-08-24T07:47:19.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA-线程并发和安全"><a href="#JAVA-线程并发和安全" class="headerlink" title="JAVA 线程并发和安全"></a>JAVA 线程并发和安全</h1><h2 id="一、线程不安全"><a href="#一、线程不安全" class="headerlink" title="一、线程不安全"></a>一、线程不安全</h2><p>先来看一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span>&#123;</span><br><span class="line">        num++;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot; ============&gt; &quot;</span>+ num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">3000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(test::increase, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们开启 3000 条线程去对同一个变量进行 +1 操作，结果如下</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/dT7e1oE93MGmzHD.png" alt="image-20210204153911927" style="zoom:50%;" /><p>很明显不是我们预期的结果</p><h2 id="二、JMM-模型"><a href="#二、JMM-模型" class="headerlink" title="二、JMM 模型"></a>二、JMM 模型</h2><p>JMM（Java Memory Model，简称JMM）定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读&#x2F;写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/Qzb3oR4HLWO6BfJ.png" alt="image-20210204161732338" style="zoom:50%;" /><h3 id="内存交互操作"><a href="#内存交互操作" class="headerlink" title="内存交互操作"></a>内存交互操作</h3><p>　<strong>内存交互操作有8种，虚拟机实现必须保证每一个操作都是原子的，不可在分的</strong></p><blockquote><p>（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许例外）</p></blockquote><ul><li>lock   （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态</li><li>unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li><li>read  （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用</li><li>load   （载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中</li><li>use   （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令</li><li>assign （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中</li><li>store  （存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用</li><li>write 　（写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中</li></ul><p>　　<strong>JMM对这八种指令的使用，制定了如下规则：</strong></p><ul><li>不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write</li><li>不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存</li><li>不允许一个线程将没有assign的数据从工作内存同步回主内存</li><li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作</li><li>一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁</li><li>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值</li><li>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量</li><li>对一个变量进行unlock操作之前，必须把此变量同步回主内存</li></ul><h3 id="可见性、原子性和有序性。"><a href="#可见性、原子性和有序性。" class="headerlink" title="可见性、原子性和有序性。"></a>可见性、原子性和有序性。</h3><p><strong>可见性：</strong></p><p>　　可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。</p><p>　　<strong>可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。</strong>也就是一个线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a &#x3D; 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。</p><blockquote><p>在 Java 中 volatile、synchronized 和 final 实现可见性。</p></blockquote><p><strong>原子性：</strong></p><p>　　<strong>原子是世界上的最小单位，具有不可分割性。</strong>比如 a&#x3D;0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作时原子操作。再比如：a++； 这个操作实际是a &#x3D; a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如：AtomicInteger、AtomicLong、AtomicReference等。</p><blockquote><p>在 Java 中 synchronized 和在 lock、unlock 中操作保证原子性。</p></blockquote><p><strong>有序性：</strong></p><p>　　Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行</p><h2 id="三、volatile-关键字"><a href="#三、volatile-关键字" class="headerlink" title="三、volatile 关键字"></a>三、volatile 关键字</h2><p>Java语言提供了一种<strong>稍弱</strong>的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。</p><p>在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，<strong>因此volatile变量是一种比sychronized关键字更轻量级的同步机制。</strong></p><blockquote><p>当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。</p></blockquote><p><strong>当一个变量定义为 volatile 之后，将具备两种特性：</strong></p><ol><li>保证此变量对所有的线程的可见性，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存来完成。</li><li>禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个<strong>内存屏障</strong>（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。</li></ol><p><strong>volatile 性能：</strong></p><p>　　volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。</p><p>volatile保证了<strong>可见性，有序性，不保证原子性</strong></p><h2 id="四、synchronized-使用"><a href="#四、synchronized-使用" class="headerlink" title="四、synchronized 使用"></a>四、synchronized 使用</h2><ol><li>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，**作用的对象是调用这个代码块的对象； **</li><li>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，<strong>作用的对象是调用这个方法的对象；</strong> </li><li>修改一个静态的方法，其作用的范围是整个静态方法，<strong>作用的对象是这个类的所有对象；</strong></li><li>修改一个类，其作用的范围是synchronized后面括号括起来的部分，<strong>作用主的对象是这个类的所有对象。</strong></li></ol><p>对于一开始的例子我们这样就可以保证线程安全了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修饰方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span>&#123;</span><br><span class="line">    num++;</span><br><span class="line">    System.out.println(<span class="string">&quot;当前线程：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot; ============&gt; &quot;</span>+ num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修饰代码块</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 锁住调用的对象</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">        num++;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot; ============&gt; &quot;</span>+ num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、可重入锁-ReentrantLock-的使用"><a href="#五、可重入锁-ReentrantLock-的使用" class="headerlink" title="五、可重入锁 ReentrantLock 的使用"></a>五、可重入锁 ReentrantLock 的使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 先获得锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        num++;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前线程：&quot;</span>+Thread.currentThread().getName()+<span class="string">&quot; ============&gt; &quot;</span>+ num);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 不要忘记释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、ReentrantLock-和-synchronized-的区别"><a href="#六、ReentrantLock-和-synchronized-的区别" class="headerlink" title="六、ReentrantLock 和 synchronized 的区别"></a>六、ReentrantLock 和 synchronized 的区别</h2><ul><li>对于Synchronized来说，它是java语言的关键字，是原生语法层面的互斥，需要jvm实现。而ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配合try&#x2F;finally语句块来完成</li><li>synchronized同步，假如发生异常，JVM是可以帮我们自动释放锁的，但是lock不可以，<strong>我们只能手动释放锁，即使发生异常，jvm也不会自动释放锁</strong>。</li><li>synchronized与wait()和notify()&#x2F;notifyAll()方法结合可以实现等待通知模式，Reentrantlock可以实现同样的效果，<strong>在synchronized当中，被通知的线程是由JVM随机选择，但是lock结合condition可以实现选择性通知。</strong></li></ul><h2 id="七、死锁"><a href="#七、死锁" class="headerlink" title="七、死锁"></a>七、死锁</h2><h3 id="1-产生死锁的原因"><a href="#1-产生死锁的原因" class="headerlink" title="1. 产生死锁的原因"></a>1. 产生死锁的原因</h3><ul><li><p>竞争资源</p><ul><li>系统中的资源可以分为两类：<ol><li>可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；</li><li>另一类资源是不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。</li></ol></li><li>产生死锁中的竞争资源之一指的是竞争不可剥夺资源（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）</li></ul></li><li><p>产生死锁中的竞争资源另外一种资源指的是竞争临时资源（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁</p></li><li><p>进程间推进顺序非法</p><ul><li>若P1保持了资源R1,P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁</li><li>例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁</li></ul></li></ul><h3 id="2-产生死锁的必要条件"><a href="#2-产生死锁的必要条件" class="headerlink" title="2. 产生死锁的必要条件"></a>2. 产生死锁的必要条件</h3><ol><li><strong>互斥条件</strong>：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</li><li><strong>请求和保持条件</strong>：当进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li><strong>不剥夺条件</strong>：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</li><li><strong>环路等待条件</strong>：在发生死锁时，必然存在一个进程–资源的环形链。</li></ol><h3 id="3-预防死锁"><a href="#3-预防死锁" class="headerlink" title="3. 预防死锁"></a>3. 预防死锁</h3><ul><li>资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）</li><li>只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏请保持条件）</li><li>可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</li><li>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</li></ul><ol><li>以一定的顺序获得锁</li><li>超时放弃</li></ol><h3 id="4-死锁检测"><a href="#4-死锁检测" class="headerlink" title="4. 死锁检测"></a>4. 死锁检测</h3><ol><li><p><strong>Jstack命令</strong></p><p>jstack是java虚拟机自带的一种堆栈跟踪工具。jstack用于打印出给定的java进程ID或core file或远程调试服务的Java堆栈信息。 Jstack工具可以用于生成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。 线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。</p></li><li><p><strong>JConsole工具</strong></p><p>Jconsole是JDK自带的监控工具，在JDK&#x2F;bin目录下可以找到。它用于连接正在运行的本地或者远程的JVM，对运行在Java应用程序的资源消耗和性能进行监控，并画出大量的图表，提供强大的可视化界面。而且本身占用的服务器内存很小，甚至可以说几乎不消耗。</p></li></ol>]]></content>
    
    
    <summary type="html">JAVA 线程并发和安全</summary>
    
    
    
    <category term="Java" scheme="https://fabian4.site/blog/categories/Java/"/>
    
    
    <category term="Java" scheme="https://fabian4.site/blog/tags/Java/"/>
    
    <category term="多线程" scheme="https://fabian4.site/blog/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JAVA 多线程编程</title>
    <link href="https://fabian4.site/blog/6499.html"/>
    <id>https://fabian4.site/blog/6499.html</id>
    <published>2021-01-24T16:00:00.000Z</published>
    <updated>2022-08-24T07:47:19.050Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA-多线程编程"><a href="#JAVA-多线程编程" class="headerlink" title="JAVA 多线程编程"></a>JAVA 多线程编程</h1><h2 id="一、线程和进程"><a href="#一、线程和进程" class="headerlink" title="一、线程和进程"></a>一、线程和进程</h2><p><strong>进程</strong>：是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。</p><p><strong>线程</strong>：是进程的一个执行路径，一个进程中至少有一个线程，进程中的多个线程共享进程的 资源。</p><p>虽然系统是把资源分给进程，但是CPU很特殊，是被分配到线程的，所以线程是CPU分配的基本单位。</p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/145NoOFLkjP3RVU.png" alt="image-20210202170351505" style="zoom:50%;" /><h3 id="二者联系"><a href="#二者联系" class="headerlink" title="二者联系"></a>二者联系</h3><p>一个进程中有多个线程，多个线程共享进程的堆和方法区资源，但是每个线程有自己的程序计数器和栈区域。</p><p> <strong>程序计数器</strong>：是一块内存区域，用来记录线程当前要执行的指令地址 。</p><p><strong>栈</strong>：用于存储该线程的局部变量，这些局部变量是该线程私有的，除此之外还用来存放线程的调用栈祯。</p><p><strong>堆</strong>：是一个进程中最大的一块内存，堆是被进程中的所有线程共享的。</p><p><strong>方法区</strong>：则用来存放 NM 加载的类、常量及静态变量等信息，也是线程共享的 。</p><h3 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h3><p><strong>进程</strong>：有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响。</p><p><strong>线程</strong>：是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉。</p><ul><li>简而言之,一个程序至少有一个进程,一个进程至少有一个线程。</li><li>线程的划分尺度小于进程，使得多线程程序的并发性高。</li><li>另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</li><li>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</li><li>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别</li></ul><h2 id="二、创建线程的四种方式"><a href="#二、创建线程的四种方式" class="headerlink" title="二、创建线程的四种方式"></a>二、创建线程的四种方式</h2><h3 id="1-继承-Thread-类"><a href="#1-继承-Thread-类" class="headerlink" title="1. 继承 Thread 类"></a>1. 继承 Thread 类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Thread &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; =================================&gt; &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ThreadDemo</span> <span class="variable">threadDemo1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadDemo</span>();</span><br><span class="line">        <span class="type">ThreadDemo</span> <span class="variable">threadDemo2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadDemo</span>();</span><br><span class="line">        <span class="type">ThreadDemo</span> <span class="variable">threadDemo3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadDemo</span>();</span><br><span class="line">        <span class="comment">// 这里是调用 start()方法而不是run()！！！！</span></span><br><span class="line">        threadDemo1.start();</span><br><span class="line">        threadDemo2.start();</span><br><span class="line">        threadDemo3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/xlXQuYndBgPa3oq.png" alt="image-20210204130244903" style="zoom: 50%;" /><h3 id="2-实现-runnable-接口"><a href="#2-实现-runnable-接口" class="headerlink" title="2. 实现 runnable 接口"></a>2. 实现 runnable 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableDemo</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; =================================&gt; &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RunnableDemo</span> <span class="variable">runnableDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableDemo</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(runnableDemo, <span class="string">&quot;a&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(runnableDemo, <span class="string">&quot;b&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(runnableDemo, <span class="string">&quot;c&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里也可以直接使用 lambda 表达式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ====&gt; &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;a&quot;</span>).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ===========&gt; &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;b&quot;</span>).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; ======================&gt; &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;c&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-实现-callable-接口"><a href="#3-实现-callable-接口" class="headerlink" title="3. 实现 callable 接口"></a>3. 实现 callable 接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CallableDemo</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CallableDemo</span> <span class="variable">callableDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CallableDemo</span>();</span><br><span class="line">        FutureTask&lt;String&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(callableDemo);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;a&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;b&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;c&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-线程池"><a href="#4-线程池" class="headerlink" title="4. 线程池"></a>4. 线程池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、线程池的创建"><a href="#三、线程池的创建" class="headerlink" title="三、线程池的创建"></a>三、线程池的创建</h2><h3 id="1-线程池七大参数"><a href="#1-线程池七大参数" class="headerlink" title="1. 线程池七大参数"></a>1. 线程池七大参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, // 核心线程池大小</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize, // 核心线程池大小</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime, // 存活时间</span></span><br><span class="line"><span class="params">                          TimeUnit unit, // 时间单位</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue, // 阻塞队列</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory, // 线程工厂</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler // 拒绝策略)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="built_in">this</span>.acc = System.getSecurityManager() == <span class="literal">null</span> ?</span><br><span class="line">                <span class="literal">null</span> :</span><br><span class="line">                AccessController.getContext();</span><br><span class="line">        <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="built_in">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>根据阿里巴巴的Java开发手册</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/jYWKO69hpPEF8tS.png" alt="image-20210204143107656"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> Executors.newSingleThreadExecutor(); </span><br><span class="line"><span class="comment">// 创建单个的线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 创建固定线程量的线程池</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">LinkedBlockingQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> Executors.newCachedThreadPool();</span><br><span class="line"><span class="comment">// 创建可伸缩的线程池</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>以上三种创建方法都默认参数填入了最大值，可能会堆积大量的请求，创建大量的线程，从而导致 OOM。</strong></p><p>我们应该指定参数进行创建</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ThreadPoolExecutor</span> <span class="variable">threadPoolExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    <span class="number">5</span>,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    TimeUnit.MINUTES,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="number">3</span>),</span><br><span class="line">    Executors.defaultThreadFactory(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="2-四种拒绝策略"><a href="#2-四种拒绝策略" class="headerlink" title="2. 四种拒绝策略"></a>2. 四种拒绝策略</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor.AbortPolicy(); </span><br><span class="line"><span class="comment">// 丢弃任务并抛出RejectedExecutionException异常。</span></span><br><span class="line"></span><br><span class="line">ThreadPoolExecutor.CallerRunsPolicy(); </span><br><span class="line"><span class="comment">// 丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃。</span></span><br><span class="line"></span><br><span class="line">ThreadPoolExecutor.DiscardOldestPolicy();</span><br><span class="line"><span class="comment">// 丢弃队列最前面的任务，然后重新提交被拒绝的任务。</span></span><br><span class="line"></span><br><span class="line">ThreadPoolExecutor.DiscardPolicy();</span><br><span class="line"><span class="comment">// 由调用线程处理该任务</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">JAVA 多线程编程</summary>
    
    
    
    <category term="Java" scheme="https://fabian4.site/blog/categories/Java/"/>
    
    
    <category term="Java" scheme="https://fabian4.site/blog/tags/Java/"/>
    
    <category term="多线程" scheme="https://fabian4.site/blog/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>概说JAVA 23种设计模式</title>
    <link href="https://fabian4.site/blog/57913.html"/>
    <id>https://fabian4.site/blog/57913.html</id>
    <published>2021-01-21T16:00:00.000Z</published>
    <updated>2022-08-24T07:47:19.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概说JAVA-23种设计模式"><a href="#概说JAVA-23种设计模式" class="headerlink" title="概说JAVA 23种设计模式"></a>概说JAVA 23种设计模式</h1><h2 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1. 单例模式"></a>1. 单例模式</h2><p>单例模式，它的定义就是确保某一个类只有一个实例，并且提供一个全局访问点。</p><p>单例模式具备典型的3个特点：1、只有一个实例。 2、自我实例化。 3、提供全局访问点。</p><p> 因此当系统中只需要一个实例对象或者系统中只允许一个公共访问点，除了这个公共访问点外，不能通过其他访问点访问该实例时，可以使用单例模式。</p><p>单例模式的主要优点就是节约系统资源、提高了系统效率，同时也能够严格控制客户对它的访问。也许就是因为系统中只有一个实例，这样就导致了单例类的职责过重，违背了“单一职责原则”，同时也没有抽象类，所以扩展起来有一定的困难。其UML结构图非常简单，就只有一个类，如下图：</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/pS2sNtHGxhKLd1q.png" alt="20210129131657.png"></p><h2 id="2-工厂方法模式"><a href="#2-工厂方法模式" class="headerlink" title="2. 工厂方法模式"></a>2. 工厂方法模式</h2><p>作为抽象工厂模式的孪生兄弟，工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，也就是说工厂方法模式让实例化推迟到子类。</p><p>工厂方法模式非常符合“开闭原则”，当需要增加一个新的产品时，我们只需要增加一个具体的产品类和与之对应的具体工厂即可，无须修改原有系统。同时在工厂方法模式中用户只需要知道生产产品的具体工厂即可，无须关系产品的创建过程，甚至连具体的产品类名称都不需要知道。虽然他很好的符合了“开闭原则”，但是由于每新增一个新产品时就需要增加两个类，这样势必会导致系统的复杂度增加。其UML结构图：</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/N4y5rpdHq8G9tKb.png" alt="img"></p><h2 id="3-抽象工厂模式"><a href="#3-抽象工厂模式" class="headerlink" title="3. 抽象工厂模式"></a>3. 抽象工厂模式</h2><p>所谓抽象工厂模式就是提供一个接口，用于创建相关或者依赖对象的家族，而不需要明确指定具体类。他允许客户端使用抽象的接口来创建一组相关的产品，而不需要关系实际产出的具体产品是什么。这样一来，客户就可以从具体的产品中被解耦。它的优点是隔离了具体类的生成，使得客户端不需要知道什么被创建了，而缺点就在于新增新的行为会比较麻烦，因为当添加一个新的产品对象时，需要更加需要更改接口及其下所有子类。其UML结构图如下：</p><p> <img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/z9Uy1SIrZcE2kFp.png" alt="img"></p><h2 id="4-建造者模式"><a href="#4-建造者模式" class="headerlink" title="4. 建造者模式"></a>4. 建造者模式</h2><p>对于建造者模式而已，它主要是将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。适用于那些产品对象的内部结构比较复杂。</p><p>建造者模式将复杂产品的构建过程封装分解在不同的方法中，使得创建过程非常清晰，能够让我们更加精确的控制复杂产品对象的创建过程，同时它隔离了复杂产品对象的创建和使用，使得相同的创建过程能够创建不同的产品。但是如果某个产品的内部结构过于复杂，将会导致整个系统变得非常庞大，不利于控制，同时若几个产品之间存在较大的差异，则不适用建造者模式，毕竟这个世界上存在相同点大的两个产品并不是很多，所以它的使用范围有限。其UML结构图：</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/KMjEemhxvs9T5zc.png" alt="img"></p><h2 id="5-原型模式"><a href="#5-原型模式" class="headerlink" title="5. 原型模式"></a>5. 原型模式</h2><p>在我们应用程序可能有某些对象的结构比较复杂，但是我们又需要频繁的使用它们，如果这个时候我们来不断的新建这个对象势必会大大损耗系统内存的，这个时候我们需要使用原型模式来对这个结构复杂又要频繁使用的对象进行克隆。所以原型模式就是用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。</p><p>它主要应用与那些创建新对象的成本过大时。它的主要优点就是简化了新对象的创建过程，提高了效率，同时原型模式提供了简化的创建结构。UML结构图：</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/mxCHL9SRQauJz5w.png" alt="img"></p><p>原型模式包含如下角色：</p><ul><li>Prototype：抽象原型类</li><li>ConcretePrototype：具体原型类</li><li>Client：客户类</li></ul><h2 id="6-适配器模式"><a href="#6-适配器模式" class="headerlink" title="6. 适配器模式"></a>6. 适配器模式</h2><p>在我们的应用程序中我们可能需要将两个不同接口的类来进行通信，在不修改这两个的前提下我们可能会需要某个中间件来完成这个衔接的过程。这个中间件就是适配器。所谓适配器模式就是将一个类的接口，转换成客户期望的另一个接口。它可以让原本两个不兼容的接口能够无缝完成对接。</p><p>作为中间件的适配器将目标类和适配者解耦，增加了类的透明性和可复用性。</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/tC5uhdRrWYgev4z.png" alt="img"></p><p>适配器模式包含如下角色：</p><ul><li>Target：目标抽象类</li><li>Adapter：适配器类</li><li>Adaptee：适配者类</li><li>Client：客户类</li></ul><h2 id="7-桥接模式"><a href="#7-桥接模式" class="headerlink" title="7. 桥接模式"></a>7. 桥接模式</h2><p>如果说某个系统能够从多个角度来进行分类，且每一种分类都可能会变化，那么我们需要做的就是讲这多个角度分离出来，使得他们能独立变化，减少他们之间的耦合，这个分离过程就使用了桥接模式。所谓桥接模式就是讲抽象部分和实现部分隔离开来，使得他们能够独立变化。</p><p>桥接模式将继承关系转化成关联关系，封装了变化，完成了解耦，减少了系统中类的数量，也减少了代码量。</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/6fGrVPDn2gYEkyo.png" alt="img"></p><p>桥接模式包含如下角色：</p><ul><li>Abstraction：抽象类</li><li>RefinedAbstraction：扩充抽象类</li><li>Implementor：实现类接口</li><li>ConcreteImplementor：具体实现类</li></ul><h2 id="8-组合模式"><a href="#8-组合模式" class="headerlink" title="8. 组合模式"></a>8. 组合模式</h2><p>组合模式组合多个对象形成树形结构以表示“整体-部分”的结构层次。它定义了如何将容器对象和叶子对象进行递归组合，使得客户在使用的过程中无须进行区分，可以对他们进行一致的处理。在使用组合模式中需要注意一点也是组合模式最关键的地方：叶子对象和组合对象实现相同的接口。这就是组合模式能够将叶子节点和对象节点进行一致处理的原因。</p><p>虽然组合模式能够清晰地定义分层次的复杂对象，也使得增加新构件也更容易，但是这样就导致了系统的设计变得更加抽象，如果系统的业务规则比较复杂的话，使用组合模式就有一定的挑战了。</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/UxEJYKpOIbgwfqL.png" alt="img"></p><p>组合模式包含如下角色：</p><ul><li>Component: 抽象构件</li><li>Leaf: 叶子构件</li><li>Composite: 容器构件</li><li>Client: 客户类</li></ul><h2 id="9-装饰模式"><a href="#9-装饰模式" class="headerlink" title="9. 装饰模式"></a>9. 装饰模式</h2><p>我们可以通过继承和组合的方式来给一个对象添加行为，虽然使用继承能够很好拥有父类的行为，但是它存在几个缺陷：一、对象之间的关系复杂的话，系统变得复杂不利于维护。二、容易产生“类爆炸”现象。三、是静态的。在这里我们可以通过使用装饰者模式来解决这个问题。</p><p>装饰者模式，动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更加有弹性的替代方案。虽然装饰者模式能够动态将责任附加到对象上，但是他会产生许多的细小对象，增加了系统的复杂度。</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/aqKR7yJEzUc13fF.png" alt="img"></p><p>装饰模式包含如下角色：</p><ul><li>Component: 抽象构件</li><li>ConcreteComponent: 具体构件</li><li>Decorator: 抽象装饰类</li><li>ConcreteDecorator: 具体装饰类</li></ul><h2 id="10-外观模式"><a href="#10-外观模式" class="headerlink" title="10. 外观模式"></a>10. 外观模式</h2><p>我们都知道类与类之间的耦合越低，那么可复用性就越好，如果两个类不必彼此通信，那么就不要让这两个类发生直接的相互关系，如果需要调用里面的方法，可以通过第三者来转发调用。外观模式非常好的诠释了这段话。外观模式提供了一个统一的接口，用来访问子系统中的一群接口。它让一个应用程序中子系统间的相互依赖关系减少到了最少，它给子系统提供了一个简单、单一的屏障，客户通过这个屏障来与子系统进行通信。通过使用外观模式，使得客户对子系统的引用变得简单了，实现了客户与子系统之间的松耦合。但是它违背了“开闭原则”，因为增加新的子系统可能需要修改外观类或客户端的源代码。</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/DunpVC7FJxRf1K8.png" alt="img"></p><p>外观模式包含如下角色：</p><ul><li>Facade: 外观角色</li><li>SubSystem:子系统角色</li></ul><h2 id="11-享元模式"><a href="#11-享元模式" class="headerlink" title="11. 享元模式"></a>11. 享元模式</h2><p>在一个系统中对象会使得内存占用过多，特别是那些大量重复的对象，这就是对系统资源的极大浪费。享元模式对对象的重用提供了一种解决方案，它使用共享技术对相同或者相似对象实现重用。享元模式就是运行共享技术有效地支持大量细粒度对象的复用。系统使用少量对象,而且这些都比较相似，状态变化小，可以实现对象的多次复用。这里有一点要注意：享元模式要求能够共享的对象必须是细粒度对象。享元模式通过共享技术使得系统中的对象个数大大减少了，同时享元模式使用了内部状态和外部状态，同时外部状态相对独立，不会影响到内部状态，所以享元模式能够使得享元对象在不同的环境下被共享。同时正是分为了内部状态和外部状态，享元模式会使得系统变得更加复杂，同时也会导致读取外部状态所消耗的时间过长。</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/2RJkTZa7Verqxoi.png" alt="img"></p><p>享元模式包含如下角色：</p><ul><li>Flyweight: 抽象享元类</li><li>ConcreteFlyweight: 具体享元类</li><li>UnsharedConcreteFlyweight: 非共享具体享元类</li><li>FlyweightFactory: 享元工厂类</li></ul><h2 id="12-代理模式"><a href="#12-代理模式" class="headerlink" title="12. 代理模式"></a>12. 代理模式</h2><p> 代理模式就是给一个对象提供一个代理，并由代理对象控制对原对象的引用。它使得客户不能直接与真正的目标对象通信。代理对象是目标对象的代表，其他需要与这个目标对象打交道的操作都是和这个代理对象在交涉。</p><p>代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了的作用和保护了目标对象的，同时也在一定程度上面减少了系统的耦合度。</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/qS1omCadpVLINAi.png" alt="img"></p><p>代理模式包含如下角色：</p><ul><li>Subject: 抽象主题角色</li><li>Proxy: 代理主题角色</li><li>RealSubject: 真实主题角色</li></ul><h2 id="13-访问者模式"><a href="#13-访问者模式" class="headerlink" title="13. 访问者模式"></a>13. 访问者模式</h2><p>访问者模式俗称23大设计模式中最难的一个。除了结构复杂外，理解也比较难。在我们软件开发中我们可能会对同一个对象有不同的处理，如果我们都做分别的处理，将会产生灾难性的错误。对于这种问题，访问者模式提供了比较好的解决方案。访问者模式即表示一个作用于某对象结构中的各元素的操作，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p><p>访问者模式的目的是封装一些施加于某种数据结构元素之上的操作，一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。为不同类型的元素提供多种访问操作方式，且可以在不修改原有系统的情况下增加新的操作方式。同时我们还需要明确一点那就是访问者模式是适用于那些数据结构比较稳定的，因为他是将数据的操作与数据结构进行分离了，如果某个系统的数据结构相对稳定，但是操作算法易于变化的话，就比较适用适用访问者模式，因为访问者模式使得算法操作的增加变得比较简单了。</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/BSa5tzhjuUirb1T.png" alt="img"></p><p>访问者模式包含如下角色：</p><ul><li>Vistor: 抽象访问者</li><li>ConcreteVisitor: 具体访问者</li><li>Element: 抽象元素</li><li>ConcreteElement: 具体元素 </li><li>ObjectStructure: 对象结构</li></ul><h2 id="14-模板模式"><a href="#14-模板模式" class="headerlink" title="14. 模板模式"></a>14. 模板模式</h2><p>有些时候我们做某几件事情的步骤都差不多，仅有那么一小点的不同，在软件开发的世界里同样如此，如果我们都将这些步骤都一一做的话，费时费力不讨好。所以我们可以将这些步骤分解、封装起来，然后利用继承的方式来继承即可，当然不同的可以自己重写实现嘛！这就是模板方法模式提供的解决方案。</p><p>所谓模板方法模式就是在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。</p><p>模板方法模式就是基于继承的代码复用技术的。在模板方法模式中，我们可以将相同部分的代码放在父类中，而将不同的代码放入不同的子类中。也就是说我们需要声明一个抽象的父类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法让子类来实现剩余的逻辑，不同的子类可以以不同的方式来实现这些逻辑。所以模板方法的模板其实就是一个普通的方法，只不过这个方法是将算法实现的步骤封装起来的。</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/PJ2Coy6TUR8EVvr.png" alt="img"></p><p>模板方法模式包含如下角色：</p><ul><li>AbstractClass: 抽象类 </li><li>ConcreteClass: 具体子类</li></ul><h2 id="15-策略模式"><a href="#15-策略模式" class="headerlink" title="15. 策略模式"></a>15. 策略模式</h2><p> 我们知道一件事可能会有很多种方式来实现它，但是其中总有一种最高效的方式，在软件开发的世界里面同样如此，我们也有很多中方法来实现一个功能，但是我们需要一种简单、高效的方式来实现它，使得系统能够非常灵活，这就是策略模式。</p><p>所以策略模式就是定义了算法族，分别封装起来，让他们之前可以互相转换，此模式然该算法的变化独立于使用算法的客户。</p><p>在策略模式中它将这些解决问题的方法定义成一个算法群，每一个方法都对应着一个具体的算法，这里的一个算法我就称之为一个策略。虽然策略模式定义了算法，但是它并不提供算法的选择，即什么算法对于什么问题最合适这是策略模式所不关心的，所以对于策略的选择还是要客户端来做。客户必须要清楚的知道每个算法之间的区别和在什么时候什么地方使用什么策略是最合适的，这样就增加客户端的负担。</p><p>同时策略模式也非常完美的符合了“开闭原则”，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。但是一个策略对应一个类将会是系统产生很多的策略类。</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/pITZOSbKXqcnLhJ.png" alt="img"></p><p>策略模式包含如下角色：</p><ul><li>Context: 环境类</li><li>Strategy: 抽象策略类</li><li>ConcreteStrategy: 具体策略类</li></ul><h2 id="16-状态模式"><a href="#16-状态模式" class="headerlink" title="16. 状态模式"></a>16. 状态模式</h2><p> 在很多情况下我们对象的行为依赖于它的一个或者多个变化的属性，这些可变的属性我们称之为状态，也就是说行为依赖状态，即当该对象因为在外部的互动而导致他的状态发生变化，从而它的行为也会做出相应的变化。对于这种情况，我们是不能用行为来控制状态的变化，而应该站在状态的角度来思考行为，即是什么状态就要做出什么样的行为。这个就是状态模式。</p><p>所以状态模式就是允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</p><p>在状态模式中我们可以减少大块的if…else语句，它是允许态转换逻辑与状态对象合成一体，但是减少if…else语句的代价就是会换来大量的类，所以状态模式势必会增加系统中类或者对象的个数。</p><p>同时状态模式是将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。但是这样就会导致系统的结构和实现都会比较复杂，如果使用不当就会导致程序的结构和代码混乱，不利于维护。</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/TmpnJvYt6bDq3gL.png" alt="img"></p><p> 状态模式包含如下角色：</p><ul><li>Context: 环境类</li><li>State: 抽象状态类</li><li>ConcreteState: 具体状态类</li></ul><h2 id="17-观察者模式"><a href="#17-观察者模式" class="headerlink" title="17. 观察者模式"></a>17. 观察者模式</h2><p>何谓观察者模式？观察者模式定义了对象之间的一对多依赖关系，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并且自动更新。</p><p>在这里，发生改变的对象称之为观察目标，而被通知的对象称之为观察者。一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，所以么可以根据需要增加和删除观察者，使得系统更易于扩展。所以观察者提供了一种对象设计，让主题和观察者之间以松耦合的方式结合。</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/HanisYtFfIpv7EG.png" alt="img"></p><p> 观察者模式包含如下角色：</p><ul><li>Subject: 目标</li><li>ConcreteSubject: 具体目标</li><li>Observer: 观察者</li><li>ConcreteObserver: 具体观察者</li></ul><h2 id="18-备忘录模式"><a href="#18-备忘录模式" class="headerlink" title="18. 备忘录模式"></a>18. 备忘录模式</h2><p> 后悔药人人都想要，但是事实却是残酷的，根本就没有后悔药可买，但是也不仅如此，在软件的世界里就有后悔药！备忘录模式就是一种后悔药，它给我们的软件提供后悔药的机制，通过它可以使系统恢复到某一特定的历史状态。</p><p>所谓备忘录模式就是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。它实现了对信息的封装，使得客户不需要关心状态保存的细节。保存就要消耗资源，所以备忘录模式的缺点就在于消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/HEGpR5gIjQU6svb.png" alt="img"></p><p>备忘录模式包含如下角色：</p><ul><li>Originator: 原发器</li><li>Memento: 备忘录</li><li>Caretaker: 负责人</li></ul><h2 id="19-中介者模式"><a href="#19-中介者模式" class="headerlink" title="19. 中介者模式"></a>19. 中介者模式</h2><p> 租房各位都有过的经历吧！在这个过程中中介结构扮演着很重要的角色，它在这里起到一个中间者的作用，给我们和房主互相传递信息。在外面软件的世界里同样需要这样一个中间者。在我们的系统中有时候会存在着对象与对象之间存在着很强、复杂的关联关系，如果让他们之间有直接的联系的话，必定会导致整个系统变得非常复杂，而且可扩展性很差！在前面我们就知道如果两个类之间没有不必彼此通信，我们就不应该让他们有直接的关联关系，如果实在是需要通信的话，我们可以通过第三者来转发他们的请求。同样，这里我们利用中介者来解决这个问题。</p><p>所谓中介者模式就是用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。在中介者模式中，中介对象用来封装对象之间的关系，各个对象可以不需要知道具体的信息通过中介者对象就可以实现相互通信。它减少了对象之间的互相关系，提供了系统可复用性，简化了系统的结构。</p><p> 在中介者模式中，各个对象不需要互相知道了解，他们只需要知道中介者对象即可，但是中介者对象就必须要知道所有的对象和他们之间的关联关系，正是因为这样就导致了中介者对象的结构过于复杂，承担了过多的职责，同时它也是整个系统的核心所在，它有问题将会导致整个系统的问题。所以如果在系统的设计过程中如果出现“多对多”的复杂关系群时，千万别急着使用中介者模式，而是要仔细思考是不是您设计的系统存在问题。</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/LDZSOopyjJ1bVXm.png" alt="img"></p><p>中介者模式包含如下角色：</p><ul><li>Mediator: 抽象中介者</li><li>ConcreteMediator: 具体中介者</li><li>Colleague: 抽象同事类</li><li>ConcreteColleague: 具体同事类</li></ul><h2 id="20-迭代器模式"><a href="#20-迭代器模式" class="headerlink" title="20. 迭代器模式"></a>20. 迭代器模式</h2><p>对于迭代在编程过程中我们经常用到，能够游走于聚合内的每一个元素，同时还可以提供多种不同的遍历方式，这就是迭代器模式的设计动机。在我们实际的开发过程中，我们可能会需要根据不同的需求以不同的方式来遍历整个对象，但是我们又不希望在聚合对象的抽象接口中充斥着各种不同的遍历操作，于是我们就希望有某个东西能够以多种不同的方式来遍历一个聚合对象，这时迭代器模式出现了。</p><p>何为迭代器模式？所谓迭代器模式就是提供一种方法顺序访问一个聚合对象中的各个元素，而不是暴露其内部的表示。迭代器模式是将迭代元素的责任交给迭代器，而不是聚合对象，我们甚至在不需要知道该聚合对象的内部结构就可以实现该聚合对象的迭代。</p><p>通过迭代器模式，使得聚合对象的结构更加简单，它不需要关注它元素的遍历，只需要专注它应该专注的事情，这样就更加符合单一职责原则了。</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/rT8CVjcMHv4No5n.png" alt="img"></p><p>迭代器模式包含如下角色：</p><ul><li>Iterator: 抽象迭代器</li><li>ConcreteIterator: 具体迭代器</li><li>Aggregate: 抽象聚合类</li><li>ConcreteAggregate: 具体聚合类</li></ul><h2 id="21-解释器模式"><a href="#21-解释器模式" class="headerlink" title="21. 解释器模式"></a>21. 解释器模式</h2><p>所谓解释器模式就是定义语言的文法，并且建立一个解释器来解释该语言中的句子。解释器模式描述了如何构成一个简单的语言解释器，主要应用在使用面向对象语言开发的编译器中。它描述了如何为简单的语言定义一个文法，如何在该语言中表示一个句子，以及如何解释这些句子。</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/Omca1shN58iFtSX.png" alt="img"></p><p>解释器模式包含如下角色：</p><ul><li>AbstractExpression: 抽象表达式</li><li>TerminalExpression: 终结符表达式</li><li>NonterminalExpression: 非终结符表达式</li><li>Context: 环境类</li><li>Client: 客户类</li></ul><h2 id="22-命令模式"><a href="#22-命令模式" class="headerlink" title="22. 命令模式"></a>22. 命令模式</h2><p> 有些时候我们想某个对象发送一个请求，但是我们并不知道该请求的具体接收者是谁，具体的处理过程是如何的，们只知道在程序运行中指定具体的请求接收者即可，对于这样将请求封装成对象的我们称之为命令模式。所以命令模式将请求封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。同时命令模式支持可撤销的操作。</p><p>命令模式可以将请求的发送者和接收者之间实现完全的解耦，发送者和接收者之间没有直接的联系，发送者只需要知道如何发送请求命令即可，其余的可以一概不管，甚至命令是否成功都无需关心。同时我们可以非常方便的增加新的命令，但是可能就是因为方便和对请求的封装就会导致系统中会存在过多的具体命令类。</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/EwTZCMiURVGYx23.png" alt="img"></p><p>命令模式包含如下角色：</p><ul><li>Command: 抽象命令类</li><li>ConcreteCommand: 具体命令类</li><li>Invoker: 调用者</li><li>Receiver: 接收者</li><li>Client:客户类</li></ul><h2 id="23-责任链模式"><a href="#23-责任链模式" class="headerlink" title="23. 责任链模式"></a>23. 责任链模式</h2><p>职责链模式描述的请求如何沿着对象所组成的链来传递的。它将对象组成一条链，发送者将请求发给链的第一个接收者，并且沿着这条链传递，直到有一个对象来处理它或者直到最后也没有对象处理而留在链末尾端。</p><p>避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止，这就是职责链模式。在职责链模式中，使得每一个对象都有可能来处理请求，从而实现了请求的发送者和接收者之间的解耦。同时职责链模式简化了对象的结构，它使得每个对象都只需要引用它的后继者即可，而不必了解整条链，这样既提高了系统的灵活性也使得增加新的请求处理类也比较方便。但是在职责链中我们不能保证所有的请求都能够被处理，而且不利于观察运行时特征。</p><p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/hKBcxlIoMF8gmGV.png" alt="img"></p><p>职责链模式包含如下角色：</p><ul><li>Handler: 抽象处理者</li><li>ConcreteHandler: 具体处理者</li><li>Client: 客户类</li></ul>]]></content>
    
    
    <summary type="html">概说JAVA 23种设计模式</summary>
    
    
    
    <category term="设计模式" scheme="https://fabian4.site/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://fabian4.site/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    <category term="JAVA" scheme="https://fabian4.site/blog/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>设计模式和设计模式原则</title>
    <link href="https://fabian4.site/blog/14128.html"/>
    <id>https://fabian4.site/blog/14128.html</id>
    <published>2021-01-12T16:00:00.000Z</published>
    <updated>2022-08-24T07:47:19.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式和设计模式原则"><a href="#设计模式和设计模式原则" class="headerlink" title="设计模式和设计模式原则"></a>设计模式和设计模式原则</h1><h2 id="一、设计模式"><a href="#一、设计模式" class="headerlink" title="一、设计模式"></a>一、设计模式</h2><blockquote><p>“设计模式”这个术语最初并不是出现在软件设计中，而是被用于建筑领域的设计中。</p></blockquote><h3 id="1-设计模式的概念"><a href="#1-设计模式的概念" class="headerlink" title="1. 设计模式的概念"></a>1. 设计模式的概念</h3><p>软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。其目的是为了提高代码的可重用性、代码的可读性和代码的可靠性。</p><h3 id="2-学习设计模式的意义"><a href="#2-学习设计模式的意义" class="headerlink" title="2. 学习设计模式的意义"></a>2. 学习设计模式的意义</h3><p><strong>设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。</strong></p><p>正确使用设计模式具有以下优点。</p><ul><li>可以提高程序员的思维能力、编程能力和设计能力。</li><li>使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。</li><li>使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。</li></ul><h3 id="3-设计模式的四个要素"><a href="#3-设计模式的四个要素" class="headerlink" title="3. 设计模式的四个要素"></a>3. 设计模式的四个要素</h3><ol><li><p><strong>模式名称</strong></p><p>每一个模式都有自己的名字，通常用一两个词来描述，可以根据模式的问题、特点、解决方案、功能和效果来命名。模式名称（PatternName）有助于我们理解和记忆该模式，也方便我们来讨论自己的设计。</p></li><li><p><strong>问题</strong></p><p>问题（Problem）描述了该模式的应用环境，即何时使用该模式。它解释了设计问题和问题存在的前因后果，以及必须满足的一系列先决条件。</p></li><li><p><strong>解决方案</strong></p><p>模式问题的解决方案（Solution）包括设计的组成成分、它们之间的相互关系及各自的职责和协作方式。因为模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象的 组合）来解决这个问题。</p></li><li><p><strong>效果</strong></p><p>描述了模式的应用效果以及使用该模式应该权衡的问题，即模式的优缺点。主要是对时间和空间的衡量，以及该模式对系统的灵活性、扩充性、可移植性的影响，也考虑其实现问题。显式地列出这些效果（Consequence）对理解和评价这些模式有很大的帮助。</p></li></ol><h2 id="二、设计模式的分类"><a href="#二、设计模式的分类" class="headerlink" title="二、设计模式的分类"></a>二、设计模式的分类</h2><ul><li>创建型模式共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式</li><li>结构型模式    共七种：适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li><li>行为型模式    共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li></ul><ol><li>单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li><li>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li><li>工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</li><li>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li><li>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li><li>代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li><li>适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li><li>桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</li><li>装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。</li><li>外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li><li>享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</li><li>组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li><li>模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</li><li>策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</li><li>命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</li><li>职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</li><li>状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。</li><li>观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li><li>中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</li><li>迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li><li>访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</li><li>备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</li><li>解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</li></ol><h2 id="三、设计模式原则"><a href="#三、设计模式原则" class="headerlink" title="三、设计模式原则"></a>三、设计模式原则</h2><h3 id="1-总原则：开闭原则"><a href="#1-总原则：开闭原则" class="headerlink" title="1. 总原则：开闭原则"></a>1. 总原则：开闭原则</h3><h4 id="定义：软件实体应当对扩展开放，对修改关闭"><a href="#定义：软件实体应当对扩展开放，对修改关闭" class="headerlink" title="定义：软件实体应当对扩展开放，对修改关闭"></a>定义：<strong>软件实体应当对扩展开放，对修改关闭</strong></h4><p>开闭原则的含义是：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol><li><p>对软件测试的影响</p><p>软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。</p></li><li><p>可以提高代码的可复用性</p><p>粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。</p></li><li><p>可以提高软件的可维护性</p><p>遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。</p></li></ol><h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><p>可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。</p><p>因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。</p><h3 id="2-里氏替换原则"><a href="#2-里氏替换原则" class="headerlink" title="2. 里氏替换原则"></a>2. 里氏替换原则</h3><h4 id="定义：继承必须确保超类所拥有的性质在子类中仍然成立"><a href="#定义：继承必须确保超类所拥有的性质在子类中仍然成立" class="headerlink" title="定义：继承必须确保超类所拥有的性质在子类中仍然成立"></a>定义：<strong>继承必须确保超类所拥有的性质在子类中仍然成立</strong></h4><p>子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ol><li>里氏替换原则是实现开闭原则的重要方式之一。</li><li>它克服了继承中重写父类造成的可复用性变差的缺点。</li><li>它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。</li><li>加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。</li></ol><h4 id="实现方法："><a href="#实现方法：" class="headerlink" title="实现方法："></a>实现方法：</h4><ul><li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法</li><li>子类中可以增加自己特有的方法</li><li>当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松</li><li>当子类的方法实现父类的方法时（重写&#x2F;重载或实现抽象方法），方法的后置条件（即方法的的输出&#x2F;返回值）要比父类的方法更严格或相等</li></ul><h3 id="3-依赖倒置原则"><a href="#3-依赖倒置原则" class="headerlink" title="3. 依赖倒置原则"></a>3. 依赖倒置原则</h3><h4 id="定义：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象"><a href="#定义：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象" class="headerlink" title="定义：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象"></a>定义：<strong>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象</strong></h4><p>核心思想是：要面向接口编程，不要面向实现编程。</p><p>依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。</p><h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><ol><li>依赖倒置原则可以降低类间的耦合性。</li><li>依赖倒置原则可以提高系统的稳定性。</li><li>依赖倒置原则可以减少并行开发引起的风险。</li><li>依赖倒置原则可以提高代码的可读性和可维护性。</li></ol><h4 id="实现方法-1"><a href="#实现方法-1" class="headerlink" title="实现方法"></a>实现方法</h4><ul><li>每个类尽量提供接口或抽象类，或者两者都具备。</li><li>变量的声明类型尽量是接口或者是抽象类。</li><li>任何类都不应该从具体类派生。</li><li>使用继承时尽量遵循里氏替换原则。</li></ul><h3 id="4-单一职责原则"><a href="#4-单一职责原则" class="headerlink" title="4. 单一职责原则"></a>4. 单一职责原则</h3><h4 id="定义：一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分"><a href="#定义：一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分" class="headerlink" title="定义：一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分"></a>定义：<strong>一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分</strong></h4><p>单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。</p><p>该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：</p><ol><li>一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；</li><li>当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。</li></ol><h4 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h4><ol><li>降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。</li><li>提高类的可读性。复杂性降低，自然其可读性会提高。</li><li>提高系统的可维护性。可读性提高，那自然更容易维护了。</li><li>变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。</li></ol><h4 id="实现方法-2"><a href="#实现方法-2" class="headerlink" title="实现方法"></a>实现方法</h4><p>单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。</p><h3 id="5-接口隔离原则"><a href="#5-接口隔离原则" class="headerlink" title="5. 接口隔离原则"></a>5. 接口隔离原则</h3><h4 id="定义：一个类对另一个类的依赖应该建立在最小的接口上"><a href="#定义：一个类对另一个类的依赖应该建立在最小的接口上" class="headerlink" title="定义：一个类对另一个类的依赖应该建立在最小的接口上"></a>定义：<strong>一个类对另一个类的依赖应该建立在最小的接口上</strong></h4><p>要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。</p><p>接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：</p><ul><li>单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。</li><li>单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。</li></ul><h4 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h4><ol><li>将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</li><li>接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。</li><li>如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。</li><li>使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。</li><li>能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。</li></ol><h4 id="实现方法-3"><a href="#实现方法-3" class="headerlink" title="实现方法"></a>实现方法</h4><ul><li>接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。</li><li>为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。</li><li>了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。</li><li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li></ul><h3 id="6-迪米特法则"><a href="#6-迪米特法则" class="headerlink" title="6. 迪米特法则"></a>6. 迪米特法则</h3><h4 id="定义：只与你的直接朋友交谈，不跟“陌生人”说话"><a href="#定义：只与你的直接朋友交谈，不跟“陌生人”说话" class="headerlink" title="定义：只与你的直接朋友交谈，不跟“陌生人”说话"></a>定义：<strong>只与你的直接朋友交谈，不跟“陌生人”说话</strong></h4><p>如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p><h4 id="作用-5"><a href="#作用-5" class="headerlink" title="作用"></a>作用</h4><ol><li>降低了类之间的耦合度，提高了模块的相对独立性。</li><li>由于亲合度降低，从而提高了类的可复用率和系统的扩展性。</li></ol><h4 id="实现方法-4"><a href="#实现方法-4" class="headerlink" title="实现方法"></a>实现方法</h4><ul><li>从依赖者的角度来说，只依赖应该依赖的对象。</li><li>从被依赖者的角度说，只暴露应该暴露的方法。</li></ul><p>注意点：</p><ol><li>在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。</li><li>在类的结构设计上，尽量降低类成员的访问权限。</li><li>在类的设计上，优先考虑将一个类设置成不变类。</li><li>在对其他类的引用上，将引用其他对象的次数降到最低。</li><li>不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。</li><li>谨慎使用序列化（Serializable）功能。</li></ol><h3 id="7-合成复用原则"><a href="#7-合成复用原则" class="headerlink" title="7. 合成复用原则"></a>7. 合成复用原则</h3><h4 id="定义：要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现"><a href="#定义：要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现" class="headerlink" title="定义：要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现"></a>定义：要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现</h4><p>如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。</p><p>继承复用的缺点：</p><ol><li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。</li><li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li><li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</li></ol><h4 id="作用-6"><a href="#作用-6" class="headerlink" title="作用"></a>作用</h4><ol><li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</li><li>新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。</li><li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</li></ol><h4 id="实现方法-5"><a href="#实现方法-5" class="headerlink" title="实现方法"></a>实现方法</h4><p>合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。</p>]]></content>
    
    
    <summary type="html">设计模式和设计模式原则</summary>
    
    
    
    <category term="设计模式" scheme="https://fabian4.site/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://fabian4.site/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
