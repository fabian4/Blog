<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>HashMap源码解析 | Fabian Bao</title><meta name="keywords" content="java,源码,jdk,HashMap"><meta name="author" content="Fabian Bao"><meta name="copyright" content="Fabian Bao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="HashMap源码解析">
<meta property="og:type" content="article">
<meta property="og:title" content="HashMap源码解析">
<meta property="og:url" content="https://fabian4.site/blog/14375.html">
<meta property="og:site_name" content="Fabian Bao">
<meta property="og:description" content="HashMap源码解析">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/LuciolaCruciata_ZH-CN9063767400_1920x1080.jpg">
<meta property="article:published_time" content="2021-03-26T16:00:00.000Z">
<meta property="article:modified_time" content="2022-08-24T07:47:19.050Z">
<meta property="article:author" content="Fabian Bao">
<meta property="article:tag" content="java">
<meta property="article:tag" content="源码">
<meta property="article:tag" content="jdk">
<meta property="article:tag" content="HashMap">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/LuciolaCruciata_ZH-CN9063767400_1920x1080.jpg"><link rel="shortcut icon" href="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/202015ouknbvshlsrvbku5.jpeg.icon.png"><link rel="canonical" href="https://fabian4.site/blog/14375"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/blog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-E90K5222F4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-E90K5222F4');
</script><script>const GLOBAL_CONFIG = { 
  root: '/blog/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'HashMap源码解析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-08-24 15:47:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/blog/atom.xml" title="Fabian Bao" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://fabian4.site/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">73</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/blog/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/blog/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/blog/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/blog/read/"><i class="fa-fw fa fa-book"></i><span> 阅读</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://fabian.oss-cn-hangzhou.aliyuncs.com/img/LuciolaCruciata_ZH-CN9063767400_1920x1080.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/blog/">Fabian Bao</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/blog/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/blog/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/blog/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/blog/read/"><i class="fa-fw fa fa-book"></i><span> 阅读</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">HashMap源码解析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-26T16:00:00.000Z" title="发表于 2021-03-27 00:00:00">2021-03-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-08-24T07:47:19.050Z" title="更新于 2022-08-24 15:47:19">2022-08-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/blog/categories/jdk%E6%BA%90%E7%A0%81/">jdk源码</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>20分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="HashMap源码解析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/blog/14375.html#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="HashMap源码解析"><a href="#HashMap源码解析" class="headerlink" title="HashMap源码解析"></a>HashMap源码解析</h1><p>作为面试必问的hashmap，我们今天来一起来探究一下他的源码。这里先贴一张 hashmap 的内部类和部分方法函数</p>
<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210921204040629.png" alt="image-20210921204040629" style="zoom: 67%;" />

<h2 id="一、什么是-哈希，-哈希函数（散列函数）"><a href="#一、什么是-哈希，-哈希函数（散列函数）" class="headerlink" title="一、什么是 哈希， 哈希函数（散列函数）"></a>一、什么是 哈希， 哈希函数（散列函数）</h2><blockquote>
<p>Hash，一般翻译做散列、杂凑，或音译为哈希，是把任意长度的<a target="_blank" rel="noopener external nofollow noreferrer" href="https://baike.baidu.com/item/%E8%BE%93%E5%85%A5/5481954">输入</a>（又叫做预映射pre-image）通过散列算法变换成固定长度的<a target="_blank" rel="noopener external nofollow noreferrer" href="https://baike.baidu.com/item/%E8%BE%93%E5%87%BA/11056752">输出</a>，该输出就是散列值。这种转换是一种<a target="_blank" rel="noopener external nofollow noreferrer" href="https://baike.baidu.com/item/%E5%8E%8B%E7%BC%A9%E6%98%A0%E5%B0%84/5114126">压缩映射</a>，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的<a target="_blank" rel="noopener external nofollow noreferrer" href="https://baike.baidu.com/item/%E6%B6%88%E6%81%AF%E6%91%98%E8%A6%81/4547744">消息摘要</a>的函数。</p>
</blockquote>
<p>上面是百度百科的解释。我们可以简单的概括为</p>
<ul>
<li>hash 就是将 <strong>任意的输入</strong> 通过 一种 <strong>特殊的算法</strong> 变成 <strong>长度固定</strong> 的输出。 </li>
<li>可以类似于一种摘要算法，获取我们输入内容的特征来生成一个简短的摘要</li>
<li>由于算法可以保证：相同的输入每次都是可以得到相同的输出，即hash值</li>
<li>但是也会发生：不同的输入哈希之后会得到相同的结果 <strong>即 哈希冲突</strong></li>
</ul>
<h3 id="object-中的-hashcode-方法"><a href="#object-中的-hashcode-方法" class="headerlink" title="object 中的 hashcode 方法"></a>object 中的 hashcode 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>方法本身是 native 方法，调用了底层的的类库，根据注释：</p>
<p>hashCode 遵守着如下的约定：</p>
<ul>
<li>Whenever it is invoked on the same object more than once during an execution of a Java application, the hashCode method must consistently return the same integer, provided no information used in equals comparisons on the object is modified. This integer need not remain consistent from one execution of an application to another execution of the same application.</li>
<li>If two objects are equal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce the same integer result.</li>
<li>It is not required that if two objects are unequal according to the equals(Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hash tables.</li>
</ul>
<p>翻译一下就是</p>
<ul>
<li><p>在程序一次执行的过程中，无论何时被调用，这个方法都会返回相同的值。但是程序的多次执行就不能保证每一次都相等</p>
</li>
<li><p>如果两个对象的 equals 方法返回 true，那么他们调用此方法就一定返回相同的结果</p>
</li>
<li><p>当然也不一定要确保：两个对象如果根据重写的 equals 方法返回为 false，那么此方法的返回结果一定不同。</p>
<blockquote>
<p>即：两个对象 根据重写的equals判断为不相等，此时的 hashcode 也可以相同</p>
<p>不过我们在写程序时应该注意尽量是不同的对象返回不同的hashcode，以便加强哈希效率，避免哈希冲突</p>
</blockquote>
</li>
</ul>
<h3 id="hashmap-采用的哈希方法"><a href="#hashmap-采用的哈希方法" class="headerlink" title="hashmap 采用的哈希方法"></a>hashmap 采用的哈希方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="comment">// 这里当 key 不为 null 的时候，将key的哈希值 和 右移16位的哈希值 做异或运算</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210924132832294.png" alt="image-20210924132832294"></p>
<p>将h无符号右移16为相当于将高区16位移动到了低区的16位，再与原hashcode做异或运算，可以<strong>将高低位二进制特征混合起来</strong>。即<strong>哈希扰动</strong>。</p>
<p>从上文可知高区的16位与原hashcode相比没有发生变化，低区的16位发生了变化。</p>
<p>我们都知道重新计算出的新哈希值在后面将会参与hashmap中数组槽位的计算，计算公式：(n - 1) &amp; hash，假如这时数组槽位有16个，则槽位计算如下：</p>
<p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210924133141544.png" alt="image-20210924133141544"></p>
<p><strong>高区的16位很有可能会被数组槽位数的二进制码屏蔽，如果我们不做刚才移位异或运算，那么在计算槽位时将丢失高区特征</strong></p>
<p>也许你可能会说，即使丢失了高区特征不同hashcode也可以计算出不同的槽位来，但是细想当两个哈希码很接近时，那么这高区的一点点差异就<strong>可能导致一次哈希碰撞</strong>，所以这也是将性能做到极致的一种体现</p>
<h3 id="取余-和位运算-amp"><a href="#取余-和位运算-amp" class="headerlink" title="取余 % 和位运算 &amp;"></a>取余 % 和位运算 &amp;</h3><p>我们看到源码中存放值的时候：<code>(n - 1) &amp; hash</code></p>
<p>一般来说我们的认为都是将 哈希值 和数组的长度进行取模运算来获得数组的下标</p>
<ul>
<li>那么这里主要考虑到的是：<strong>位运算相比取模运算效率更高</strong></li>
</ul>
<p>关于为什么位运算能代替取模运算可以参考这个 👉<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/ysocean/p/9054804.html"><strong>由HashMap哈希算法引出的求余%和与运算&amp;转换问题</strong></a></p>
<blockquote>
<p><strong>当 lenth &#x3D; 2n 时，X % length &#x3D; X &amp; (length - 1)</strong></p>
<ul>
<li>也就是说，长度为2的n次幂时，模运算 % 可以变换为按位与 &amp; 运算。</li>
</ul>
<p>　　比如：9 % 4 &#x3D; 1，9的二进制是 1001 ,4-1 &#x3D; 3,3的二进制是 0011。 9 &amp; 3 &#x3D; 1001 &amp; 0011 &#x3D; 0001 &#x3D; 1</p>
<p>　　再比如：12 % 8 &#x3D; 4,12的二进制是 1100,8-1 &#x3D; 7,7的二进制是 0111。12 &amp; 7 &#x3D; 1100 &amp; 0111 &#x3D; 0100 &#x3D; 4</p>
<ul>
<li>上面两个例子4和8都是2的n次幂，结论是成立的，那么当长度不为2的n次幂呢？</li>
</ul>
<p>　　比如：9 % 5 &#x3D; 4，9的二进制是 1001，5-1 &#x3D; 4,4的二进制是0100。9 &amp; 4 &#x3D; 1001 &amp; 0100 &#x3D; 0000 &#x3D; 0。显然是不成立的。</p>
</blockquote>
<h2 id="二、存储方式和数据结构"><a href="#二、存储方式和数据结构" class="headerlink" title="二、存储方式和数据结构"></a>二、存储方式和数据结构</h2><blockquote>
<p>问：HashMap的底层数据结构是什么</p>
<p>答：数组+链表+红黑树</p>
</blockquote>
<p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210924142231035.png" alt="image-20210924142231035"></p>
<p>从上面的图中我们可以看出hashmap的存储结构，默认是数组+链表的结构。</p>
<p>当<strong>链表的长度大于 8 (默认)</strong> 的时候，链表会转换为红黑树。</p>
<ul>
<li><p>node 的数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment">* necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment">* (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment">* bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>
</li>
<li><p>node 结点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Basic hash bin node, used for most entries.  (See below for</span></span><br><span class="line"><span class="comment">* TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.hash = hash;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> K <span class="title function_">getKey</span><span class="params">()</span>        &#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">getValue</span><span class="params">()</span>      &#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> &#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * node结点的哈希值：将 key 的哈希值和 value 的哈希值进行异或运算</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">setValue</span><span class="params">(V newValue)</span> &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="built_in">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>treenode 结点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn</span></span><br><span class="line"><span class="comment">* extends Node) so can be used as extension of either regular or</span></span><br><span class="line"><span class="comment">* linked node.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="type">boolean</span> red;</span><br><span class="line">    TreeNode(<span class="type">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>Hashmap中的链表大小超过八个时会自动转化为红黑树，当删除小于六时重新变为链表</p>
</blockquote>
<h2 id="三、构造方法和初始化"><a href="#三、构造方法和初始化" class="headerlink" title="三、构造方法和初始化"></a>三、构造方法和初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and load factor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment"> *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="built_in">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="built_in">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个是最后被调用的构造方法，本质上就是先给 hashmap 初始两个值：<strong>initialCapacity</strong> 和 <strong>loadFactor</strong>：即初始容量和负载因子</p>
<h3 id="1-初始容量-initialCapacity"><a href="#1-初始容量-initialCapacity" class="headerlink" title="1. 初始容量 initialCapacity"></a>1. 初始容量 initialCapacity</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取 比 cap 大的最小的二进制数</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">tableSizeFor</span><span class="params">(<span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="comment">// 避免 输入为2的幂时 返回了 cap * 2</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们以输入 9 为例</p>
<ol>
<li><p>n &#x3D; cap - 1;</p>
<p><strong>这里如果直接没有 -1 操作，如果输入的为2的幂，补1之后再+1，就不会返回原值而是 cap*2</strong></p>
<p>n &#x3D;  00000000 00000000 00000000 00001000</p>
</li>
<li><p>n |&#x3D; n &gt;&gt;&gt; 1</p>
<p>00000000 00000000 00000000 00001000  n</p>
<p>00000000 00000000 00000000 00000100  n &gt;&gt;&gt; 1</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<p>00000000 00000000 00000000 00001100 &#x3D;&gt; n  </p>
</li>
<li><p>n |&#x3D; n &gt;&gt;&gt; 2</p>
<p>00000000 00000000 00000000 00001101  n</p>
<p>00000000 00000000 00000000 00000011  n &gt;&gt;&gt; 2</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p>
<p>00000000 00000000 00000000 00001111 &#x3D;&gt; n  </p>
</li>
<li><p>后续操作使得后续全为一</p>
</li>
<li><p>最后检查 大于零且小于最大值，将结果加一返回：16</p>
</li>
</ol>
<h3 id="2-负载因子-loadFactor"><a href="#2-负载因子-loadFactor" class="headerlink" title="2. 负载因子 loadFactor"></a>2. 负载因子 loadFactor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment"> * 这里我们可以看到 jdk 默认的负载因子为 0.75。当初始化未指定时就采用此值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure>

<p>这个值和我们hashmap的扩容有关：<strong>比如说当前的容器容量是16，负载因子是0.75,16*0.75&#x3D;12，也就是说，当容量达到了12的时候就会进行扩容操作</strong></p>
<p>此处我们可以从时间和空间的角度来考虑：</p>
<ul>
<li><strong>当负载因子的值为 1</strong><ul>
<li>此时只有当 node 数组被填满时才会进行扩容</li>
<li>既然哈希碰撞是不可避免的，那么此时底层的红黑树结构就会变得异常复杂，明显会降低查询效率</li>
<li>时间换空间</li>
</ul>
</li>
<li><strong>当负载因子的值为 0.5</strong><ul>
<li>此时当 node 数组被填充超过一半就会进行扩容</li>
<li>那么虽然可以降低底层红黑树的结构提高查找效率，也无疑牺牲了一半的存储空间</li>
<li>空间换时间</li>
</ul>
</li>
</ul>
<p>所以 0.75 的选择可以说是空间和时间的权衡。但最后的 0.75 也并不是简单的 0.5 和 1 的折中。</p>
<p>根据源码的注释，里面涉及到一些统计学方面的泊松分布的计算，这里就不展开细说了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Ideally, under random hashCodes, the frequency of</span></span><br><span class="line"><span class="comment">* nodes in bins follows a Poisson distribution</span></span><br><span class="line"><span class="comment">* (http://en.wikipedia.org/wiki/Poisson_distribution) with a</span></span><br><span class="line"><span class="comment">* parameter of about 0.5 on average for the default resizing</span></span><br><span class="line"><span class="comment">* threshold of 0.75, although with a large variance because of</span></span><br><span class="line"><span class="comment">* resizing granularity. Ignoring variance, the expected</span></span><br><span class="line"><span class="comment">* occurrences of list size k are (exp(-0.5) * pow(0.5, k) /</span></span><br><span class="line"><span class="comment">* factorial(k)). The first values are:</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 0:    0.60653066</span></span><br><span class="line"><span class="comment">* 1:    0.30326533</span></span><br><span class="line"><span class="comment">* 2:    0.07581633</span></span><br><span class="line"><span class="comment">* 3:    0.01263606</span></span><br><span class="line"><span class="comment">* 4:    0.00157952</span></span><br><span class="line"><span class="comment">* 5:    0.00015795</span></span><br><span class="line"><span class="comment">* 6:    0.00001316</span></span><br><span class="line"><span class="comment">* 7:    0.00000094</span></span><br><span class="line"><span class="comment">* 8:    0.00000006</span></span><br><span class="line"><span class="comment">* more: less than 1 in ten million</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="四、添加元素和查找元素"><a href="#四、添加元素和查找元素" class="headerlink" title="四、添加元素和查找元素"></a>四、添加元素和查找元素</h2><h3 id="1-put-方法"><a href="#1-put-方法" class="headerlink" title="1. put 方法"></a>1. put 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment"> * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment"> * value is replaced.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment"> *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>这里贴一张流程图并且附上加了注释的源码</strong></p>
<p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210927232504843.png" alt="image-20210927232504843"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 	密钥的散列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 	键值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 	要放置的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent 	如果为真，则不更改现有值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict 	如果为 false，则表处于创建模式。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 	以前的值，如果没有，则为 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line"></span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    Node&lt;K,V&gt; p;</span><br><span class="line">    <span class="type">int</span> n, i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// table数组为空或者长度为零则 调用 resize() 来初始化数组</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算数组下标，如果结点为空则新建结点放入</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        K k;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果和头节点哈希值相等，则直接命中头节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是树节点进行红黑树的操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 剩下的就是链表节点操作</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 走到尾结点则新建节点追加在后面</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 如果链表长度超过阈值则转化为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 当未走到尾结点时，根据哈希值是否相等来判断是否命中</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="comment">// 根据标识位判断是否替换</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 提供给 LinkedHashMap 的回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新修改次数来保证迭代器的快速失败机制</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 超过阈值就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供给 LinkedHashMap 的回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-get-方法-和-containsKey-方法"><a href="#2-get-方法-和-containsKey-方法" class="headerlink" title="2. get 方法 和 containsKey 方法"></a>2. get 方法 和 containsKey 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(hash(key), key) != <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里我们可以看到底层都是调用了 <code>getNode()</code>这个方法通过哈希值和键值去搜索结点</p>
<p><code>containsKey</code>：如果找到结点则返回 true，否则返回 false</p>
<p><code>get</code>：如果找到结点返回结点的 value 值，否则返回 null</p>
<ul>
<li>不过要注意的是，这里如果返回了 null 可能有<strong>两种原因</strong>：<ol>
<li><strong>key 不存在</strong></li>
<li><strong>key 存在，但是存储的结果为 null</strong></li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    Node&lt;K,V&gt;[] tab; </span><br><span class="line">    Node&lt;K,V&gt; first, e; </span><br><span class="line">    <span class="type">int</span> n; </span><br><span class="line">    K k;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先对头节点做判断</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果是红黑树结点</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 最后遍历链表</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、扩容和rehash"><a href="#五、扩容和rehash" class="headerlink" title="五、扩容和rehash"></a>五、扩容和rehash</h2><p>这里我们先上<code>resize()</code>函数的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当原结构有数据的时候</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果之前的容量大于最大容量，即将阈值调整到最大并不再扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当新容量小于最大容量 旧容量大于默认初始值时，对阈值 double</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果一开始给定了初始容量，就取初始化时的值</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后采取默认值</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过最大容量和负载因子计算阈值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 newCap 创建新的数组</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不为空，搬运之前map的存储内容，遍历每一个数组</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 将链表分成两个组，根据哈希值一部分留在原来数组位置，一部分向前 oldCap</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数一般提供两个功能：</p>
<ul>
<li>在构造函数之后，第一次<code>put()</code>发现数组为空则会调用，实现懒加载</li>
<li>当存储的数据超过阈值时调用，来实现扩容</li>
</ul>
<p><strong>经过rehash之后，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置</strong></p>
<p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210929231418128.png" alt="image-20210929231418128"></p>
<p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210929231439803.png" alt="image-20210929231439803"></p>
<p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210929231504675.png" alt="image-20210929231504675"></p>
<blockquote>
<ul>
<li><p>扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。</p>
</li>
<li><p>负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。</p>
</li>
</ul>
</blockquote>
<h2 id="六、头插法和尾插法"><a href="#六、头插法和尾插法" class="headerlink" title="六、头插法和尾插法"></a>六、头插法和尾插法</h2><blockquote>
<p>JDK8以前是头插法，JDK8后是尾插法</p>
</blockquote>
<p>头插法和尾插法，顾名思义就是插入链表的时候插入在链表头部还是尾部。</p>
<p><strong>由于<code>HashMap</code>在扩容时采用头插法会造成链表死循环，故在JDK8之后调整为尾插法</strong>。</p>
<p>这里贴一个别人的分析</p>
<ul>
<li>前提条件：<ol>
<li>hash算法为简单的用key mod链表的大小。</li>
<li>最开始hash表size&#x3D;2，key&#x3D;3,7,5，则都在table[1]中。</li>
<li>然后进行resize，使size变成4。</li>
<li>未resize前的数据结构如下：</li>
</ol>
</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfecWQvk4vhdQnUBzictjvKTV8KojY8VrMVmMVK0mT4Ric2icyc3icUzVuQCuLGpzOgZxOeHd8MgfgNuXQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>如果在单线程环境下，最后的结果如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfecWQvk4vhdQnUBzictjvKTVCB9USBX1WYQPWzj7iciaTjlyHZpq2MlWRasFGPLvXEM1zf0tiaictibYSsg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>这里的转移过程，不再进行详述，只要理解transfer函数在做什么，其转移过程以及如何对链表进行反转应该不难。</p>
<p>然后在多线程环境下，假设有两个线程A和B都在进行put操作。线程A在执行到transfer函数中第11行代码处挂起，因为该函数在这里分析的地位非常重要，因此再次贴出来。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfecWQvk4vhdQnUBzictjvKTVRtdI81vOOgiayBNwiaru5saibodJiaUAxBsic9Clib8qu2SZWQd6MlokUF9g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>此时线程A中运行结果如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfecWQvk4vhdQnUBzictjvKTVCrq6iaOLPVE0kE1zgCQYmWKTUPBGAm1icoUUR8ADvhUwTLoQ0jZzBr1g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>线程A挂起后，此时线程B正常执行，并完成resize操作，结果如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfecWQvk4vhdQnUBzictjvKTVGWwiboVcEoovrdg7qUibUcwrLTuww3rbptiaFoZI11NaTj0tDAxybhwag/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p><strong>这里需要特别注意的点：由于线程B已经执行完毕，根据Java内存模型，现在newTable和table中的Entry都是主存中最新值：7.next&#x3D;3，3.next&#x3D;null。</strong></p>
<p>此时切换到线程A上，在线程A挂起时内存中值如下：e&#x3D;3，next&#x3D;7，newTable[3]&#x3D;null，代码执行过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newTable[3]=e ----&gt; newTable[3]=3</span><br><span class="line">e=next ----&gt; e=7</span><br></pre></td></tr></table></figure>

<p>此时结果如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfecWQvk4vhdQnUBzictjvKTVSPJ6RwE1NHxILdUiaIFib3NHncYPI6hfE0NvKWKu0UANfsFsWPicWKOvA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>继续循环：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e=7</span><br><span class="line">next=e.next ----&gt; next=3【从主存中取值】</span><br><span class="line">e.next=newTable[3] ----&gt; e.next=3【从主存中取值】</span><br><span class="line">newTable[3]=e ----&gt; newTable[3]=7</span><br><span class="line">e=next ----&gt; e=3</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfecWQvk4vhdQnUBzictjvKTVlVDoSg5Kvo0maS6h9RNZVRd7sMsZtu5homM7KI9ibEk47WtJXibgXfcg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></p>
<p>再次进行循环：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e=3</span><br><span class="line">next=e.next ----&gt; next=null</span><br><span class="line">e.next=newTable[3] ----&gt; e.next=7 即：3.next=7</span><br><span class="line">newTable[3]=e ----&gt; newTable[3]=3</span><br><span class="line">e=next ----&gt; e=null</span><br></pre></td></tr></table></figure>

<p>注意此次循环：e.next&#x3D;7，而在上次循环中7.next&#x3D;3，出现环形链表，并且此时e&#x3D;null循环结束。</p>
<p>结果如下：</p>
<p><strong><img src="https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZfecWQvk4vhdQnUBzictjvKTVU7APPu5l0lKpFRwBS0KFISCE1h9iarAQnv7zpXz2k9DnZPIr2AWqhiaw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="Image"></strong></p>
<p>在后续操作中只要涉及轮询hashmap的数据结构，就会在这里发生死循环，造成悲剧。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://fabian4.site/blog">Fabian Bao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://fabian4.site/blog/14375.html">https://fabian4.site/blog/14375.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://fabian4.site/blog" target="_blank">Fabian Bao</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/blog/tags/java/">java</a><a class="post-meta__tags" href="/blog/tags/%E6%BA%90%E7%A0%81/">源码</a><a class="post-meta__tags" href="/blog/tags/jdk/">jdk</a><a class="post-meta__tags" href="/blog/tags/HashMap/">HashMap</a></div><div class="post_share"><div class="social-share" data-image="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/LuciolaCruciata_ZH-CN9063767400_1920x1080.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/h3WuUjvQlqPEAzS.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/h3WuUjvQlqPEAzS.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/9yaek4PwfNoZEHF.jpg" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/9yaek4PwfNoZEHF.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blog/5986.html"><img class="prev-cover" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/HallstattAustria_PT-BR9407016733_1920x1080.jpg" onerror="onerror=null;src='/blog/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">HashMap、HashTable和ConcurrentHashMap</div></div></a></div><div class="next-post pull-right"><a href="/blog/20209.html"><img class="next-cover" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/ChefchaouenMorocco_ZH-CN6127993429_1920x1080.jpg" onerror="onerror=null;src='/blog/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">源码环境搭建</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/blog/5986.html" title="HashMap、HashTable和ConcurrentHashMap"><img class="cover" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/HallstattAustria_PT-BR9407016733_1920x1080.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-03</div><div class="title">HashMap、HashTable和ConcurrentHashMap</div></div></a></div><div><a href="/blog/20209.html" title="源码环境搭建"><img class="cover" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/ChefchaouenMorocco_ZH-CN6127993429_1920x1080.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-18</div><div class="title">源码环境搭建</div></div></a></div><div><a href="/blog/22066.html" title="Spring 中的9种设计模式"><img class="cover" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/img-c6d3a2d229d395e79da66a8feff97814.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-10</div><div class="title">Spring 中的9种设计模式</div></div></a></div><div><a href="/blog/17692.html" title="浅谈IoC和AOP"><img class="cover" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/2c3XOeVFzLdnAE1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-28</div><div class="title">浅谈IoC和AOP</div></div></a></div><div><a href="/blog/60824.html" title="Spring Bean配置——注解配Bean"><img class="cover" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/UuKkAcjq6rZzs8v.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-05</div><div class="title">Spring Bean配置——注解配Bean</div></div></a></div><div><a href="/blog/57175.html" title="Spring AOP的配置和应用"><img class="cover" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/186zIDlrCPFeuXQ.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-12</div><div class="title">Spring AOP的配置和应用</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://fabian4.site/avatar.png" onerror="this.onerror=null;this.src='/blog/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Fabian Bao</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">73</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">The best is yet to come</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">HashMap源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF-%E5%93%88%E5%B8%8C%EF%BC%8C-%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%EF%BC%88%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">一、什么是 哈希， 哈希函数（散列函数）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#object-%E4%B8%AD%E7%9A%84-hashcode-%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.1.</span> <span class="toc-text">object 中的 hashcode 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashmap-%E9%87%87%E7%94%A8%E7%9A%84%E5%93%88%E5%B8%8C%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.2.</span> <span class="toc-text">hashmap 采用的哈希方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E4%BD%99-%E5%92%8C%E4%BD%8D%E8%BF%90%E7%AE%97-amp"><span class="toc-number">1.1.3.</span> <span class="toc-text">取余 % 和位运算 &amp;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">二、存储方式和数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.3.</span> <span class="toc-text">三、构造方法和初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8B%E5%AE%B9%E9%87%8F-initialCapacity"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. 初始容量 initialCapacity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90-loadFactor"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. 负载因子 loadFactor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%E5%92%8C%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0"><span class="toc-number">1.4.</span> <span class="toc-text">四、添加元素和查找元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-put-%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.1.</span> <span class="toc-text">1. put 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-get-%E6%96%B9%E6%B3%95-%E5%92%8C-containsKey-%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.2.</span> <span class="toc-text">2. get 方法 和 containsKey 方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%89%A9%E5%AE%B9%E5%92%8Crehash"><span class="toc-number">1.5.</span> <span class="toc-text">五、扩容和rehash</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%A4%B4%E6%8F%92%E6%B3%95%E5%92%8C%E5%B0%BE%E6%8F%92%E6%B3%95"><span class="toc-number">1.6.</span> <span class="toc-text">六、头插法和尾插法</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/blog/55079.html" title="Mysql 执行流程和日志系统"><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/Hatshepsut_ZH-CN4516192627_1920x1080.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="Mysql 执行流程和日志系统"/></a><div class="content"><a class="title" href="/blog/55079.html" title="Mysql 执行流程和日志系统">Mysql 执行流程和日志系统</a><time datetime="2021-05-14T16:00:00.000Z" title="发表于 2021-05-15 00:00:00">2021-05-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/47132.html" title="Mysql 锁机制"><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/Italica_ZH-CN1692906751_1920x1080.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="Mysql 锁机制"/></a><div class="content"><a class="title" href="/blog/47132.html" title="Mysql 锁机制">Mysql 锁机制</a><time datetime="2021-04-24T16:00:00.000Z" title="发表于 2021-04-25 00:00:00">2021-04-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/10729.html" title="Mysql 隔离级别与MVCC"><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/CuscoCathedral_ZH-CN9834821723_1920x1080.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="Mysql 隔离级别与MVCC"/></a><div class="content"><a class="title" href="/blog/10729.html" title="Mysql 隔离级别与MVCC">Mysql 隔离级别与MVCC</a><time datetime="2021-04-19T16:00:00.000Z" title="发表于 2021-04-20 00:00:00">2021-04-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/58885.html" title="数据库四大性质和隔离等级"><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/ContainerShip_ZH-CN0850122021_1920x1080.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="数据库四大性质和隔离等级"/></a><div class="content"><a class="title" href="/blog/58885.html" title="数据库四大性质和隔离等级">数据库四大性质和隔离等级</a><time datetime="2021-04-07T16:00:00.000Z" title="发表于 2021-04-08 00:00:00">2021-04-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/5986.html" title="HashMap、HashTable和ConcurrentHashMap"><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/HallstattAustria_PT-BR9407016733_1920x1080.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="HashMap、HashTable和ConcurrentHashMap"/></a><div class="content"><a class="title" href="/blog/5986.html" title="HashMap、HashTable和ConcurrentHashMap">HashMap、HashTable和ConcurrentHashMap</a><time datetime="2021-04-02T16:00:00.000Z" title="发表于 2021-04-03 00:00:00">2021-04-03</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://fabian.oss-cn-hangzhou.aliyuncs.com/img/LuciolaCruciata_ZH-CN9063767400_1920x1080.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Fabian Bao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/blog/js/utils.js"></script><script src="/blog/js/main.js"></script><script src="/blog/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '98fe0206dedd0d2caf96',
      clientSecret: '5f2816f58a108f15feba46f9bc88497d3d6457a4',
      repo: 'blog',
      owner: 'fabian4',
      admin: ['fabian4'],
      id: 'cdeb82ea60604f008f3810b890b2464a',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>