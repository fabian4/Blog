<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>JVM 垃圾回收 | Fabian Bao</title><meta name="keywords" content="Java,JVM"><meta name="author" content="Fabian Bao"><meta name="copyright" content="Fabian Bao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JVM 垃圾回收">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM 垃圾回收">
<meta property="og:url" content="https://fabian4.site/blog/40208.html">
<meta property="og:site_name" content="Fabian Bao">
<meta property="og:description" content="JVM 垃圾回收">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/20210312160242.png">
<meta property="article:published_time" content="2021-02-19T16:00:00.000Z">
<meta property="article:modified_time" content="2022-08-24T07:47:19.052Z">
<meta property="article:author" content="Fabian Bao">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/20210312160242.png"><link rel="shortcut icon" href="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/202015ouknbvshlsrvbku5.jpeg.icon.png"><link rel="canonical" href="https://fabian4.site/blog/40208"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/blog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-788W4F6C1Y"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-788W4F6C1Y');
</script><script>const GLOBAL_CONFIG = { 
  root: '/blog/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JVM 垃圾回收',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-08-24 15:47:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/blog/atom.xml" title="Fabian Bao" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://fabian4.site/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">73</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/blog/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/blog/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/blog/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/blog/read/"><i class="fa-fw fa fa-book"></i><span> 阅读</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://fabian.oss-cn-hangzhou.aliyuncs.com/img/20210312160242.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/blog/">Fabian Bao</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/blog/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/blog/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/blog/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/blog/read/"><i class="fa-fw fa fa-book"></i><span> 阅读</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JVM 垃圾回收</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-02-19T16:00:00.000Z" title="发表于 2021-02-20 00:00:00">2021-02-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-08-24T07:47:19.052Z" title="更新于 2022-08-24 15:47:19">2022-08-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/blog/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>47分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JVM 垃圾回收"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/blog/40208.html#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="JVM-垃圾回收"><a href="#JVM-垃圾回收" class="headerlink" title="JVM 垃圾回收"></a>JVM 垃圾回收</h1><h2 id="一、垃圾回收概述"><a href="#一、垃圾回收概述" class="headerlink" title="一、垃圾回收概述"></a>一、垃圾回收概述</h2><h3 id="1-简述-Java-垃圾回收机制"><a href="#1-简述-Java-垃圾回收机制" class="headerlink" title="1. 简述 Java 垃圾回收机制"></a>1. 简述 Java 垃圾回收机制</h3><ul>
<li>在 Java中，我们不需要手动释放对象内存，由于 JVM的垃圾回收线程自动对没有引用的对象进行回收</li>
<li>创建对象时，GC 开始监控这个对象的地址，大小以及使用情况。</li>
<li>GC采用的有向图的方式记录和管理堆中的所有对象。通过这种方式确定哪些对象是 “可达的”， 哪些对象是 “不可达的”。当GC确定一些对象为“不可达”时，GC就有责任回收这些内存空间</li>
</ul>
<h3 id="2-垃圾回收机制"><a href="#2-垃圾回收机制" class="headerlink" title="2. 垃圾回收机制"></a>2. 垃圾回收机制</h3><ul>
<li>分代复制垃圾回收</li>
<li>标记垃圾回收</li>
<li>增量垃圾回收</li>
</ul>
<h3 id="3-什么是-Grabage"><a href="#3-什么是-Grabage" class="headerlink" title="3. 什么是 Grabage"></a>3. 什么是 Grabage</h3><ul>
<li>垃圾是指在运行程序中没有任何指针指向的这个对象，这个对象就是需要被回收的垃圾</li>
<li>如果不及时堆内存中的垃圾进行清理，那么这些垃圾对象所占据的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至肯导致内存溢出</li>
</ul>
<h3 id="4-为什么需要进行-Grabage-Collection"><a href="#4-为什么需要进行-Grabage-Collection" class="headerlink" title="4. 为什么需要进行 Grabage Collection"></a>4. 为什么需要进行 Grabage Collection</h3><ul>
<li>不进行垃圾回收，内存会消耗完。</li>
<li>碎片整理，令新对象获得连续的内存空间</li>
<li>STW的GC无法满足实际需求，需要对GC进行优化</li>
</ul>
<h3 id="5-垃圾回收器"><a href="#5-垃圾回收器" class="headerlink" title="5. 垃圾回收器"></a>5. 垃圾回收器</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>无需手动分配回收内存，降低内存泄漏，内存溢出的风险</li>
<li>没有垃圾回收器，Java也会和cpp一样，各种悬垂指针，野指针，泄露问题需要资金管理</li>
<li>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专注于业务开发</li>
</ul>
<h4 id="担忧"><a href="#担忧" class="headerlink" title="担忧"></a>担忧</h4><ul>
<li>对于 Java开发人员而言，自动管理内存就像一个黑匣子，如果过度依赖于“自动”，会弱化 Java开发人员在程序出现内存溢出定位能力和解决问题能力。</li>
<li>只有在整正了解 JVM 是如果管理内存后，我们才能够在遇见 OutOfMemoryError 时，快速地根据错误异常日志定位问题和解决问题</li>
<li>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节</li>
</ul>
<h3 id="6-GC-的作用域"><a href="#6-GC-的作用域" class="headerlink" title="6. GC 的作用域"></a>6. GC 的作用域</h3><ul>
<li><p>垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收，其中，Java堆是垃圾回收器的工作重点</p>
</li>
<li><p>次数层面</p>
<ul>
<li>频繁收集年轻代</li>
<li>较少收集老年代</li>
<li>基本不收集永久代（元空间 matespace）</li>
</ul>
</li>
<li><p>GC 主要关注于方法区和堆中的垃圾收集</p>
<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210313163015243.png" alt="image-20210313163015243" style="zoom:50%;" /></li>
</ul>
<h2 id="二、垃圾回收相关算法"><a href="#二、垃圾回收相关算法" class="headerlink" title="二、垃圾回收相关算法"></a>二、垃圾回收相关算法</h2><h3 id="1-标记阶段what：判断对象是否存活"><a href="#1-标记阶段what：判断对象是否存活" class="headerlink" title="1. 标记阶段what：判断对象是否存活"></a>1. 标记阶段what：判断对象是否存活</h3><ul>
<li>堆存放：几乎所有的Java对象实例</li>
<li>GC执行只回收死亡对象，释放其所占用的内存空间</li>
<li>标记死亡对象：当一个对象不再被存活对象引用时</li>
<li>两种方式：引用计数算法、可达性分析</li>
</ul>
<h3 id="2-引用计数法"><a href="#2-引用计数法" class="headerlink" title="2. 引用计数法"></a>2. 引用计数法</h3><p>每个对象上保证整形的引用计数属性，有对象引用计数器加一，减少引用计数器减一。计数器为零时，进行垃圾回收。</p>
<ul>
<li><p>优点：实现简单、垃圾对象易识别、判定效率高、回收没有延迟性</p>
</li>
<li><p>缺点：循环引用问题</p>
<p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210313164046996.png" alt="image-20210313164046996"></p>
</li>
</ul>
<h3 id="3-标记阶段：可达性分析算法（根据搜索算法、追踪性垃圾收集）"><a href="#3-标记阶段：可达性分析算法（根据搜索算法、追踪性垃圾收集）" class="headerlink" title="3. 标记阶段：可达性分析算法（根据搜索算法、追踪性垃圾收集）"></a>3. 标记阶段：可达性分析算法（根据搜索算法、追踪性垃圾收集）</h3><ul>
<li>解决循环引用问题，防止内存溢出</li>
</ul>
<blockquote>
<p>跟对象集合为起点，向下搜索直接或间接连接的对象为存活对象</p>
<p>无法建立连接，即不可达对象标记为可回收对象</p>
</blockquote>
<h4 id="GC-Roots-可以是哪些元素"><a href="#GC-Roots-可以是哪些元素" class="headerlink" title="GC Roots 可以是哪些元素"></a>GC Roots 可以是哪些元素</h4><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210313170717208.png" alt="image-20210313170717208" style="zoom:50%;" />

<ul>
<li>虚拟机栈中引用的对象，比如：各个线程被调用的方法中使用到的参数，局部变量等</li>
<li>本地方法栈内 JNI（通常说本地方法）引用的对象方法区中类静态属性引用的对象，比如：Java类的引用类型静态变量</li>
<li>方法区中常量引用的对象，比如：字符串常量池（StringTable）里的引用</li>
<li>所有被同步锁 synchronized 持有的对象</li>
<li>Java 虚拟机内部的引用</li>
<li>基本数据类型对应的 Class 对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器</li>
<li>反映 Java 虚拟机内部情况的 JMXBean、JVMTI中注册的回调、本地代码缓存</li>
</ul>
<h4 id="关于-GC-Roots"><a href="#关于-GC-Roots" class="headerlink" title="关于 GC Roots"></a>关于 GC Roots</h4><ul>
<li>除了堆空间外的一些结构，比如：虚拟机栈、本地方法栈、方法区、字符串常量池等地方堆堆空间的引用，都可以作为GC Roots进行可达性分析</li>
<li>除了这些固定的GC Roots集合以外，根据用户所选的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收</li>
<li>如果只针对 Java堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己实现细节，更不是孤立封闭，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才有可能保证可达性分析的准确性</li>
</ul>
<blockquote>
<p>由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root</p>
</blockquote>
<h4 id="可达性分析算法的注意事项"><a href="#可达性分析算法的注意事项" class="headerlink" title="可达性分析算法的注意事项"></a>可达性分析算法的注意事项</h4><ul>
<li>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结构的准确性就无法保证</li>
<li>一致性 –&gt; 准确性</li>
<li>这点也是导致 GC 进行时必须 “Stop the World”的一个重要原因。即使号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的</li>
<li>枚举根节点停顿</li>
</ul>
<h4 id="关于永生代"><a href="#关于永生代" class="headerlink" title="关于永生代"></a>关于永生代</h4><ul>
<li>垃圾回收不会发生在永久代</li>
<li>如果永久代满或超过设定阈值，会触发 Full GC （堆+方法区）</li>
<li>查看垃圾回收器的输出信息，也发现永久代也是被回收的</li>
<li>避免Full GC：设置永久代大小，Java8：从永久代到元数据区（本地内存区）</li>
</ul>
<h4 id="对象的-finalization-机制"><a href="#对象的-finalization-机制" class="headerlink" title="对象的 finalization 机制"></a>对象的 finalization 机制</h4><ul>
<li><p>对象销毁前的回调函数</p>
<ol>
<li>Java语言提供了对象终止机制来运行开发人员提供对象被销毁之前的自定义处理逻辑</li>
<li>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize() 方法</li>
<li>finalize() 方法允许在子类被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理工作，比如关闭文件，套接字和数据库连接等</li>
</ol>
</li>
<li><p>finalize() 方法使用的注意事项</p>
<ol>
<li>永远不要主动调用某个对象的 finalize() 方法，应该交给垃圾回收机制调用<ul>
<li>在 finalize()时可能会导致对象复活</li>
<li>finalize() 方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则 finalize() 方法将没有执行机会</li>
<li>因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收</li>
</ul>
</li>
<li>一个糟糕的 finalize() 会验证影响 GC 性能</li>
<li>从功能上来说，finalize() 方法与 C++ 中的析构函数比较相似，但是 Java采用的是基于垃圾回收器的自动内存管理机制，所以 finalize() 方法在本质上不同于 C++ 中的析构函数</li>
</ol>
</li>
<li><p>由于 finalize() 方法的存在，虚拟机中的对象有三种可能的状态</p>
<ol>
<li>可触及：从根节点开始，可以到达这个对象</li>
<li>可复活：对象的所有引用都被释放，但是对象有可能在 finalize() 中复活</li>
<li>不可触及：对象的 finalize() 被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为 finalize() 只会被调用一次</li>
</ol>
</li>
<li><p>finalize() 具体执行过程</p>
<ol>
<li><p>判定一个对象 objA 是否可回收，至少要经过两次标记过程</p>
</li>
<li><p>如果对象 objA 到 GC Roots 没有引用链，则进行一次标记</p>
</li>
<li><p>进行筛选，判断此对象是否有必要执行 finalize() 方法</p>
<ul>
<li>如果没有重写 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA 被判定为不可触及的</li>
<li>如果对象 objA 重写了 finalize() 方法，且还未执行过，那么 objA 会被插入到 F-Queue 队列中，由一个虚拟机自动创建的、低优先级的 Finalizer 线程触发其 finalize() 方法执行</li>
</ul>
</li>
<li><p>finalize() 方法是对象逃脱死亡的最后机会，稍后 GC 会对 F-Queue 队列中的对象进行第二次标记。如果 objA 在 finalize() 方法中与引用链上任何一个对象建立了联系，那么在第二次标记时，objA 会被移除 “即将回收”集合</p>
</li>
<li><p>之后，对象会再次出现没有引用内存的情况，在这个情况下，finalize() 方法不会被再次调用，对象会直接变成不可触及的状态</p>
<blockquote>
<p>一个对象的 finalize() 方法只会被调用一次</p>
</blockquote>
</li>
</ol>
</li>
<li><p>GC Roots 溯源</p>
<ul>
<li>MAT (Memory Analyzer)：一款功能强大的 Java堆内存分析器，用于查找内存泄漏以及查看内存消耗情况。基于Eclipse开发，是一款免费的性能分析工具</li>
<li>使用 JVisualVM 捕捉 heap dump</li>
<li>使用 JProfiler 进行 GC Roots 溯源</li>
<li>JProfiler 分析 OOM</li>
</ul>
</li>
<li><p>清除阶段：当成功区分出内存中存活对象和死亡对象后，GC 接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够可用的内存空间为新对象分配内存。目前在JVM中比较常见的三种垃圾收集算法</p>
<ul>
<li>标记-清除算法</li>
<li>复制算法</li>
<li>标记压缩算法</li>
<li>(分代算法)</li>
</ul>
</li>
<li><p>清除阶段：标记-清除算法</p>
<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210313203841538.png" alt="image-20210313203841538" style="zoom: 67%;" />

<ul>
<li><p>执行过程</p>
<p>当堆中的有效内存空间被耗尽时，就会停止整个程序，然后进行两项工作：标记、清除</p>
<ol>
<li>标记：Collector从根节点开始遍历，标记所有被引用的对象，一般是在对象的 Header 中记录为可达对象</li>
<li>清除：Collector对堆内存从头到尾进行线性遍历，如果发现某个对象在其 Header 中没有标记为可达对象，则将其回收</li>
</ol>
</li>
<li><p>清除对象的方式</p>
<ol>
<li><p>把需要清除的对象地址保存在空闲地址列表。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够就存放并覆盖原有地址</p>
</li>
<li><p>如果内存规整，采用指针碰撞的方式</p>
<blockquote>
<p>如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新分配在第一个空闲内存的位置上，这种分配方式叫做指针碰撞</p>
</blockquote>
</li>
<li><p>如果内存不规整，虚拟机需要维护一个空闲列表，采用空闲列表分配内存</p>
</li>
</ol>
</li>
<li><p>标记-清除算法缺点</p>
<ol>
<li>效率不高</li>
<li>在进行 GC 时，需要停止整个应用程序，用户体验差</li>
<li>空闲内存不连续，产生内碎片</li>
<li>需要维护一个空闲列表</li>
</ol>
</li>
</ul>
</li>
<li><p>清除阶段：复制算法</p>
<ul>
<li><p>将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</p>
</li>
<li><p>Eden区，from区，to区的复制算法</p>
<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210313205517137.png" alt="image-20210313205517137" style="zoom: 50%;" />
</li>
<li><p>复制算法优点</p>
<ol>
<li>没有标记和清除过程，实现简单，运行高效</li>
<li>复制过去以后保证空间连续性，不会出现碎片问题</li>
</ol>
</li>
<li><p>复制算法缺点</p>
<ol>
<li>需要两倍内存空间</li>
<li>对于G1这种分拆成大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，内存占用，时间开销都很大</li>
</ol>
</li>
<li><p>综上：<strong>适合垃圾对象多，存活对象很少的场景</strong>， 例如：Young区的Survivor0和Survivor1区</p>
</li>
</ul>
</li>
<li><p>清除阶段：标记-压缩算法（标记-整理、Mark-Compact）</p>
<ul>
<li><p>标记-清除算法：老年代，会产生大量碎片</p>
</li>
<li><p>复制算法针对：新生代，存活对象少，垃圾对象多。不适于老年代，大量存活对象</p>
</li>
<li><p>标记-压缩算法的执行流程</p>
<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210313210404445.png" alt="image-20210313210404445" style="zoom: 67%;" />

<ul>
<li>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</li>
<li>第二阶段将所有存活对象压缩到内存一端，按顺序排放。之后，清理边界外所有空间</li>
</ul>
</li>
<li><p>优点</p>
<ol>
<li>消除了标记-清除算法当中，内存区域分散的特点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。</li>
<li>消除了复制算法当中，内存减半的高额代价</li>
</ol>
</li>
<li><p>缺点</p>
<ol>
<li>从效率上来说，标记-整理算法要低于复制算法。</li>
<li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</li>
<li>移动过程中，需要全暂停用户应用程序。即STW</li>
</ol>
</li>
</ul>
</li>
<li><p>对比三种清除阶段算法（没有最好的，只有最适合的算法）</p>
<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210313211045543.png" alt="image-20210313211045543" style="zoom:50%;" />
</li>
<li><p>分代收集算法</p>
<ul>
<li><p>年轻代</p>
<ul>
<li>区域相对老年代较小，对象生命周期短、存活率低，回收频繁</li>
<li>这种情况复制算法时回收整理，速度是最快的。复制算法的效率之和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解</li>
</ul>
</li>
<li><p>老年代</p>
<ul>
<li>区域较大，对象生命周期长，存活率高，回收不及年轻代频繁</li>
<li>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-整理的混合实现<ul>
<li>Mark 阶段的开销与存活对象的数量成正比</li>
<li>Sweep 阶段的开销与所管理区域的大小成正比</li>
<li>Compact 阶段的开销与存活对象的数据成正比</li>
</ul>
</li>
</ul>
</li>
<li><p>HotSpot CMS 回收器</p>
<ul>
<li>以 HotSpot 中的CMS回收器为例，CMS是基于Mark-Sweep实现，对于对象的回收效率很高</li>
<li>对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致 Concurrent Mode Failure时），将采用 Serial Old执行 Full GC 以达到堆老年代内存的整理</li>
</ul>
</li>
<li><p>增量收集算法</p>
<ul>
<li>上述现有的算法，在垃圾回收过程中，应用软件将处于一种 Stop The World 的状态。在 STW 状态下，应用程序所有线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成</li>
<li>如果垃圾回收时间过长，应用程序就会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集算法的诞生</li>
<li>基本思想<ul>
<li>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成</li>
<li>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</li>
</ul>
</li>
<li>优缺点<ul>
<li>使用这种方式，由于在垃圾回收的过程中，间接性还执行了应用程序代码，所以能减少系统的停顿时间</li>
<li>但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量下降</li>
</ul>
</li>
</ul>
</li>
<li><p>分区算法</p>
<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210313214651632.png" alt="image-20210313214651632" style="zoom:67%;" />

<ul>
<li>一般来说，在相同条件下，堆空间越大，一次 GC 时所需要的时间就越长，有关 GC 产生的停顿也越长</li>
<li>为了更好的控制GC产生的停顿时间，将一块大的区域风格成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿</li>
<li>分代算法间按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="三、垃圾回收相关概念"><a href="#三、垃圾回收相关概念" class="headerlink" title="三、垃圾回收相关概念"></a>三、垃圾回收相关概念</h2><h3 id="1-System-gc-的理解"><a href="#1-System-gc-的理解" class="headerlink" title="1. System.gc() 的理解"></a>1. System.gc() 的理解</h3><ul>
<li>在默认情况下，通过 System.gc() 或者 Runtime.getRuntime().gc() 的调用会显式触发 Full GC，同时对新生代老年代进行回收，尝试释放被丢弃对象的占用空间</li>
<li>System.gc() 调用无法保证对垃圾收集器的调用（不能确保立即生效）</li>
<li>JVM 实现者可以通过 System.gc() 调用来决定 JVM 的 GC 行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦</li>
<li>在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用 System.gc()</li>
</ul>
<h3 id="2-内存溢出-OutOfMemoryError"><a href="#2-内存溢出-OutOfMemoryError" class="headerlink" title="2. 内存溢出 OutOfMemoryError"></a>2. 内存溢出 OutOfMemoryError</h3><ul>
<li><p>应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度</p>
</li>
<li><p>GC 年轻代老年代的垃圾回收 –&gt; 内存不足 –&gt; 独占式 Full GC 操作 –&gt; 回收大量内存 –&gt; 供应用程序继续使用</p>
</li>
<li><p>Javadoc中对OOM的解释：没有空闲的内存，并且垃圾收集器也无法提供更多内存</p>
<ul>
<li><p>Java虚拟机的堆内存设置不够</p>
<ul>
<li>可能存在内存泄漏问题；也可能是堆的大小设计不合理，比如要处理比较可观的数量，但没有显式指定 JVM 堆大小或指定数值偏小</li>
<li>调整参数 -Xms、-Xmx</li>
</ul>
</li>
<li><p>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</p>
<ul>
<li>对于老版本 Oracle JDK，因为永久代大小有限，并且 JVM 对永久代垃圾回收非常不积极，所以当我们不断添加新类型时，永久代出现OutOfMemoryError</li>
<li>运行时存在大量动态类型生成的场合：类似 intern 字符串缓存占用太多空间，也会导致 OOM 问题</li>
<li>异常信息，会标记出永久代相关：java.lang.OutOfMemoryError:PermGenspace</li>
<li>元数据区，本地内存，异常信息：java.lang.OutOfMemoryError:Metaspace。直接内存不足，也会导致 OOM</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-内存泄漏"><a href="#3-内存泄漏" class="headerlink" title="3. 内存泄漏"></a>3. 内存泄漏</h3><ul>
<li><p>不再被使用的对象或变量一直占据在内存中，但GC又不能回收</p>
</li>
<li><p>内存泄漏，程序不会立即崩溃，耗尽内存，最终出现 OutOfMemory 异常，导致程序崩溃</p>
</li>
<li><p>存储空间：虚拟内存大小，取决于磁盘交换区设定的大小</p>
</li>
<li><p>导致内存泄漏的原因：长生命周期对象持有短生命周期对象的引用</p>
</li>
<li><p>内存泄漏举例</p>
  <img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210314104850907.png" alt="image-20210314104850907" style="zoom:50%;" />

<ul>
<li><p>左边的图：Java使用可达性分析算法，最上面的数据不可达，需要被回收</p>
<p>右边的图：后期一些短生命周期对象不用，应断开引用，但长生命周期对象持有引用，导致短生命周期对象无法回收</p>
</li>
<li><p>单例模式：单例的生命周期和应用程序一样长，所以在单例程序中，若持有对外部对象的引用，那么这个外部对象不能被回收，导致内存泄漏</p>
</li>
<li><p>一些提供部分 close() 的资源未关闭导致内存泄漏</p>
</li>
</ul>
</li>
</ul>
<h3 id="4-Stop-The-World"><a href="#4-Stop-The-World" class="headerlink" title="4. Stop The World"></a>4. Stop The World</h3><ul>
<li>GC 事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为 STW</li>
<li>可达性分析算法中枚举根节点 会导致所有 Java执行线程停顿<ul>
<li>分析工作必须在一个能确保一致性的快照中进行</li>
<li>一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li>
<li>如果出现分析过程中对象引用关系还在不断变化，则分析结构的准确性无法保证</li>
</ul>
</li>
<li>被STW中断的应用程序会在完成GC之后恢复，频繁中断令用户体验差，需要减少STW的发生</li>
<li>STW事件和采用哪款GC无关，所有的GC都有这个事件</li>
<li>哪怕时G1也不能完全避免STW，只能说回收效率越来越高，尽可能缩短了暂停时间</li>
<li>STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的线程全部停掉</li>
<li>开发中不要用 System.gc()，会导致 STW的发生</li>
</ul>
<h3 id="5-垃圾回收的并行与并发"><a href="#5-垃圾回收的并行与并发" class="headerlink" title="5. 垃圾回收的并行与并发"></a>5. 垃圾回收的并行与并发</h3><ul>
<li><p>并发</p>
<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210314110439921.png" alt="image-20210314110439921" style="zoom:50%;" />

<ul>
<li>在操作系统中，是指一个时间段有几个常响都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行</li>
<li>并发不是真正意义上的 同时进行，只是CPU把一个时间段划分成几个时间片段，然后在这几个时间片段之间来回切换</li>
<li>由于 CPU 处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应该程序同时正在进行</li>
</ul>
</li>
<li><p>并行</p>
<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210314111651774.png" alt="image-20210314111651774" style="zoom:50%;" />

<ul>
<li>当一个系统有两个以上CPU时，当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程不抢占CPU资源，可以同时进行，我们称之为并行</li>
<li>决定并行的因素不是CPU的数量，而是CPU核心数量，比如一个CPU多个核也可以并行</li>
</ul>
</li>
<li><p>并行与并发对比</p>
<ul>
<li>并发的是多个任务相互抢占资源，并行的多个任务之前不相互抢占资源</li>
<li>只有在多CPU或者一个CPU多核的情况中才会发生并行，否则，看似同时发生是事情其实都是并发执行</li>
</ul>
</li>
<li><p>垃圾回收的并行与串行</p>
<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210314112807100.png" alt="image-20210314112807100" style="zoom:50%;" />

<ul>
<li>并行：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态</li>
<li>串行：相比较于并行概念，单线程执行，如果内存不够，则程序暂停，启动 JVM 垃圾回收器进行垃圾回收</li>
</ul>
</li>
<li><p>垃圾回收的并发</p>
<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210314113025875.png" alt="image-20210314113025875" style="zoom:50%;" />

<ul>
<li>指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行</li>
<li>比如用户程序在继续运行，而垃圾收集器线程运行于另一个CPU上</li>
<li>典型垃圾回收器：CMS、G1</li>
</ul>
</li>
</ul>
<h3 id="6-安全点与安全区域"><a href="#6-安全点与安全区域" class="headerlink" title="6. 安全点与安全区域"></a>6. 安全点与安全区域</h3><h4 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h4><ul>
<li>程序执行时并非在所有地方都能停下来GC，只有在特定位置才能停顿下来开始 GC，这些位置称为 安全点</li>
<li>安全点的选择很重要，如果太少可能会导致GC等待时间太长，如果太频繁可能导致运行时的性能问题</li>
<li>大部分指令执行时间都非常短暂，通常会根据 **是否具有让程序长时间执行的特征 **为标准，如：选择一些执行时间较长的指令作为 安全点，如方法调用、循环跳转和异常跳转</li>
</ul>
<h4 id="安全点中断实现方式"><a href="#安全点中断实现方式" class="headerlink" title="安全点中断实现方式"></a>安全点中断实现方式</h4><ul>
<li>主动式中断：设置一个中断标志，各个线程运行到安全点的适合就会主动轮询这个标志，如果标志为真，则将自己进行中断挂起</li>
</ul>
<h4 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h4><ul>
<li>安全点 机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的 安全点，但是程序不执行的时候呢？</li>
<li>例如线程处于 Sleep状态或者 Blocked状态，这时候线程无法响应 JVM 的中断请求，走到安全点区挂起中断，JVM也不太可能等待线程被唤醒</li>
<li>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域的任何位置开始 GC 都是安全的。我们也可以把 安全区看作是被扩展了的 安全点</li>
</ul>
<h4 id="安全区域是执行流程"><a href="#安全区域是执行流程" class="headerlink" title="安全区域是执行流程"></a>安全区域是执行流程</h4><ul>
<li>当线程运行到 安全区域 的代码时，首先标识已经进入了 安全区，如果这段时间内发生GC，JVM会忽略标识为安全区状态的线程</li>
<li>当线程即将离开 安全区时，会检查 JVM 是否已经完成 GC，如果完成了，则继续运行。否则线程必须等待直到收到可以安全离开安全区的信号为止</li>
</ul>
<h2 id="四、垃圾回收器"><a href="#四、垃圾回收器" class="headerlink" title="四、垃圾回收器"></a>四、垃圾回收器</h2><h3 id="1-垃圾回收器分类"><a href="#1-垃圾回收器分类" class="headerlink" title="1. 垃圾回收器分类"></a>1. 垃圾回收器分类</h3><ul>
<li><p>按线程数分（垃圾回收线程数），可以分为串行垃圾回收器和并行垃圾回收器</p>
<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210314115156102.png" alt="image-20210314115156102" style="zoom:50%;" />

<ul>
<li><p>串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。</p>
</li>
<li><p>并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-the-World”机制。</p>
<blockquote>
<p>适用场景</p>
<ul>
<li>在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的Client模式下的JVM中</li>
<li>在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器</p>
<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210314115510806.png" alt="image-20210314115510806" style="zoom:50%;" />

<ul>
<li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间</li>
<li>独占式垃圾回收器（Stop the World）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束</li>
</ul>
</li>
<li><p>按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器。</p>
<ul>
<li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片，分配对象空间使用指针碰撞</li>
<li>非压缩式的垃圾回收器不进行这步操作，分配对象空间使用空闲列表</li>
</ul>
</li>
<li><p>按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器。</p>
</li>
</ul>
<h3 id="2-评估-GC-的性能指标"><a href="#2-评估-GC-的性能指标" class="headerlink" title="2. 评估 GC 的性能指标"></a>2. 评估 GC 的性能指标</h3><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>运行用户代码的时间占总运行时间的比例（总运行时间 &#x3D; 程序的运行时间 + 内存回收的时间）</p>
<ul>
<li><p>虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%</p>
</li>
<li><p>吞吐量优先，意味着在单位时间内，STW的时间最短</p>
</li>
<li><p>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快</p>
</li>
<li><p>因为如果选择以吞吐量优先，那么必然需要降低内存回收的执行频率，但是这样会导致GC需要更长的暂停时间来执行内存回收</p>
</li>
<li><p>若吞吐量低，50%用于执行程序，50%用于垃圾回收，程序执行会很久</p>
<h4 id="暂停时间"><a href="#暂停时间" class="headerlink" title="暂停时间"></a>暂停时间</h4><p>是指一个时间段内应用程序线程暂停，让GC线程执行的状态</p>
<ul>
<li>GC期间100毫秒的暂停时间意味着在这100毫秒期间内没有应用程序线程是活动的</li>
<li>暂停时间优先，意味着尽可能让单次STW的时间最短</li>
<li>低暂停时间（低延迟）较好，因为从最终用户的角度来看，不管是GC还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，有时候甚至短暂的200毫秒暂停都可能打断终端用户体验。因此，具有较低的暂停时间是非常重要的，特别是对于一个交互式应用程序。</li>
<li>如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也只能频繁地执行内存回收，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</li>
</ul>
</li>
</ul>
<blockquote>
<p>一个GC算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。现在标准：在最大吞吐量优先的情况下，降低停顿时间</p>
</blockquote>
<blockquote>
<ul>
<li>内存占用：Java堆区所占的内存大小。</li>
<li>垃圾收集开销：垃圾收集所用时间与总运行时间的比例。</li>
<li>收集频率：相对于应用程序的执行，收集操作发生的频率。</li>
<li>快速：一个对象从诞生到被回收所经历的时间。</li>
</ul>
</blockquote>
<h3 id="3-7种经典的垃圾收集器"><a href="#3-7种经典的垃圾收集器" class="headerlink" title="3. 7种经典的垃圾收集器"></a>3. 7种经典的垃圾收集器</h3><ul>
<li><p>串行回收器：Serial、Serial old</p>
</li>
<li><p>并行回收器：ParNew、Parallel Scavenge、Parallel old</p>
</li>
<li><p>并发回收器：CMS、G1</p>
</li>
<li><p>分代</p>
<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210314120149313.png" alt="image-20210314120149313" style="zoom:50%;" />
</li>
<li><p>如何选择垃圾回收器</p>
</li>
<li><p>针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</p>
</li>
<li><p>如何查看默认垃圾收集器</p>
<ul>
<li>-XX:+PrintCommandLineFlags：查看命令行相关参数（包含使用的垃圾收集器）</li>
<li>使用命令行指令：jinfo -flag 相关垃圾回收器参数 进程ID</li>
</ul>
</li>
</ul>
<h4 id="串行垃圾回收器"><a href="#串行垃圾回收器" class="headerlink" title="串行垃圾回收器"></a>串行垃圾回收器</h4><ul>
<li><p>Serial  GC（年轻代  Client模式）：复制算法、串行回收、”Stop-the-World”机制</p>
</li>
<li><p>Serial Old GC（老年代 Client模式）：标记-压缩算法、串行回收和”Stop the World”机制</p>
<ul>
<li>Server模式下</li>
<li>与新生代的Parallel Scavenge配合使用</li>
<li>作为老年代CMS收集器的后备垃圾收集方案</li>
</ul>
</li>
<li><p>特点</p>
<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210314120716108.png" alt="image-20210314120716108" style="zoom:50%;" />

<ul>
<li>它只会使用一个CPU或一条收集线程去完成垃圾收集工作<br>限定单个CPU环境：省去切换线程的开销</li>
<li>在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束（STW）</li>
</ul>
</li>
<li><p>-XX:+UseSerialGC：指定年轻代和老年代都使用串行收集器</p>
</li>
</ul>
<h4 id="ParNew-回收器：年轻代（Parallel-New）复制、并行、STW"><a href="#ParNew-回收器：年轻代（Parallel-New）复制、并行、STW" class="headerlink" title="ParNew 回收器：年轻代（Parallel New）复制、并行、STW"></a>ParNew 回收器：年轻代（Parallel New）复制、并行、STW</h4><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210314120737438.png" alt="image-20210314120737438" style="zoom:50%;" />

<ul>
<li>区别Serial GC：是否并行</li>
<li>新生代：回收次数频繁，使用并行方式高效</li>
<li>老年代：回收次数少，使用串行方式节省资源（切换线程）</li>
<li>适用范围<ul>
<li>ParNew收集器运行在多CPU的环境下，可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</li>
<li>单CPU：Serial GC</li>
</ul>
</li>
<li>设置 ParNew 垃圾回收器<ul>
<li>-XX:+UseParNewGC：指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代</li>
<li>-XX:ParallelGCThreads：限制线程数量，默认开启和CPU相同线程数</li>
</ul>
</li>
</ul>
<h4 id="Parallel-Scavenge-回收器：吞吐量优先、复制并行STW、server模式、Java8默认"><a href="#Parallel-Scavenge-回收器：吞吐量优先、复制并行STW、server模式、Java8默认" class="headerlink" title="Parallel Scavenge 回收器：吞吐量优先、复制并行STW、server模式、Java8默认"></a>Parallel Scavenge 回收器：吞吐量优先、复制并行STW、server模式、Java8默认</h4><ul>
<li><p>区别ParNew</p>
<ul>
<li>Parallel Scavenge收集器的目标：达到一个可控制的吞吐量</li>
<li>自适应调节策略</li>
</ul>
</li>
<li><p>适用范围</p>
<ul>
<li>高吞吐量可以高效率利用CPU时间，尽快完成程序的运算任务，主要适用于后台运算而不需要太多交互任务。因此，常见在服务器环境中使用。例如，执行批量处理、订单处理、工资支付、科学计算的应用程序。</li>
</ul>
</li>
<li><p>Parallel Old GC：标记-压缩、并行、STW、Java8默认</p>
  <img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210314121144215.png" alt="image-20210314121144215" style="zoom:50%;" />
</li>
<li><p>Parallel Scavenge 回收器参数设置</p>
<ul>
<li>-XX:+UseParallelGC ：指定年轻代使用Parallel并行收集器执行内存回收任务</li>
<li>-XX:+UseParallelOldGC：指定老年代使用并行回收收集器</li>
<li>默认jdk8开启。默认开启一个，另一个也会被开启。（互相激活）</li>
<li>-XX:ParallelGCThreads：设置年轻代并行收集器的线程数<ul>
<li>默认情况下，当CPU数量小于8个，ParallelGCThreads的值等于CPU数量</li>
<li>当CPU数量大于8个，ParallelGCThreads的值等于3+[5*CPU_Count]&#x2F;8]</li>
<li>避免过多的线程数影响垃圾收集性能</li>
</ul>
</li>
</ul>
</li>
<li><p>-XX:MaxGCPauseMillis：设置垃圾收集器最大停顿时间（即STW的时间）单位：毫秒</p>
<ul>
<li>为了尽可能地把停顿时间控制在XX:MaxGCPauseMillis 以内，收集器在工作时会调整Java堆大小或者其他一些参数</li>
<li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。该参数使用需谨慎</li>
</ul>
</li>
<li><p>-XX:GCTimeRatio：垃圾收集时间占总时间的比例，用于衡量吞吐量的大小</p>
<ul>
<li>取值范围(0, 100)。默认值99，也就是垃圾回收时间占比不超过1。等于 1 &#x2F; (N+1) </li>
<li>与前一个-XX:MaxGCPauseMillis参数有一定矛盾性</li>
<li>STW暂停时间越长，Radio参数就容易超过设定的比例</li>
</ul>
</li>
<li><p>-XX:+UseAdaptiveSizePolicy ：设置Parallel Scavenge收集器具有自适应调节策略</p>
<ul>
<li>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，来达到在堆大小、吞吐量和停顿时间之间的平衡点。</li>
<li>在手动调优比较困难的场合，可以直接使用这种自适应方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMillis），让虚拟机自己完成调优工作</li>
</ul>
</li>
</ul>
<h4 id="CMS-垃圾回收器"><a href="#CMS-垃圾回收器" class="headerlink" title="CMS 垃圾回收器"></a>CMS 垃圾回收器</h4><ul>
<li><p>CMS 回收器（Concurrent-Mark-Sweep）：标记-清除、并发、低延迟（STW）、老年代、客户端</p>
<ul>
<li><p>第一次实现了让垃圾收集线程与用户线程同时工作</p>
</li>
<li><p>匹配：ParNew、Serial GC 无法匹配：Parallel Scavenge</p>
</li>
<li><p>CMS 工作原理</p>
<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210314122244430.png" alt="image-20210314122244430" style="zoom:50%;" />

<ul>
<li>初始标记（Initial-Mark）阶段：STW<br>程序中所有的工作线程都将会因为“Stop-the-World”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出GC Roots能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。</li>
<li>并发标记（Concurrent-Mark）阶段<br>从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。</li>
<li>重新标记（Remark）阶段：STW<br> 由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，并且也会导致“Stop-the-World”的发生，但也远比并发标记阶段的时间短</li>
<li>并发清除（Concurrent-Sweep）阶段<br>此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="CMS-特点与弊端分析"><a href="#CMS-特点与弊端分析" class="headerlink" title="CMS 特点与弊端分析"></a>CMS 特点与弊端分析</h4><ul>
<li>最耗时：并发标记、并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的</li>
<li>由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用–&gt;堆内存使用率达到某一阈值时，便开始进行回收</li>
<li>CMS运行期间预留的内存无法满足程序需求：出现“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用Serial old收集器来重新进行老年代的垃圾收集，这样停顿时间更长</li>
<li>并发清楚阶段：标记-清除算法、内存碎片、×指针碰撞技术、空闲列表执行内存分配</li>
<li>未用标签-压缩算法原因：<ul>
<li>并发清除时，用Compact整理内存，原来的用户线程使用的内存无法使用</li>
<li>需要 STW</li>
</ul>
</li>
</ul>
<blockquote>
<p>缺点总结：</p>
<ul>
<li>内存碎片–&gt;分配大对象–&gt;提前触发 Full GC</li>
<li>占用一部分线程–&gt;导致应用程序变慢，总吞吐量降低</li>
<li>无法处理浮动垃圾–&gt;Concurrent Mode Failure–&gt;Full GC<ul>
<li>在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，从而只能在下一次执行GC时释放这些之前未被回收的内存空间。</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="CMS-参数配置"><a href="#CMS-参数配置" class="headerlink" title="CMS 参数配置"></a>CMS 参数配置</h4><ul>
<li>-XX:+UseConcMarkSweepGC：手动指定使用CMS收集器执行内存回收任务。<br>开启该参数后会自动将-XX:+UseParNewGC打开。即：ParNew（Young区）+CMS（Old区）+Serial Old（Old区备选方案）的组合。</li>
<li>-XX:CMSInitiatingOccupanyFraction：设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。<ul>
<li>JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次CMS回收。JDK6及以上版本默认值为92%</li>
<li>如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。</li>
<li>反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Full GC的执行次数。</li>
</ul>
</li>
<li>-XX:+UseCMSCompactAtFullCollection：用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</li>
<li>-XX:CMSFullGCsBeforeCompaction：设置执行多少次Full GC后对内存空间进行压缩整理</li>
<li>-XX:ParallelCMSThreads：设置CMS的线程数</li>
</ul>
<blockquote>
<p>如何选择垃圾回收器？</p>
<ul>
<li>最小化地使用内存和并行开销：Serial GC</li>
<li>最大化应用程序的吞吐量：Parallel Scavenge GC</li>
<li>最小化GC的中断或停顿时间：CMS  GC</li>
</ul>
</blockquote>
<h4 id="G1-回收器"><a href="#G1-回收器" class="headerlink" title="G1 回收器"></a>G1 回收器</h4><p>区域化分代式（Garbage-First）复制算法、并行并发兼具、面向服务端</p>
<ul>
<li><p>目标：在延迟可控的情况下获得尽可能高的吞吐量</p>
</li>
<li><p>并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW</p>
</li>
<li><p>并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</p>
</li>
<li><p>分代收集</p>
<ul>
<li><p>区分年轻代和老年代，年轻代依然有Eden区和Survivor区</p>
</li>
<li><p>但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是物理连续的，也不再坚持固定大小和固定数量。</p>
<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210314122915131.png" alt="image-20210314122915131" style="zoom:50%;" /></li>
</ul>
</li>
<li><p>可预测的停顿时间模型</p>
<ul>
<li>设定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</li>
<li>G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li>
<li>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率</li>
</ul>
</li>
<li><p>G1 回收器的缺点</p>
<ul>
<li>用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（overload）都要比CMS要高。</li>
<li>从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间。</li>
</ul>
</li>
<li><p>G1 参数配置</p>
<ul>
<li>-XX:+UseG1GC：手动指定使用G1垃圾收集器执行内存回收任务</li>
<li>-XX:G1HeapRegionSize：设置每个Region的大小<br>​值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1&#x2F;2000</li>
<li>-XX:MaxGCPauseMillis：设置期望达到的最大GC停顿时间指标，默认值：200ms</li>
<li>-XX:+ParallelGCThread：设置STW工作线程数。最多设置为8</li>
<li>-XX:ConcGCThreads：设置并发标记的线程数<br>​将n设置为并行垃圾回收线程数（ParallelGcThreads）的1&#x2F;4左右</li>
<li>-XX:InitiatingHeapOccupancyPercent：设置触发并发GC周期的Java堆占用率阈值<br>超过此值，触发GC。默认值：45</li>
</ul>
</li>
<li><p>G1 收集器的常见操作步骤</p>
<ul>
<li>G1的设计原则：简化JVM性能调优。开发人员只需要简单的三步即可完成调优</li>
<li>第一步：开启G1垃圾收集器</li>
<li>第二步：设置堆的最大内存</li>
<li>第三步：设置最大的停顿时间</li>
</ul>
</li>
<li><p>G1收集器的适用场景</p>
<ul>
<li>面向服务端应用，针对具有大内存、多处理器的机器</li>
<li>要低GC延迟，并具有大堆的应用程序提供解决方案<br>​在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）</li>
<li>用来替换掉JDK1.5中的CMS收集器；在下面的情况时，使用G1可能比CMS好<ul>
<li>超过50%的Java堆被活动数据占用</li>
<li>对象分配频率或年代提升频率变化很大</li>
<li>GC停顿时间过长（长于0.5至1秒）</li>
</ul>
</li>
<li>HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器均使用内置的JVM线程执行GC的多线程操作，而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程</li>
</ul>
</li>
<li><p>分区 Region：化整为零</p>
<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210314123150627.png" alt="image-20210314123150627" style="zoom:50%;" />

<ul>
<li><p>使用G1收集器时，它将整个Java堆划分成约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB，2MB，4MB，8MB，16MB，32MB。</p>
</li>
<li><p>XX:G1HeapRegionSize设定。所有的Region大小相同，且在JVM生命周期内不会被改变。</p>
</li>
<li><p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。通过Region的动态分配方式实现逻辑上的连续。</p>
</li>
<li><p>一个Region有可能属于Eden，Survivor或者Old&#x2F;Tenured内存区域。但是一个Region只可能属于一个角色。图中的E表示该Region属于Eden内存区域，S表示属于Survivor内存区域，O表示属于Old内存区域。图中空白的表示未使用的内存空间。</p>
</li>
<li><p>G1垃圾收集器还增加了一种新的内存区域，叫做Humongous内存区域，如图中的H块。主要用于存储大对象，如果超过0.5个Region，就放到H。</p>
<blockquote>
<p>设置 H 的原因</p>
<ul>
<li>对于堆中的大对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。</li>
<li>为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。</li>
<li>如果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。</li>
</ul>
</blockquote>
</li>
<li><p>Region的内部结构</p>
<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210314123454051.png" alt="image-20210314123454051" style="zoom:50%;" />

<ul>
<li>每个Region都是通过指针碰撞来分配空间</li>
<li>每个Region都有TLAB，提高对象分配的效率</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="G1-垃圾回收流程"><a href="#G1-垃圾回收流程" class="headerlink" title="G1 垃圾回收流程"></a>G1 垃圾回收流程</h4><ul>
<li><p>G1 GC的垃圾回收过程主要包括如下三个环节</p>
</li>
<li><p>年轻代GC（Young GC）</p>
<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210314131011898.png" alt="image-20210314131011898" style="zoom: 50%;" />

<ul>
<li><p>JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。</p>
</li>
<li><p>YGC时，首先G1停止应用程序的执行（Stop-The-World），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。</p>
</li>
<li><p>然后开始如下回收过程</p>
<ol>
<li><p>第一阶段，扫描根</p>
<ul>
<li>根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等</li>
<li>根引用连同RSet记录的外部引用作为扫描存活对象的入口</li>
</ul>
</li>
<li><p>第二阶段，更新RSet</p>
<ul>
<li>处理dirty card queue（见备注）中的card，更新RSet。</li>
<li>此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用。</li>
</ul>
</li>
<li><p>第三阶段，处理RSet</p>
<ul>
<li>识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。</li>
</ul>
<p>			</p>
</li>
<li><p>第四阶段，复制对象</p>
<ul>
<li>此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象</li>
<li>如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到Old区中空的内存分段。</li>
<li>如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。</li>
</ul>
<p>	</p>
</li>
<li><p>第五阶段，处理引用</p>
<ul>
<li>处理Soft，Weak，Phantom，Final，JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</li>
</ul>
</li>
</ol>
<ul>
<li><p>备注</p>
<ol>
<li>对于应用程序的引用赋值语句 oldObject.field&#x3D;new Object()，JVM会在之前和之后执行特殊的操作以在dirty card queue中入队一个保存了对象引用信息的card。</li>
<li>在年轻代回收的时候，G1会对Dirty Card Queue中所有的card进行处理，以更新RSet，保证RSet实时准确的反映引用关系。</li>
<li>那为什么不在引用赋值语句处直接更新RSet呢？这是为了性能的需要，RSet的处理需要线程同步，开销会很大，使用队列性能会好很多。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>老年代并发标记过程（Concurrent Marking）</p>
<ol>
<li>初始标记阶段<ul>
<li>标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC</li>
<li>正是由于该阶段时STW的，所以我们只扫描根节点可达的对象，以节省时间</li>
</ul>
<p>			</p>
</li>
<li>根区域扫描（Root Region Scanning）<ul>
<li>G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象</li>
<li>这一过程必须在Young GC之前完成，因Young GC会使用复制算法对Survivor区进行GC</li>
</ul>
</li>
<li>并发标记（Concurrent Marking）</li>
</ol>
<ul>
<li>在整个堆中进行并发标记（和应用程序并发执行），此过程可能被Young GC中断<ul>
<li>在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收</li>
<li>同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）</li>
</ul>
</li>
</ul>
<ol start="4">
<li>重新标记（Remark）<ul>
<li>由于应用程序持续进行，需要修正上一次的标记结果。STW</li>
<li>G1中采用了比CMS更快的初始快照算法：Snapshot-At-The-Beginning（SATB）</li>
</ul>
</li>
<li>独占清理（cleanup，STW）</li>
</ol>
<ul>
<li>计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域</li>
<li>为下阶段做铺垫。是STW的。这个阶段并不会实际上去做垃圾的收集</li>
</ul>
<ol start="6">
<li>并发清理阶段</li>
</ol>
<ul>
<li>识别并清理完全空闲的区域</li>
</ul>
</li>
<li><p>混合回收过程（Mixed GC）</p>
<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210315095509303.png" alt="image-20210315095509303" style="zoom:50%;" />

<ul>
<li>当越来越多的对象晋升到老年代Old Region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了回收整个Young Region，还会回收一部分的Old Region</li>
<li>这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些Old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC</li>
<li>混合回收细节<ol>
<li>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算出来</li>
<li>默认情况下，这些老年代的内存分段会分8次（可以通过-XX:G1MixedGCCountTarget设置）被回收</li>
<li>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程</li>
<li>由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收</li>
<li>XX:G1MixedGCLiveThresholdPercent，默认65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间</li>
<li>混合回收并不一定要进行8次。有一个阈值-XX:G1HeapWastePercent，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但回收到的内存却很少</li>
</ol>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>（如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）</p>
</blockquote>
<ul>
<li><p>顺时针，Young GC –&gt; Young GC+Concurrent Marking –&gt; Mixed GC，进行垃圾回收</p>
<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210315100135783.png" alt="image-20210315100135783" style="zoom:50%;" />
</li>
<li><p>大致的回收流程</p>
<ol>
<li><p>应用程序分配内存，当年轻代的Eden区用尽时开始年轻代回收过程；G1的年轻代收集阶段是一个并行的独占式收集器。</p>
</li>
<li><p>在年轻代回收期，G1 GC暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。</p>
</li>
<li><p>当堆内存使用达到一定值（默认45%）时，开始老年代并发标记过程。标记完成马上开始混合回收过程。</p>
</li>
<li><p>对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。</p>
</li>
<li><p>和年轻代不同，老年代的G1回收器和其他GC不同，G1的老年代回收器不需要整个老年代被回收，一次只需要扫描&#x2F;回收一小部分老年代的Region就可以了。同时，这个老年代Region是和年轻代一起被回收的。</p>
<blockquote>
<p>举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h4 id="G1-回收器垃圾回收过程：Remembered-Set（记忆集）"><a href="#G1-回收器垃圾回收过程：Remembered-Set（记忆集）" class="headerlink" title="G1 回收器垃圾回收过程：Remembered Set（记忆集）"></a>G1 回收器垃圾回收过程：Remembered Set（记忆集）</h4><ul>
<li><p>存在问题</p>
<ol>
<li>一个对象被不同区域引用的问题</li>
<li>一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？</li>
<li>在其他的分代收集器，也存在这样的问题（而G1更突出，因为G1主要针对大堆）</li>
<li>回收新生代也不得不同时扫描老年代？这样的话会降低Minor GC的效率</li>
</ol>
</li>
<li><p>解决方法</p>
<ol>
<li>无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描</li>
<li>每个Region都有一个对应的Remembered Set</li>
<li>每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作</li>
<li>然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）</li>
<li>如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中</li>
<li>当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏</li>
</ol>
</li>
<li><p>总结</p>
<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210315100435152.png" alt="image-20210315100435152" style="zoom:50%;" />

<ul>
<li>在回收 Region 时，为了不进行全堆的扫描，引入了 Remembered Set</li>
<li>Remembered Set 记录了当前 Region 中的对象被哪个对象引用了</li>
<li>这样在进行 Region 复制时，就不要扫描整个堆，只需要去 Remembered Set 里面找到引用了当前 Region 的对象</li>
<li>Region 复制完毕后，修改 Remembered Set 中对象的引用即可</li>
</ul>
</li>
<li><p>G1 的注意事项</p>
<ul>
<li>G1 回收可选的过程四：Full GC<ol>
<li>G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（Stop-The-World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长</li>
<li>要避免Full GC的发生，一旦发生Full GC，需要对JVM参数进行调整。什么时候会发生Ful1GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到Full GC，这种情况可以通过增大内存来解决</li>
</ol>
</li>
<li>导致G1 Full GC的原因可能有两个<ol>
<li>回收Evacuation的时候没有足够的to-space来存放晋升的对象</li>
<li>并发处理过程完成之前空间耗尽</li>
</ol>
</li>
<li>G1 回收器的补充<ol>
<li>从Oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回一部分Region，停顿时间是用户可控制的，所以并不迫切去实现，而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中</li>
<li>另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案</li>
</ol>
</li>
<li>G1 回收器的优化建议<ul>
<li>年轻代大小<ol>
<li>避免使用-Xmn或-XX:NewRatio等相关选项显式设置年轻代大小</li>
<li>固定年轻代的大小会覆盖暂停时间目标</li>
</ol>
</li>
<li>暂停时间目标不要太过严苛<ol>
<li>G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间</li>
<li>评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？"><a href="#新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？" class="headerlink" title="新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？"></a>新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？</h4><ul>
<li>新生代回收器：Serial、ParNew、Parallel Scavenge<ul>
<li>采用：复制算法，优点：效率高，缺点：内存利用率低（to区永远是空）；适用生命周期短的对象收集</li>
</ul>
</li>
<li>老年代回收器：Serial Old、Parallel Old、CMS<ul>
<li>采用：标记-清除-压缩算法</li>
</ul>
</li>
<li>整堆回收器：G1</li>
</ul>
<h2 id="五、垃圾回收器总结"><a href="#五、垃圾回收器总结" class="headerlink" title="五、垃圾回收器总结"></a>五、垃圾回收器总结</h2><h3 id="7-种垃圾回收器的比较"><a href="#7-种垃圾回收器的比较" class="headerlink" title="7 种垃圾回收器的比较"></a>7 种垃圾回收器的比较</h3><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210315102127059.png" alt="image-20210315102127059" style="zoom:50%;" />

<h3 id="怎么选择垃圾回收器？"><a href="#怎么选择垃圾回收器？" class="headerlink" title="怎么选择垃圾回收器？"></a>怎么选择垃圾回收器？</h3><ol>
<li>优先调整堆的大小让JVM自适应完成</li>
<li>如果内存小于100M，使用串行收集器</li>
<li>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</li>
<li>如果是多CPU、需要高吞吐量、允许停顿时间超过1秒，选择并行或者JVM自己选择</li>
<li>如果是多CPU、追求低停顿时间，需快速响应（比如延迟不能超过1秒，如互联网应用），使用并发收集器</li>
<li>官方推荐G1，性能高。现在互联网的项目，基本都是使用G1</li>
</ol>
<ul>
<li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li>
</ul>
<h3 id="GC-日志分析"><a href="#GC-日志分析" class="headerlink" title="GC 日志分析"></a>GC 日志分析</h3><ul>
<li><p>GC 日志参数设置：通过阅读GC日志，我们可以了解Java虚拟机</p>
<p>内存分配与回收策略</p>
</li>
<li><p>内存分配与垃圾回收的参数列表</p>
<ul>
<li><p>-XX:+PrintGC ：输出GC日志，类似：-verbose:gc</p>
<ul>
<li><p>输出信息</p>
<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210315102213052.png" alt="image-20210315102213052" style="zoom: 67%;" />
</li>
<li><p>参数解析</p>
<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210315102243513.png" alt="image-20210315102243513" style="zoom:50%;" /></li>
</ul>
</li>
<li><p>-XX:+PrintGCDetails ：输出GC的详细日志</p>
<ul>
<li><p>输出信息</p>
<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210315102319597.png" alt="image-20210315102319597" style="zoom:50%;" />
</li>
<li><p>参数解析</p>
<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210315102342532.png" alt="image-20210315102342532" style="zoom:50%;" /></li>
</ul>
</li>
<li><p>-XX:+PrintGCTimestamps ：输出GC的时间戳（以基准时间的形式）</p>
</li>
<li><p>-XX:+PrintGCDatestamps ：输出GC的时间戳</p>
<ul>
<li>以日期的形式，如2013-05-04T21: 53: 59.234 +0800</li>
<li>输出信息（日志带上了日期和时间）</li>
</ul>
</li>
<li><p>-XX:+PrintHeapAtGC ：在进行GC的前后打印出堆的信息</p>
   <img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210315102416837.png" alt="image-20210315102416837" style="zoom:50%;" />
</li>
<li><p>-XLoggc:.&#x2F;Logs&#x2F;gc.Log：日志文件的输出路径</p>
<ul>
<li>.&#x2F; 表示当前目录，在 IDEA中程序运行的当前目录是工程的根目录，而不是模块的根目录</li>
</ul>
</li>
</ul>
</li>
<li><p>日志分析的补充说明</p>
<ul>
<li>“[GC”和”[Full GC”说明了这次垃圾收集的停顿类型，如果有”Full”则说明GC发生了STW</li>
<li>使用Serial收集器在新生代的名字是Default New Generation，因此显示的是”[DefNew”</li>
<li>使用ParNew收集器在新生代的名字会变成”[ParNew”，意思是”Parallel New Generation”</li>
<li>使用Parallel scavenge收集器在新生代的名字是”[PSYoungGen”</li>
<li>老年代的收集和新生代道理一样，名字也是收集器决定的</li>
<li>使用G1收集器的话，会显示为”garbage-first heap”</li>
<li>Allocation Failure表明本次引起GC的原因是在年轻代中没有足够的空间能够存储新的数据</li>
<li>[ PSYoungGen: 5986K-&gt;696K(8704K) ] 5986K-&gt;704K (9216K)<ul>
<li>中括号内：GC回收前年轻代大小，回收后大小，（年轻代总大小）</li>
<li>括号外：GC回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</li>
</ul>
</li>
<li>user代表用户态回收耗时，sys内核态回收耗时，real实际耗时。由于多核线程切换的原因，时间总和可能会超过real时间</li>
</ul>
</li>
<li><p>Young GC 图例</p>
<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210315102648003.png" alt="image-20210315102648003" style="zoom:50%;" />
</li>
<li><p>Full GC 图例</p>
<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210315102706396.png" alt="image-20210315102706396" style="zoom:50%;" />
</li>
<li><p>日志分析工具</p>
<ul>
<li>GCViewer</li>
<li>GCEasy</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://fabian4.site/blog">Fabian Bao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://fabian4.site/blog/40208.html">https://fabian4.site/blog/40208.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://fabian4.site/blog" target="_blank">Fabian Bao</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/blog/tags/Java/">Java</a><a class="post-meta__tags" href="/blog/tags/JVM/">JVM</a></div><div class="post_share"><div class="social-share" data-image="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/20210312160242.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/h3WuUjvQlqPEAzS.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/h3WuUjvQlqPEAzS.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/9yaek4PwfNoZEHF.jpg" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/9yaek4PwfNoZEHF.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blog/22217.html"><img class="prev-cover" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/img-4807e805e5208cd813eeb4870650afcc.jpg" onerror="onerror=null;src='/blog/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">使用 frp 搭建内网穿透</div></div></a></div><div class="next-post pull-right"><a href="/blog/41789.html"><img class="next-cover" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/20210312160242.png" onerror="onerror=null;src='/blog/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JVM 运行时数据区</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/blog/41489.html" title="JVM 架构、类加载子系统和执行引擎"><img class="cover" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/20210312160242.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-10</div><div class="title">JVM 架构、类加载子系统和执行引擎</div></div></a></div><div><a href="/blog/41789.html" title="JVM 运行时数据区"><img class="cover" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/20210312160242.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-15</div><div class="title">JVM 运行时数据区</div></div></a></div><div><a href="/blog/62781.html" title="JAVA 8 新特性"><img class="cover" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/MYxEQ51GWCyp8R9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-02</div><div class="title">JAVA 8 新特性</div></div></a></div><div><a href="/blog/6499.html" title="JAVA 多线程编程"><img class="cover" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/DBQoWytONRSr5I3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-25</div><div class="title">JAVA 多线程编程</div></div></a></div><div><a href="/blog/43332.html" title="JAVA 并发相关"><img class="cover" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/ujHGUnEID1JSgqF.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-29</div><div class="title">JAVA 并发相关</div></div></a></div><div><a href="/blog/12941.html" title="JAVA 线程安全集合"><img class="cover" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/7xPYzltZs94ROI6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-31</div><div class="title">JAVA 线程安全集合</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://fabian4.site/avatar.png" onerror="this.onerror=null;this.src='/blog/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Fabian Bao</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">73</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">The best is yet to come</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">1.</span> <span class="toc-text">JVM 垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">一、垃圾回收概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%AE%80%E8%BF%B0-Java-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.1.</span> <span class="toc-text">1. 简述 Java 垃圾回收机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.2.</span> <span class="toc-text">2. 垃圾回收机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%80%E4%B9%88%E6%98%AF-Grabage"><span class="toc-number">1.1.3.</span> <span class="toc-text">3. 什么是 Grabage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%BF%9B%E8%A1%8C-Grabage-Collection"><span class="toc-number">1.1.4.</span> <span class="toc-text">4. 为什么需要进行 Grabage Collection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">1.1.5.</span> <span class="toc-text">5. 垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%85%E5%BF%A7"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">担忧</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-GC-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.1.6.</span> <span class="toc-text">6. GC 的作用域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">二、垃圾回收相关算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5what%EF%BC%9A%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB"><span class="toc-number">1.2.1.</span> <span class="toc-text">1. 标记阶段what：判断对象是否存活</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. 引用计数法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%EF%BC%88%E6%A0%B9%E6%8D%AE%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E3%80%81%E8%BF%BD%E8%B8%AA%E6%80%A7%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%EF%BC%89"><span class="toc-number">1.2.3.</span> <span class="toc-text">3. 标记阶段：可达性分析算法（根据搜索算法、追踪性垃圾收集）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GC-Roots-%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%93%AA%E4%BA%9B%E5%85%83%E7%B4%A0"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">GC Roots 可以是哪些元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-GC-Roots"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">关于 GC Roots</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">可达性分析算法的注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E6%B0%B8%E7%94%9F%E4%BB%A3"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">关于永生代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84-finalization-%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">对象的 finalization 机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.</span> <span class="toc-text">三、垃圾回收相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-System-gc-%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. System.gc() 的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA-OutOfMemoryError"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. 内存溢出 OutOfMemoryError</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">1.3.3.</span> <span class="toc-text">3. 内存泄漏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Stop-The-World"><span class="toc-number">1.3.4.</span> <span class="toc-text">4. Stop The World</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="toc-number">1.3.5.</span> <span class="toc-text">5. 垃圾回收的并行与并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%AE%89%E5%85%A8%E7%82%B9%E4%B8%8E%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F"><span class="toc-number">1.3.6.</span> <span class="toc-text">6. 安全点与安全区域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9"><span class="toc-number">1.3.6.1.</span> <span class="toc-text">安全点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9%E4%B8%AD%E6%96%AD%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.6.2.</span> <span class="toc-text">安全点中断实现方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F"><span class="toc-number">1.3.6.3.</span> <span class="toc-text">安全区域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F%E6%98%AF%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.6.4.</span> <span class="toc-text">安全区域是执行流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">1.4.</span> <span class="toc-text">四、垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%88%86%E7%B1%BB"><span class="toc-number">1.4.1.</span> <span class="toc-text">1. 垃圾回收器分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%AF%84%E4%BC%B0-GC-%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">1.4.2.</span> <span class="toc-text">2. 评估 GC 的性能指标</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E9%87%8F"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">吞吐量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9A%82%E5%81%9C%E6%97%B6%E9%97%B4"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">暂停时间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7%E7%A7%8D%E7%BB%8F%E5%85%B8%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">1.4.3.</span> <span class="toc-text">3. 7种经典的垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">串行垃圾回收器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ParNew-%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E5%B9%B4%E8%BD%BB%E4%BB%A3%EF%BC%88Parallel-New%EF%BC%89%E5%A4%8D%E5%88%B6%E3%80%81%E5%B9%B6%E8%A1%8C%E3%80%81STW"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">ParNew 回收器：年轻代（Parallel New）复制、并行、STW</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Parallel-Scavenge-%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9A%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88%E3%80%81%E5%A4%8D%E5%88%B6%E5%B9%B6%E8%A1%8CSTW%E3%80%81server%E6%A8%A1%E5%BC%8F%E3%80%81Java8%E9%BB%98%E8%AE%A4"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">Parallel Scavenge 回收器：吞吐量优先、复制并行STW、server模式、Java8默认</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">CMS 垃圾回收器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS-%E7%89%B9%E7%82%B9%E4%B8%8E%E5%BC%8A%E7%AB%AF%E5%88%86%E6%9E%90"><span class="toc-number">1.4.3.5.</span> <span class="toc-text">CMS 特点与弊端分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS-%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE"><span class="toc-number">1.4.3.6.</span> <span class="toc-text">CMS 参数配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1-%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">1.4.3.7.</span> <span class="toc-text">G1 回收器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%B5%81%E7%A8%8B"><span class="toc-number">1.4.3.8.</span> <span class="toc-text">G1 垃圾回收流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1-%E5%9B%9E%E6%94%B6%E5%99%A8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%BF%87%E7%A8%8B%EF%BC%9ARemembered-Set%EF%BC%88%E8%AE%B0%E5%BF%86%E9%9B%86%EF%BC%89"><span class="toc-number">1.4.3.9.</span> <span class="toc-text">G1 回收器垃圾回收过程：Remembered Set（记忆集）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E5%92%8C%E8%80%81%E5%B9%B4%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.4.3.10.</span> <span class="toc-text">新生代垃圾回收器和老年代垃圾回收器都有哪些？有什么区别？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.</span> <span class="toc-text">五、垃圾回收器总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%A7%8D%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.5.1.</span> <span class="toc-text">7 种垃圾回收器的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9F"><span class="toc-number">1.5.2.</span> <span class="toc-text">怎么选择垃圾回收器？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC-%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90"><span class="toc-number">1.5.3.</span> <span class="toc-text">GC 日志分析</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/blog/55079.html" title="Mysql 执行流程和日志系统"><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/Hatshepsut_ZH-CN4516192627_1920x1080.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="Mysql 执行流程和日志系统"/></a><div class="content"><a class="title" href="/blog/55079.html" title="Mysql 执行流程和日志系统">Mysql 执行流程和日志系统</a><time datetime="2021-05-14T16:00:00.000Z" title="发表于 2021-05-15 00:00:00">2021-05-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/47132.html" title="Mysql 锁机制"><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/Italica_ZH-CN1692906751_1920x1080.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="Mysql 锁机制"/></a><div class="content"><a class="title" href="/blog/47132.html" title="Mysql 锁机制">Mysql 锁机制</a><time datetime="2021-04-24T16:00:00.000Z" title="发表于 2021-04-25 00:00:00">2021-04-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/10729.html" title="Mysql 隔离级别与MVCC"><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/CuscoCathedral_ZH-CN9834821723_1920x1080.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="Mysql 隔离级别与MVCC"/></a><div class="content"><a class="title" href="/blog/10729.html" title="Mysql 隔离级别与MVCC">Mysql 隔离级别与MVCC</a><time datetime="2021-04-19T16:00:00.000Z" title="发表于 2021-04-20 00:00:00">2021-04-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/58885.html" title="数据库四大性质和隔离等级"><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/ContainerShip_ZH-CN0850122021_1920x1080.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="数据库四大性质和隔离等级"/></a><div class="content"><a class="title" href="/blog/58885.html" title="数据库四大性质和隔离等级">数据库四大性质和隔离等级</a><time datetime="2021-04-07T16:00:00.000Z" title="发表于 2021-04-08 00:00:00">2021-04-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/5986.html" title="HashMap、HashTable和ConcurrentHashMap"><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/HallstattAustria_PT-BR9407016733_1920x1080.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="HashMap、HashTable和ConcurrentHashMap"/></a><div class="content"><a class="title" href="/blog/5986.html" title="HashMap、HashTable和ConcurrentHashMap">HashMap、HashTable和ConcurrentHashMap</a><time datetime="2021-04-02T16:00:00.000Z" title="发表于 2021-04-03 00:00:00">2021-04-03</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://fabian.oss-cn-hangzhou.aliyuncs.com/img/20210312160242.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Fabian Bao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/blog/js/utils.js"></script><script src="/blog/js/main.js"></script><script src="/blog/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '98fe0206dedd0d2caf96',
      clientSecret: '5f2816f58a108f15feba46f9bc88497d3d6457a4',
      repo: 'blog',
      owner: 'fabian4',
      admin: ['fabian4'],
      id: '7dafadc3321cfce37b0d588e64c34dd4',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>