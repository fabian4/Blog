---
title: JAVA 线程并发和安全
date: 2021/1/27
description: JAVA 线程并发和安全
top_img: 'https://fabian.oss-cn-hangzhou.aliyuncs.com/img/LGPb6mABqndWp45.jpg'
cover: 'https://fabian.oss-cn-hangzhou.aliyuncs.com/img/LGPb6mABqndWp45.jpg'
categories:
  - Java
tags:
  - Java
  - 多线程
abbrlink: 8531
---

# JAVA 线程并发和安全

## 一、线程不安全

先来看一个例子

```java
public class Test {

    private int num = 0;

    public void increase(){
        num++;
        System.out.println("当前线程："+Thread.currentThread().getName()+" ============> "+ num);
    }

    public static void main(String[] args) {
        Test test = new Test();
        int num = 0;
        for (int i = 1; i <= 3000; i++) {
            new Thread(test::increase, String.valueOf(i)).start();
        }
    }
}
```

我们开启 3000 条线程去对同一个变量进行 +1 操作，结果如下

<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/dT7e1oE93MGmzHD.png" alt="image-20210204153911927" style="zoom:50%;" />

很明显不是我们预期的结果

## 二、JMM 模型

JMM（Java Memory Model，简称JMM）定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。

<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/Qzb3oR4HLWO6BfJ.png" alt="image-20210204161732338" style="zoom:50%;" />

### 内存交互操作

　**内存交互操作有8种，虚拟机实现必须保证每一个操作都是原子的，不可在分的**

> （对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许例外）

- lock   （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态
- unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
- read  （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用
- load   （载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中
- use   （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令
- assign （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中
- store  （存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用
- write 　（写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中

　　**JMM对这八种指令的使用，制定了如下规则：**

- 不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write
- 不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存
- 不允许一个线程将没有assign的数据从工作内存同步回主内存
- 一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作
- 一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁
- 如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值
- 如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量
- 对一个变量进行unlock操作之前，必须把此变量同步回主内存

### 可见性、原子性和有序性。

**可见性：**

　　可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。

　　**可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。**也就是一个线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。

> 在 Java 中 volatile、synchronized 和 final 实现可见性。

**原子性：**

　　**原子是世界上的最小单位，具有不可分割性。**比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作时原子操作。再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如：AtomicInteger、AtomicLong、AtomicReference等。

> 在 Java 中 synchronized 和在 lock、unlock 中操作保证原子性。

**有序性：**

　　Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行

## 三、volatile 关键字

Java语言提供了一种**稍弱**的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。

在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，**因此volatile变量是一种比sychronized关键字更轻量级的同步机制。**

> 当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。

**当一个变量定义为 volatile 之后，将具备两种特性：**

1. 保证此变量对所有的线程的可见性，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存来完成。
2. 禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个**内存屏障**（指令重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。

**volatile 性能：**

　　volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。

volatile保证了**可见性，有序性，不保证原子性**

## 四、synchronized 使用

1. 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，**作用的对象是调用这个代码块的对象； **
2. 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，**作用的对象是调用这个方法的对象；** 
3. 修改一个静态的方法，其作用的范围是整个静态方法，**作用的对象是这个类的所有对象；**
4. 修改一个类，其作用的范围是synchronized后面括号括起来的部分，**作用主的对象是这个类的所有对象。**

对于一开始的例子我们这样就可以保证线程安全了

~~~java
// 修饰方法
public synchronized void increase(){
    num++;
    System.out.println("当前线程："+Thread.currentThread().getName()+" ============> "+ num);
}

// 修饰代码块
public void increase(){
    // 锁住调用的对象
    synchronized (this){
        num++;
        System.out.println("当前线程："+Thread.currentThread().getName()+" ============> "+ num);
    }
}
~~~

## 五、可重入锁 ReentrantLock 的使用

~~~java
private Lock lock = new ReentrantLock();

public void increase(){
    // 先获得锁
    lock.lock();
    try {
        num++;
        System.out.println("当前线程："+Thread.currentThread().getName()+" ============> "+ num);
    } finally {
        // 不要忘记释放锁
        lock.unlock();
    }
}
~~~

## 六、ReentrantLock 和 synchronized 的区别

- 对于Synchronized来说，它是java语言的关键字，是原生语法层面的互斥，需要jvm实现。而ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配合try/finally语句块来完成
- synchronized同步，假如发生异常，JVM是可以帮我们自动释放锁的，但是lock不可以，**我们只能手动释放锁，即使发生异常，jvm也不会自动释放锁**。
- synchronized与wait()和notify()/notifyAll()方法结合可以实现等待通知模式，Reentrantlock可以实现同样的效果，**在synchronized当中，被通知的线程是由JVM随机选择，但是lock结合condition可以实现选择性通知。**

## 七、死锁

### 1. 产生死锁的原因

- 竞争资源
  - 系统中的资源可以分为两类：
    1. 可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；
    2. 另一类资源是不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。
  - 产生死锁中的竞争资源之一指的是竞争不可剥夺资源（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）
- 产生死锁中的竞争资源另外一种资源指的是竞争临时资源（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁
  
- 进程间推进顺序非法
  - 若P1保持了资源R1,P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁
  - 例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁

### 2. 产生死锁的必要条件

1. **互斥条件**：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
2. **请求和保持条件**：当进程因请求资源而阻塞时，对已获得的资源保持不放。
3. **不剥夺条件**：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
4. **环路等待条件**：在发生死锁时，必然存在一个进程--资源的环形链。

### 3. 预防死锁

- 资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）
- 只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏请保持条件）
- 可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）
- 资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）

1. 以一定的顺序获得锁
2. 超时放弃

### 4. 死锁检测

1. **Jstack命令**

   jstack是java虚拟机自带的一种堆栈跟踪工具。jstack用于打印出给定的java进程ID或core file或远程调试服务的Java堆栈信息。 Jstack工具可以用于生成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。 线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。

2. **JConsole工具**

   Jconsole是JDK自带的监控工具，在JDK/bin目录下可以找到。它用于连接正在运行的本地或者远程的JVM，对运行在Java应用程序的资源消耗和性能进行监控，并画出大量的图表，提供强大的可视化界面。而且本身占用的服务器内存很小，甚至可以说几乎不消耗。