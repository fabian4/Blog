---
title: JVM 架构、类加载子系统和执行引擎
date: 2021/2/10
description: JVM 架构、类加载子系统和执行引擎
top_img: 'https://fabian.oss-cn-hangzhou.aliyuncs.com/img/20210312160242.png'
cover: 'https://fabian.oss-cn-hangzhou.aliyuncs.com/img/20210312160242.png'
categories:
  - Java
tags:
  - Java
  - JVM
abbrlink: 41489
---

# JVM 架构、类加载子系统和执行引擎

## 一、简介

1. jvm是一种用于计算设备的规范，它是一个虚构出来的机器，是通过在实际的计算机上仿真模拟各种功能实现的。
2. jvm包含一套字节码指令集，一组寄存器，一个栈，一个垃圾回收堆和一个存储方法域。
3. jvm屏蔽了与具体操作系统平台相关的信息，使Java程序只需生成在Java虚拟机上运行的目标代码（字节码）,就可以在多种平台上不加修改地运行。

> JVM在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。

- JDK(Java Development Kit)，是开发者用来编译、调试程序用的开发包。JDK也是JAVA程序需要在JRE上运行。
- JRE(Java Runtime Environment)，也就是java平台。所有的java程序都要在JRE环境下才能运行。
- JVM(Java Virtual Machine)，是JRE的一部分。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。

> JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。
> Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。

<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210312154041273.png" alt="image-20210312154041273" style="zoom: 50%;" />

1. 编译型语言(C++以及Fortran)的优缺点：

   - 速度快：因为在编译的时候它们能够获取到更多的有关程序结构的信息，从而有机会对它们进行优化。
   - 适用性差：它们编译得到的二进制代码往往是CPU相关的，在需要适配多种CPU时，可能需要编译多次。

2. 解释型语言(PHP以及Perl)的优缺点：

   - 适应性强：只需要安装正确的解释器，程序在任何CPU上都能够被运行
   - 速度慢：因为程序需要被逐行翻译，导致速度变慢。同时因为缺乏编译这一过程，执行代码不能通过编译器进行优化。

3. Java的做法是找到编译型语言和解释性语言的一个中间点：

   - Java代码会被编译：被编译成Java字节码，而不是针对某种CPU的二进制代码。
   - Java代码会被解释：Java字节码需要被java程序解释执行，此时，Java字节码被翻译成CPU相关的二进制代码。
   - JIT编译器的作用：在程序运行期间，将Java字节码编译成平台相关的二进制代码。正因为此编译行为发生在程序运行期间，所以该编译器被称为Just-In-Time编译器。

   

## 二、架构设计图

<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210311171429408.png" alt="image-20210311171429408" style="zoom:50%;" />

- 类加载子系统：加载字节码文件到运行数据区的方法区
- 执行引擎：执行字节码文件中的指令
- 本地方法接口：java调用其他语言的接口，与本地资源交互
- 运行时数据区：JVM的内存

### **执行流程**

1. 首先通过编译器把Java代码转换成字节码
2. 类加载器再把字节码加载到内存中，将其放在运行时数据区的方法区内
3. 执行引擎将字节码翻译成底层系统指令，再交由CPU去执行
4. 这个过程需要调用其他语言的本地库接口来实现整个程序的功能

<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210311171521971.png" alt="image-20210311171521971" style="zoom: 50%;" />

### **JVM 架构模型  基于栈式（虚拟机栈）**

- 优点

  1. 设计和实现简单，适用于资源受限的系统

  2. 避开了寄存器的分配难题：使用零地址指令方式分配

     操作栈顶元素不需要地址

  3. 指令流中大部分都是零地址指令，执行过程依赖操作栈，指令集更小，编译器容易实现。

     8位字节码，指令集更小，但完成一项操作花费的指令相对多

  4. 不需要硬件支持，可移植性更好，更好实现跨平台

- 缺点

  性能下降，实现同样的功能需要更多的指令，毕竟还要入栈出栈等操作

> javap 查看字节码
>
> - -v 输出附加信息
> - -l 输出行号和本地变量表
> - -p 显示所有类和成员
> - -c 对代码进行反汇编

### **JVM 生命周期**

1. 虚拟机启动
   - 通过引导类加载器 bootstrap class loader 创建一个初始类来完成，这个类是由虚拟机的具体实现指定的
2. 虚拟机执行
   - 执行一个所谓的 Java 程序的实现，真正执行的是一个叫 Java 虚拟机的进程
3. 虚拟的推出
   - 程序正常执行结束
   - 执行过程遇到异常或错误而异常终止
   - 操作系统错误导致Java虚拟机进程终止
   - Runtime类或者System类的exit方法、runtime类的halt方法，并且Java安全管理器允许这次exit或halt操作
     - halt停止、停下、阻止
     - exit方法
   - JNI规范描述了用JNI Invocation API 来加载或卸载 Java虚拟机时，Java虚拟机退出的情况

## 三、类加载子系统

### 1. 作用

- 负责从文件系统或者网络中加载Class文件，Class文件开头有特定文件标识

- Classloader只负责class文件的加载，是否可以运行，由执行引擎决定

- 加载类信息存到内存

  方法区除了类信息，方法区还会存放运行时常量池信息，还可能包括字符串字面量和数字常量

  常量池运行时加载到内存中，即运行时常量池

- 类加载器加载字节码文件到内存

### 2. 角色

<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210311171534145.png" alt="image-20210311171534145" style="zoom:50%;" />

### 3. 加载过程

1. 加载：根据查找路径找到相应的class文件然后导入

   - 通过一个类的全限定类名获取定义此类的二进制字节流
     - 本地系统获取
     - 网络获取，Web Applet
     - zip压缩包获取，jar，war
     - 运行时计算生成，动态代理
     - 有其他文件生成，jsp
     - 专有数据库提取 .class 文件，比较少见
     - 加密文件中获取，防止Class文件被反编译的保护措施
   - 将这个字节流所代表的静态存储结果转化为方法区的运行时数据结构
   - 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据访问入口

2. 验证：检查加载的 class 文件的正确性，确保被加载类的正确性，不会危害虚拟机自身安全

   - 文件格式验证
     1. 是否以 0xCAFEBABE 开头
     2. 主次版本号
     3. 常量池的常量中是否有不被支持的常量类型
     4. 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量
   - 元数据验证
     1. 对字节码描述的信息进行语义分析，保证符号Java规范
     2. 类是否有父类，除了Object类之外，所有类都应该有父类
     3. 类的父类是否继承了不允许被继承的类（ 被final修饰的类 ）
     4. 如果这个类不是抽象类，是否实现了其父类或接口中要求实现的所有方法
     5. 类的字段，方法是否与父类的产生矛盾。例如方法参数都一样，返回值不用。
   - 字节码验证
     1. 通过数据流分析和控制流分析，确定程序语义是合法的，符合逻辑的
     2. 对类的方法体，进行校验分析，保证在运行时不会做出危害虚拟机的行为
     3. 保证任意时刻操作数栈的数据类型与指令代码都能配合工作
     4. 保障任何跳转指令都不会跳转到方法体之外的字节码指令上
   - 符合引用验证
     1. 通过字符串描述的全限定类名是否能找到对应的类
     2. 符合引用的类、字段、方法的可访问性是否可被当前类访问

3. 准备：给类中的静态变量分配内存空间

   - 为类变量（静态变量）分配内存，并且设置该类变量的初始值，即零值

     ![image-20210311171549757](https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210311171549757.png)

   - 不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显示初始化

   - 不会为实例变量分配初始化，类变量会分配在方法区中，示例变量会随着对象一起分配到Java堆中

4. 解析：虚拟机将常量池中的符号引用替换成直接引用的过程

   解析动作主要针对类，或接口，字段，类方法，接口方法，方法类型等。

5. 初始化：对静态变量和静态代码块执行初始化工作

   - 执行类的构造器方法 clinit 的过程

   - 此方法不需要定义，是 Javac 编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来

     如果没有类变量和静态代码块，也不会有 clinit

   - 构造器方法中指令按照语句在源文中出现的顺序执行

   - clinit 不同于类的构造器

     构造器是虚拟机视角下的 init

   - 若该类有父类，JVM 会保证子类的 clinit 执行前，父类的 clinit 已经执行完毕

   - 虚拟机必须保证一个类的 clinit 方法在多线程下被同步加锁

> JVM 把描述类的数据从Class文件加载到内存(方法区)，并对数据进行校验，解析和初始化

### 4. 类加载器

**通过类的全限定类名获取该类的二进制字节流的代码块叫做类加载器**

#### 四种类加载器

- 启动类加载器 `Bootstrap ClassLoader`：用来加载java核心类库，无法被java程序直接引用

- 扩展类加载器 `extensions class loader`：它用来加载 Java 的扩展库。JVM 的实现会提供一个扩展库目录。该类会在此目录里面查找并加载 Java 类

- 系统类加载器 `system class loader`：它根据 Java 应用的类路径 （CLASSPATH）来加载 Java 类。

  一般来说，Java 应用的类都是由它类完成加载的。可用通过 `ClassLoader.getSystemClassLoader()` 来获取它

- 用户自定义类加载器，通过继承 `java.lang.ClassLoader` 类的方式实现

<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210311171601073.png" alt="image-20210311171601073" style="zoom:50%;" />

#### 双亲委派模型

Java虚拟机对Class文件采用的是按需加载，而且加载Class文件时，Java虚拟机使用的是双亲委派模型，即把请求交由父类处理，它是异种任务委派模式

<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210311171611359.png" alt="image-20210311171611359" style="zoom:50%;" />

1. 如果一个类加载器收到了类加载请求，它并不会自己先去加载。而是把这个请求委托给父类加载器去执行
2. 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器
3. 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式

**优势：**

- 避免类加载重复
- 保护程序安全，防止核心API被篡改
- 保证对 Java 核心源代码的保护

> 在 JVM 中表示两个 class 对象，是否为同一个类存在的两个必要条件：
>
> - 类的完整类名必须一致、包括包名
> - 加载这个类的 ClassLoader 必须相同

JVM 必须知道一个类型是由启动类加载器加载的，还是由用户加载器加载的。**如果是用户类加载器加载的，JVM 会将这个类加载器的一个引用作为类型信息的一部分，保存到方法区中**

## 四、执行引擎

### 1. 执行引擎概述

- 执行引擎是Java虚拟机核心的组成部分之一
- 虚拟机的执行引擎由软件自行实现。物理机的执行引擎是操作系统层面上的
- 能够执行不被硬件直接支持的指令格式
- 工作过程
  1. 执行引擎在执行过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器
  2. 每执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址
  3. 当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息

### 2. Java代码编译和执行过程

大部分的程序代码转化成物理机的目标代码或者虚拟机能执行的指令集之前，都需要经过以下步骤

<img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/image-20210312155153541.png" alt="image-20210312155153541" style="zoom:50%;" />

> 为什么说 Java是半编译半解释型语言
>
> - JVM 在执行Java代码的时候，通常会见将结束执行与编译执行二者结合起来

### 3. 机器码、指令、汇编语言

#### 机器码

各种采用二进制编码方式表示的指令，叫做机器指令码。机器语言。机器指令和CPU紧密相关，不同种类的CPU所对应的机器指令也就不同

#### 指令

- #### 由于机器码由 01 组成，可读性太差。于是人们发明了指令

- 指令就是把机器码特定的0和1序列化，简化成对应的指令，一般为英文编写如mov、inc等，可读性稍好

- 由于不同的硬件平台，执行同一个操作，对应的机器码也可能不同。所以不同的硬件平台的同一种指令，对应的机器码也可能不同

#### 指令集

- 不同硬件平台，各种支持的指令是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集
- x86指令集，对应的是x86架构的平台
- ARM指令集，对应的是ARM架构的平台

#### 汇编

- 由于指令的可读性太差了，于是又有了汇编语言
- 汇编语言用助记符代替机器指令的操作码，用地址符合或标号，代替指令或操作数地址
- 汇编语言要翻译成机器指令码，计算机才能识别和执行

#### 解释器

- 当 Java虚拟机启动时，会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容翻译为赌赢平台的本地机器指令执行

- 解释器真正意义上所承担的角色就是一个运行时翻译器，将字节码文件中的内容翻译为对应的本地机器指令执行

- 当一条字节码指令被解释执行完成后，接着在根据PC寄存器中的记录下一条需要被执行的字节码执行解释执行

- 普遍使用的解释器模板

  模板解释器将每一条字节码和一个模板函数相关联，模板函数直接产生这条字节码执行时的字节码，提高解释器的性能

- HotSpot中

  - Interpreter模块实现了解释器的核心功能
  - Code模块用于管理HotSpot在运行时生成的本地机器指令

#### JIT编译器

- 就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言
- JVM平台支持一种叫做即使编译的技术，目的时避免解释执行，而是将整个函数体编译成机器码，每次函数执行时，只执行编译后的机器码即可。使执行效率大幅提升

> 为什么两种方式？
>
> - 首先程序启动后，解释器可以马上发挥作用，省去编译时间，立即执行
> - 编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后执行效率更高
> - 对于服务端应用，启动时间并非关注重点，但是对于看重启动时间的应用场景，就需要找到一个平衡点
> - 当 Java虚拟机启动时，解释器可以首先发挥作用，而不是等到即使编译器全部编译完成后再执行，这样可以省去很多不必要的编译时间，随着时间的推移，把越来越多的代码编译成本地代码，获得更高的执行效率

> - 前端编译器：把 .java 文件转化为 .class文件的过程
>
>   sun 的 Javac
>
> - 后端运行期编译器：把字节码转为机器码的过程
>
>   JIT编译器：hotSpot的C1、C2编译器
>
> - 静态提前编译器：直接把 .java 文件编译成本地代码的过程
>
>   GNU Compiler for the Java（GCJ）

