<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Go 的并发处理 | Fabian Bao</title><meta name="keywords" content="go,语法"><meta name="author" content="Fabian Bao"><meta name="copyright" content="Fabian Bao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Go 的并发处理">
<meta property="og:type" content="article">
<meta property="og:title" content="Go 的并发处理">
<meta property="og:url" content="https://fabian4.site/blog/20817.html">
<meta property="og:site_name" content="Fabian Bao">
<meta property="og:description" content="Go 的并发处理">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/u9vgyrxMZbcAEG2.png">
<meta property="article:published_time" content="2020-12-12T16:00:00.000Z">
<meta property="article:modified_time" content="2022-08-24T07:47:19.050Z">
<meta property="article:author" content="Fabian Bao">
<meta property="article:tag" content="go">
<meta property="article:tag" content="语法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/u9vgyrxMZbcAEG2.png"><link rel="shortcut icon" href="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/202015ouknbvshlsrvbku5.jpeg.icon.png"><link rel="canonical" href="https://fabian4.site/blog/20817"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/blog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-788W4F6C1Y"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-788W4F6C1Y');
</script><script>const GLOBAL_CONFIG = { 
  root: '/blog/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Go 的并发处理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-08-24 15:47:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/blog/atom.xml" title="Fabian Bao" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://fabian4.site/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">73</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/blog/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/blog/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/blog/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/blog/read/"><i class="fa-fw fa fa-book"></i><span> 阅读</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://fabian.oss-cn-hangzhou.aliyuncs.com/img/u9vgyrxMZbcAEG2.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/blog/">Fabian Bao</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/blog/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/blog/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/blog/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/blog/read/"><i class="fa-fw fa fa-book"></i><span> 阅读</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Go 的并发处理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-12-12T16:00:00.000Z" title="发表于 2020-12-13 00:00:00">2020-12-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-08-24T07:47:19.050Z" title="更新于 2022-08-24 15:47:19">2022-08-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/blog/categories/go/">go</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>42分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Go 的并发处理"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/blog/20817.html#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Go-的并发处理"><a href="#Go-的并发处理" class="headerlink" title="Go 的并发处理"></a>Go 的并发处理</h1><h2 id="一、Goroutine"><a href="#一、Goroutine" class="headerlink" title="一、Goroutine"></a>一、Goroutine</h2><p>在了解Goroutine并发之前，我们需要先了解下进程和线程,并发与并行 (Concurrency and Parallelism)的概念。</p>
<ul>
<li><p><strong>进程</strong>：进程是操作系统中进行保护和资源分配的基本单位，操作系统分配资源以进程为基本单位。</p>
<p>cpu在切换程序的时候，如果不保存上一个程序的状态（也就是我们常说的context–上下文），直接切换下一个程序，就会丢失上一个程序的一系列状态，于是引入了进程这个概念，用以划分好程序运行时所需要的资源。因此进程就是一个程序运行时候的所需要的基本资源单位（也可以说是程序运行的一个实体）。</p>
</li>
<li><p><strong>线程</strong>：线程是进程的组成部分，它代表了一条顺序的执行流。</p>
<p>cpu切换多个进程的时候，会花费不少的时间，因为切换进程需要切换到内核态，而每次调度需要内核态都需要读取用户态的数据，进程一旦多起来，cpu调度会消耗一大堆资源，因此引入了线程的概念，线程本身几乎不占有资源，他们共享进程里的资源，内核调度起来不会那么像进程切换那么耗费资源。</p>
<blockquote>
<p>进程是从操作系统获得基本的内存空间，所有的线程共享着进程的内存地址空间。此外，每个线程也会拥有自己私有的内存地址范围，其他线程不能访问。然而由于所有的线程共享进程的内存地址空间，所以线程间的通信就非常容易，通过共享进程级全局变量就可以实现线程间的通信。</p>
</blockquote>
</li>
<li><p><strong>协程</strong>：协程拥有自己的寄存器上下文和栈。<br>协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此，协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。线程和进程的操作是由程序触发系统接口，最后的执行者是系统；协程的操作执行者则是用户自身程序，goroutine也是协程。</p>
</li>
<li><p><strong>并发</strong>：并发是指程序的逻辑结构,交替做不同事的能力,在这里通常是不同程序交替执行的性能。</p>
</li>
<li><p><strong>并行</strong>：并行是指程序的运行状态,同时做不同事的能力,在这里通常是指不同程序同时执行的性能。</p>
</li>
</ul>
<p>如果某个系统支持两个或者多个动作（Action）同时存在，那么这个系统就是一个<strong>并发系统</strong>。如果某个系统支持两个或者多个动作同时执行，那么这个系统就是一个<strong>并行系统</strong>。</p>
<p>并发系统与并行系统这两个定义之间的关键差异在于“存在”这个词。在并发程序中可以同时拥有两个或者多个线程。这意味着，如果程序在单核处理器上运行，那么这两个线程将交替地换入或者换出内存。这些线程是同时“存在”的——每个线程都处于执行过程中的某个状态。如果程序能够并行执行，那么就一定是运行在多核处理器上。</p>
<p>此时，程序中的每个线程都将分配到一个独立的处理器核上，因此可以同时运行。这里相信你已经能够得出结论——“并行”概念是“并发”概念的一个子集。也就是说，你可以编写一个拥有多个线程或者进程的并发程序，但如果没有多核处理器来执行这个程序，那么就不能以并行方式来运行代码。因此，凡是在求解单个问题时涉及多个执行流程的编程模式或者执行行为，都属于并发编程的范畴。</p>
<p>Goroutine 的概念类似于线程，但 Goroutine 由 Go 程序运行时的调度和管理。Go 程序会将Goroutine 中的任务合理地分配给每个 CPU。Go 程序从 main 包的 main() 函数开始，在程序启动时，Go 程序就会为 main() 函数创建一个默认的 Goroutine。</p>
<p>Goroutine 是 Go语言原生支持并发的具体实现，在Go中的代码都是运行在Goroutine中的。Goroutine占用的资源非常小(Go 1.4将每个Goroutine stack的size默认设置为2k)，goroutine调度的切换也不用陷入(trap)操作系统内核层完成，代价很低。因此，一个Go程序中可以创建成千上万个并发的goroutine。</p>
<p>所有的Go代码都在goroutine中执行，即使是go的runtime也不例外。我们可以启动成千上万的goroutine，但是Go的runtime负责对goroutine进行调度。这里的调度就是决定何时哪个goroutine将获得资源开始执行、哪个goroutine应该停止执行让出资源、哪个goroutine应该被唤醒恢复执行等.</p>
<h3 id="Go的调度器"><a href="#Go的调度器" class="headerlink" title="Go的调度器"></a>Go的调度器</h3><p><strong>Go的调度器内部有三个重要的结构：G P M</strong></p>
<ul>
<li><p>G: 表示goroutine，存储了goroutine的执行stack信息、goroutine状态以及goroutine的任务函数等；另外G对象是可以重用的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> G &#123;</span><br><span class="line">    <span class="type">uintptr</span>    stackguard;  <span class="comment">// 分段栈的可用空间下界</span></span><br><span class="line">    <span class="type">uintptr</span>    stackbase;   <span class="comment">// 分段栈的栈基址</span></span><br><span class="line">    Gobuf      sched;       <span class="comment">//进程切换时，利用sched域来保存上下文</span></span><br><span class="line">    <span class="type">uintptr</span>    stack0;</span><br><span class="line">    FuncVal*   fnstart;     <span class="comment">// goroutine运行的函数</span></span><br><span class="line">    void*      param;       <span class="comment">// 用于传递参数，睡眠时其它goroutine设置param，唤醒时此goroutine可以获取</span></span><br><span class="line">    <span class="type">int16</span>      status;      <span class="comment">// 状态Gidle,Grunnable,Grunning,Gsyscall,Gwaiting,Gdead</span></span><br><span class="line">    <span class="type">int64</span>      goid;        <span class="comment">// goroutine的id号</span></span><br><span class="line">    G*         schedlink;</span><br><span class="line">    M*         m;           <span class="comment">// for debuggers, but offset not hard-coded</span></span><br><span class="line">    M*         lockedm;     <span class="comment">// G被锁定只能在这个m上运行</span></span><br><span class="line">    <span class="type">uintptr</span>    gopc;        <span class="comment">// 创建这个goroutine的go表达式的pc</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体G中的部分域如上所示。其中包含了栈信息stackbase和stackguard，还有运行的函数信息fnstart。这样就可以成为一个可执行的单元了，只要得到CPU就可以运行。goroutine切换时，上下文信息保存在结构体的sched域中。goroutine是轻量级的线程或者称为协程，切换时并不必陷入到操作系统内核中，所以保存过程很轻量。</p>
<p>而G中的Gobuf，只保存了当前栈指针，程序计数器，以及goroutine自身。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Gobuf &#123;</span><br><span class="line">    <span class="comment">// The offsets of these fields are known to (hard-coded in) libmach.</span></span><br><span class="line">    <span class="type">uintptr</span>    sp;</span><br><span class="line">    <span class="type">byte</span>*      pc;</span><br><span class="line">    G*         g;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里g是为了恢复当前goroutine的结构体G指针，运行时库中使用了一个常驻的寄存器extern register G* g，这个是当前goroutine的结构体G的指针。这样做是为了快速地访问goroutine中的信息.</p>
</li>
<li><p>P:  表示逻辑processor 代表cpu，P的数量决定了系统内最大可并行的G的数量（系统的物理cpu核数&gt;&#x3D;P的数量）；P的最大作用还是其拥有的各种G对象队列、链表、一些cache和状态。</p>
<p>在代码中结构体P的加入是为了提高Go程序的并发度，实现更好的调度。M代表OS线程。P代表Go代码执行时需要的资源。当M执行Go代码时，它需要关联一个P，当M为idle或者在系统调用中时，它也需要P。有刚好GOMAXPROCS个P。所有的P被组织为一个数组，在P上实现了工作流窃取的调度器。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> P &#123;</span><br><span class="line">    Lock;</span><br><span class="line">    <span class="type">uint32</span>    status;       <span class="comment">// Pidle或Prunning等</span></span><br><span class="line">    P*        link;</span><br><span class="line">    <span class="type">uint32</span>    schedtick;    <span class="comment">// 每次调度时将它加一</span></span><br><span class="line">    M*        m;           <span class="comment">// 链接到它关联的M (nil if idle)</span></span><br><span class="line">    MCache*   mcache;</span><br><span class="line"></span><br><span class="line">    G*        runq[<span class="number">256</span>];</span><br><span class="line">    <span class="type">int32</span>     runqhead;</span><br><span class="line">    <span class="type">int32</span>     runqtail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Available G&#x27;s (status == Gdead)</span></span><br><span class="line">    G*        gfree;</span><br><span class="line">    <span class="type">int32</span>     gfreecnt;</span><br><span class="line">    <span class="type">byte</span>      pad[<span class="number">64</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在P中有一个Grunnable的goroutine队列，这是一个P的局部队列。当P执行Go代码时，它会优先从自己的这个局部队列中取，这时可以不用加锁，提高了并发度。如果发现这个队列空了，则去其它P的队列中拿一半过来，这样实现工作流窃取的调度。这种情况下是需要给调用器加锁的。</p>
</li>
<li><p>M: M代表着执行计算资源。在绑定有效的p后，进入schedule循环；而schedule循环的机制大致是从各种队列、p的本地队列中获取G，切换到G的执行栈上并执行G的函数，调用goexit做清理工作并回到m，如此反复。M并不保留G状态，这是G可以跨M调度的基础。</p>
<p>M是machine的缩写，是对机器的抽象，每个m都是对应到一条操作系统的物理线程。M必须关联了P才可以执行Go代码，但是当它处理阻塞或者系统调用中时，可以不需要关联P。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> M &#123;</span><br><span class="line">    G*       g0;                 <span class="comment">// 带有调度栈的goroutine</span></span><br><span class="line">    G*       gsignal;            <span class="comment">// signal-handling G 处理信号的goroutine</span></span><br><span class="line">    void     (*mstartfn)(void);</span><br><span class="line">    G*       curg;               <span class="comment">// M中当前运行的goroutine</span></span><br><span class="line">    P*       p;                  <span class="comment">// 关联P以执行Go代码 (如果没有执行Go代码则P为nil)</span></span><br><span class="line">    P*       nextp;</span><br><span class="line">    <span class="type">int32</span>    id;</span><br><span class="line">    <span class="type">int32</span>    mallocing;         <span class="comment">//状态</span></span><br><span class="line">    <span class="type">int32</span>    throwing;</span><br><span class="line">    <span class="type">int32</span>    gcing;</span><br><span class="line">    <span class="type">int32</span>    locks;</span><br><span class="line">    <span class="type">int32</span>    helpgc;            <span class="comment">//不为0表示此m在做帮忙gc。helpgc等于n只是一个编号</span></span><br><span class="line">    <span class="type">bool</span>     blockingsyscall;</span><br><span class="line">    <span class="type">bool</span>     spinning;</span><br><span class="line">    Note     park;</span><br><span class="line">    M*       alllink;          <span class="comment">// 这个域用于链接allm</span></span><br><span class="line">    M*       schedlink;</span><br><span class="line">    MCache   *mcache;</span><br><span class="line">    G*       lockedg;</span><br><span class="line">    M*       nextwaitm;       <span class="comment">// next M waiting for lock</span></span><br><span class="line">    GCStats  gcstats;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和G类似，M中也有alllink域将所有的M放在allm链表中。lockedg是某些情况下，G锁定在这个M中运行而不会切换到其它M中去。M中还有一个MCache，是当前M的内存的缓存。M也和G一样有一个常驻寄存器变量，代表当前的M。同时存在多个M，表示同时存在多个物理线程。</p>
<p>结构体M中有两个G是需要关注一下的，一个是curg，代表结构体M当前绑定的结构体G。另一个是g0，是带有调度栈的goroutine，这是一个比较特殊的goroutine。普通的goroutine的栈是在堆上分配的可增长的栈，而g0的栈是M对应的线程的栈。所有调度相关的代码，会先切换到该goroutine的栈中再执行。</p>
</li>
</ul>
<p>G 代表 goroutine，M 可以看做真实的资源（OS Threads）。P是 G-M 的中间层，P是一个“逻辑Proccessor”，组织多个Goroutine跑在同一个 OS Thread 上。</p>
<p>对于G来说，P就是运行它的“CPU”，可以说：G的眼里只有P。但从Go scheduler视角来看，真正的“CPU”是M，只有将P和M绑定才能让P的runq中G得以真实运行起来。这样的P与M的关系，就好比Linux操作系统调度层面用户线程(user thread)与核心线程(kernel thread)的对应关系那样(N x M)。</p>
<p>一个 P上会挂着多个G，当一个G执行结束时，P会选择下一个 Goroutine 继续执行。而当一个Goroutine执行太久没有结束，这样就需要调度给后面的 Goroutine 运行的机会。所以，Go scheduler 除了在一个 Goroutine 执行结束时会调度后面的 Goroutine 执行，还会在正在被执行的 Goroutine 发生以下情况时让出当前 goroutine 的执行权，并调度后面的 Goroutine 执行：IO 操作,Channel 阻塞,system call,运行较长时间.</p>
<p>对于运行时间较长的Goroutine，scheduler会在其 G对象上打上一个标志（ preempt），当这个 goroutine 内部发生函数调用的时候，会先主动检查这个标志，如果为 true ,就需要主动调用Gosched()来让出CPU。</p>
<p>然而如果G被阻塞在某个channel操作或network I&#x2F;O操作上时，G会被放置到某个wait队列中，而M会尝试运行下一个runnable的G；如果此时没有runnable的G供m运行，那么m将解绑P，并进入sleep状态。当I&#x2F;O available或channel操作完成，在wait队列中的G会被唤醒，标记为runnable，放入到某P的队列中，绑定一个M继续执行。</p>
<p>如果G被阻塞在某个system call操作上，那么不光G会阻塞，执行该G的M也会解绑P，与G一起进入sleep状态。如果此时有idle的M，则P与其绑定继续执行其他G；如果没有idle M，但仍然有其他G要去执行，那么就会创建一个新M。</p>
<p>当阻塞在syscall上的G完成syscall调用后，G会去尝试获取一个可用的P，如果没有可用的P，那么G会被标记为runnable，之前的那个sleep的M将再次进入sleep。</p>
<h3 id="调度器状态的查看方法"><a href="#调度器状态的查看方法" class="headerlink" title="调度器状态的查看方法"></a>调度器状态的查看方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; GODEBUG=schedtrace=<span class="number">1000</span> godoc -http=:<span class="number">6060</span></span><br><span class="line"></span><br><span class="line">SCHED <span class="number">0</span>ms: gomaxprocs=<span class="number">4</span> idleprocs=<span class="number">2</span> threads=<span class="number">5</span> spinningthreads=<span class="number">1</span> idlethreads=<span class="number">0</span> runqueue=<span class="number">0</span> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">SCHED <span class="number">1007</span>ms: gomaxprocs=<span class="number">4</span> idleprocs=<span class="number">4</span> threads=<span class="number">27</span> spinningthreads=<span class="number">0</span> idlethreads=<span class="number">5</span> runqueue=<span class="number">0</span> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">SCHED <span class="number">2016</span>ms: gomaxprocs=<span class="number">4</span> idleprocs=<span class="number">3</span> threads=<span class="number">27</span> spinningthreads=<span class="number">0</span> idlethreads=<span class="number">5</span> runqueue=<span class="number">0</span> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">SCHED <span class="number">3017</span>ms: gomaxprocs=<span class="number">4</span> idleprocs=<span class="number">3</span> threads=<span class="number">27</span> spinningthreads=<span class="number">0</span> idlethreads=<span class="number">5</span> runqueue=<span class="number">0</span> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">SCHED <span class="number">4018</span>ms: gomaxprocs=<span class="number">4</span> idleprocs=<span class="number">1</span> threads=<span class="number">27</span> spinningthreads=<span class="number">0</span> idlethreads=<span class="number">5</span> runqueue=<span class="number">0</span> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">SCHED <span class="number">5018</span>ms: gomaxprocs=<span class="number">4</span> idleprocs=<span class="number">1</span> threads=<span class="number">27</span> spinningthreads=<span class="number">0</span> idlethreads=<span class="number">5</span> runqueue=<span class="number">0</span> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">SCHED <span class="number">6018</span>ms: gomaxprocs=<span class="number">4</span> idleprocs=<span class="number">2</span> threads=<span class="number">27</span> spinningthreads=<span class="number">0</span> idlethreads=<span class="number">5</span> runqueue=<span class="number">0</span> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">SCHED <span class="number">7018</span>ms: gomaxprocs=<span class="number">4</span> idleprocs=<span class="number">3</span> threads=<span class="number">27</span> spinningthreads=<span class="number">0</span> idlethreads=<span class="number">5</span> runqueue=<span class="number">0</span> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">SCHED <span class="number">8019</span>ms: gomaxprocs=<span class="number">4</span> idleprocs=<span class="number">3</span> threads=<span class="number">27</span> spinningthreads=<span class="number">0</span> idlethreads=<span class="number">5</span> runqueue=<span class="number">0</span> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">SCHED <span class="number">9020</span>ms: gomaxprocs=<span class="number">4</span> idleprocs=<span class="number">0</span> threads=<span class="number">27</span> spinningthreads=<span class="number">1</span> idlethreads=<span class="number">4</span> runqueue=<span class="number">0</span> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">SCHED <span class="number">10020</span>ms: gomaxprocs=<span class="number">4</span> idleprocs=<span class="number">3</span> threads=<span class="number">27</span> spinningthreads=<span class="number">0</span> idlethreads=<span class="number">5</span> runqueue=<span class="number">0</span> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>GODEBUG这个Go运行时环境变量非常有用，我们通过给其传入不同的key&#x3D;value,…组合，可以查看Go的runtime会输出不同的调试信息，比如在这里我们给GODEBUG传入了”schedtrace&#x3D;1000″，其含义就是每1000ms，打印输出一次goroutine scheduler的状态，每次一行.其他的状态如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SCHED <span class="number">1007</span>ms: gomaxprocs=<span class="number">4</span> idleprocs=<span class="number">4</span> threads=<span class="number">27</span> spinningthreads=<span class="number">0</span> idlethreads=<span class="number">5</span> runqueue=<span class="number">0</span> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">SCHED：     调试信息输出标志字符串，代表本行是goroutine scheduler的输出.</span><br><span class="line"><span class="number">1007</span>ms：    即从程序启动到输出这行日志的时间.</span><br><span class="line">gomaxprocs: P的数量.</span><br><span class="line">idleprocs:  处于idle状态的P的数量；通过gomaxprocs和idleprocs的差值，我们就可知道执行<span class="keyword">go</span>代码的P的数量.</span><br><span class="line">threads:    os threads的数量，包含scheduler使用的m数量，加上runtime自用的类似sysmon这样的thread的数量.</span><br><span class="line">spinningthreads: 处于自旋状态的os thread数量.</span><br><span class="line">idlethread: 处于idle状态的os thread的数量.</span><br><span class="line">runqueue=<span class="number">0</span>： <span class="keyword">go</span> scheduler全局队列中G的数量.</span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]:   分别为<span class="number">0</span>个P的local queue中的G的数量.</span><br></pre></td></tr></table></figure>

<h3 id="Goroutine的闭包函数"><a href="#Goroutine的闭包函数" class="headerlink" title="Goroutine的闭包函数"></a>Goroutine的闭包函数</h3><p>闭包函数可以直接引用外层代码定义的变量，需要注意的是，在闭包函数里面引用的是变量的地址，当goroutine被调度时，改地址的值才会被传递给goroutine 函数。</p>
<p>使用匿名函数或闭包创建 goroutine 时，除了将函数定义部分写在 go 的后面之外，还需要加上匿名函数的调用参数，格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">( 参数列表 )</span></span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;( 调用参数列表 )</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li>参数列表：函数体内的参数变量列表。</li>
<li>函数体：匿名函数的代码。</li>
<li>调用参数列表：启动 goroutine 时，需要向匿名函数传递的调用参数。</li>
</ul>
<h3 id="Goroutine的使用"><a href="#Goroutine的使用" class="headerlink" title="Goroutine的使用"></a>Goroutine的使用</h3><p>设置goroutine运行的CPU数量，最新版本的go已经默认已经设置了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num := runtime.NumCPU()    <span class="comment">//获取主机的逻辑CPU个数</span></span><br><span class="line">runtime.GOMAXPROCS(num)    <span class="comment">//设置可同时执行的最大CPU数</span></span><br></pre></td></tr></table></figure>

<p>应用示例:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">count</span><span class="params">(a <span class="type">int</span> , b <span class="type">int</span> )</span></span>  &#123;</span><br><span class="line">    c := a+b</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d + %d = %d\n&quot;</span>,a,b,c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i :=<span class="number">0</span> ; i&lt;<span class="number">10</span> ;i++&#123;</span><br><span class="line">        <span class="keyword">go</span> count(i,i+<span class="number">1</span>)  <span class="comment">//启动10个goroutine 来计算</span></span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Second * <span class="number">3</span>) <span class="comment">// sleep作用是为了等待所有任务完成</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>由于goroutine是异步执行的，那很有可能出现主程序退出时还有goroutine没有执行完，此时goroutine也会跟着退出。此时如果想等到所有goroutine任务执行完毕才退出，go提供了sync包和channel来解决同步问题，当然如果你能预测每个goroutine执行的时间，你还可以通过time.Sleep方式等待所有的groutine执行完成以后在退出程序。</p>
<h3 id="通过sync实现goroutine之间的同步"><a href="#通过sync实现goroutine之间的同步" class="headerlink" title="通过sync实现goroutine之间的同步"></a>通过sync实现goroutine之间的同步</h3><p>WaitGroup 等待一组goroutinue执行完毕. 主程序调用 Add 添加等待的goroutinue数量. 每个goroutinue在执行结束时调用 Done ，此时等待队列数量减1.，主程序通过Wait阻塞，直到等待队列为0.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">count</span><span class="params">(a ,b <span class="type">int</span>,n *sync.WaitGroup)</span></span>&#123;</span><br><span class="line">	c := a +b</span><br><span class="line">	fmt.Printf(<span class="string">&quot;The Result of %d + %d=%d\n&quot;</span>,a,b,c)</span><br><span class="line">	<span class="keyword">defer</span> n.Done() <span class="comment">//goroutinue完成后, WaitGroup的计数-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span> ;i++&#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>) <span class="comment">// WaitGroup的计数加1</span></span><br><span class="line">		<span class="keyword">go</span> count(i,i+<span class="number">1</span>,&amp;wg)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()  <span class="comment">//等待所有goroutine执行完毕</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">The Result of <span class="number">9</span> + <span class="number">10</span>=<span class="number">19</span></span><br><span class="line">The Result of <span class="number">7</span> + <span class="number">8</span>=<span class="number">15</span></span><br><span class="line">The Result of <span class="number">8</span> + <span class="number">9</span>=<span class="number">17</span></span><br><span class="line">The Result of <span class="number">5</span> + <span class="number">6</span>=<span class="number">11</span></span><br><span class="line">The Result of <span class="number">0</span> + <span class="number">1</span>=<span class="number">1</span></span><br><span class="line">The Result of <span class="number">1</span> + <span class="number">2</span>=<span class="number">3</span></span><br><span class="line">The Result of <span class="number">2</span> + <span class="number">3</span>=<span class="number">5</span></span><br><span class="line">The Result of <span class="number">3</span> + <span class="number">4</span>=<span class="number">7</span></span><br><span class="line">The Result of <span class="number">6</span> + <span class="number">7</span>=<span class="number">13</span></span><br><span class="line">The Result of <span class="number">4</span> + <span class="number">5</span>=<span class="number">9</span></span><br></pre></td></tr></table></figure>

<h3 id="通过channel实现goroutine之间的同步"><a href="#通过channel实现goroutine之间的同步" class="headerlink" title="通过channel实现goroutine之间的同步"></a>通过channel实现goroutine之间的同步</h3><p>通过channel能在多个groutine之间通讯，当一个goroutine完成时候向channel发送退出信号,等所有goroutine退出时候，利用for循环channe去channel中的信号，若取不到数据会阻塞原理，等待所有goroutine执行完毕，使用该方法有个前提是你已经知道了你启动了多少个goroutine。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">count</span><span class="params">(a <span class="type">int</span> , b <span class="type">int</span> ,exitChan <span class="keyword">chan</span> <span class="type">bool</span>)</span></span>  &#123;</span><br><span class="line">	c := a+b</span><br><span class="line">    fmt.Printf(<span class="string">&quot;The Result of %d + %d = %d\n&quot;</span>,a,b,c)</span><br><span class="line">	time.Sleep(time.Second*<span class="number">2</span>)</span><br><span class="line">	exitChan &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	exitChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>,<span class="number">10</span>)  <span class="comment">//声明并分配管道内存</span></span><br><span class="line">	<span class="keyword">for</span> i :=<span class="number">0</span> ; i&lt;<span class="number">10</span> ;i++&#123;</span><br><span class="line">		<span class="keyword">go</span> count(i,i+<span class="number">1</span>,exitChan)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> j :=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++&#123;</span><br><span class="line">		&lt;- exitChan  <span class="comment">//取信号数据，如果取不到则会阻塞e</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(exitChan) <span class="comment">// 关闭管道</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">The Result of <span class="number">9</span> + <span class="number">10</span> = <span class="number">19</span></span><br><span class="line">The Result of <span class="number">0</span> + <span class="number">1</span> = <span class="number">1</span></span><br><span class="line">The Result of <span class="number">7</span> + <span class="number">8</span> = <span class="number">15</span></span><br><span class="line">The Result of <span class="number">6</span> + <span class="number">7</span> = <span class="number">13</span></span><br><span class="line">The Result of <span class="number">3</span> + <span class="number">4</span> = <span class="number">7</span></span><br><span class="line">The Result of <span class="number">4</span> + <span class="number">5</span> = <span class="number">9</span></span><br><span class="line">The Result of <span class="number">1</span> + <span class="number">2</span> = <span class="number">3</span></span><br><span class="line">The Result of <span class="number">2</span> + <span class="number">3</span> = <span class="number">5</span></span><br><span class="line">The Result of <span class="number">8</span> + <span class="number">9</span> = <span class="number">17</span></span><br><span class="line">The Result of <span class="number">5</span> + <span class="number">6</span> = <span class="number">11</span></span><br></pre></td></tr></table></figure>



<h2 id="二、Channel"><a href="#二、Channel" class="headerlink" title="二、Channel"></a>二、Channel</h2><h3 id="Channel-管道"><a href="#Channel-管道" class="headerlink" title="Channel 管道"></a>Channel 管道</h3><p>Channel是Go中的一个核心类型，你可以把它看成一个管道，通过它并发核心单元就可以发送或者接收数据进行通讯(communication).</p>
<p>Channel用于数据传递或数据共享，其本质上是一个先进先出的队列，使用Goroutine 和channel进行数据通讯简单高效，同时也线程安全，多个Goroutine可同时修改一个Channel，不需要加锁。</p>
<p>管道是一系列由channel联通的状态（stage），而每个状态是一组运行相同函数的Goroutine。在每个状态的Goroutine上:</p>
<ul>
<li>通过流入（inbound）channel接收上游的数值.</li>
<li>运行一些函数来处理接收的数据，一般会产生新的数值.</li>
<li>通过流出（outbound）channel将数值发给下游.</li>
</ul>
<p>每个语态都会有任意个流入或者流出channel，除了第一个状态（只有流出channel）和最后一个状态（只有流入channel）。第一个状态有时被称作源或者生产者；最后一个状态有时被称作槽（sink）或者消费者。</p>
<h4 id="创建-Channel"><a href="#创建-Channel" class="headerlink" title="创建 Channel"></a>创建 Channel</h4><p>我们先从简单开始使用内置的make函数,创建一个Channel:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="string">``</span><span class="string">``</span></span><br><span class="line"></span><br><span class="line">然而每个channel都有一个特殊的类型,也就是channels可发送数据的类型。一个可以发送<span class="type">int</span>类型数据的channel一般写为<span class="keyword">chan</span> <span class="type">int</span>，一个channel有发送和接受两个主要操作,都是通信行为。一个发送语句将一个值从一个goroutine通过channel发送到另一个执行接收操作的goroutine。发送和接收两个操作都是用&lt;-运算符。</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`go</span></span><br><span class="line"><span class="string">ch &lt;- p    // 发送值p到Channel ch中</span></span><br><span class="line"><span class="string">p := &lt;-ch  // 从Channel ch中接收数据，并将数据赋值给p</span></span><br></pre></td></tr></table></figure>

<p>注意：在channel中箭头的指向是数据的流向．</p>
<p>和map类似,channel也一个对应make创建的底层数据结构的引用。当我们复制一个channel或用于函数参数传递时,我们只是拷贝了一个channel引用,因此调用者何被调用者将引用同一个channel对象。和其它的引用类型一样,channel的零值也是nil。两个相同类型的channel可以使用&#x3D;&#x3D;运算符比较。如果两个channel引用的是相通的对象,那么比较的结果为真。一个channel也可以和nil进行比较。</p>
<p>Channel类型的定义格式：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChannelType = ( <span class="string">&quot;chan&quot;</span> | <span class="string">&quot;chan&quot;</span> <span class="string">&quot;&lt;-&quot;</span> | <span class="string">&quot;&lt;-&quot;</span> <span class="string">&quot;chan&quot;</span> ) Type .</span><br></pre></td></tr></table></figure>

<p>它包括三种类型的定义。可选的&lt;-代表channel的方向。如果没有指定方向，那么Channel就是双向的，既可以接收数据，也可以发送数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">chan</span> p            <span class="comment">// 可以接收和发送类型为p的数据</span></span><br><span class="line"><span class="keyword">chan</span>&lt;- <span class="type">float64</span>   <span class="comment">// 只可以用来发送 float64 类型的数据</span></span><br><span class="line">&lt;-<span class="keyword">chan</span> <span class="type">int</span>       <span class="comment">// 只可以用来接收 int 类型的数据</span></span><br></pre></td></tr></table></figure>

<p>这里需要注意下：&lt;-总是优先和最左边的类型结合。</p>
<p>使用make初始化Channel,我们还可以设置channel的容量,容量(capacity)代表Channel容纳的最多的元素的数量，代表Channel的缓存的大小。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)    <span class="comment">// 无缓冲 channel</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">0</span>) <span class="comment">// 无缓冲 channel</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">3</span>) <span class="comment">// 缓冲 channel容量是3</span></span><br></pre></td></tr></table></figure>

<p>如果没有设置容量，或者容量设置为0, 说明Channel没有缓存，只有sender和receiver都准备好了后它们的通讯(communication)才会发生(Blocking)。如果设置了缓存，就有可能不发生阻塞， 只有buffer满了后 send才会阻塞， 而只有缓存空了后receive才会阻塞。一个nil channel不会通信。</p>
<h4 id="无缓冲的Channels"><a href="#无缓冲的Channels" class="headerlink" title="无缓冲的Channels"></a>无缓冲的Channels</h4><p>无缓冲：发送和接收动作是同时发生的Channels的发送和接收操作将导致两个goroutine做一次同步操作。因为这个原因，无缓存Channels有时候也被称为同步Channels。如果没有 goroutine 读取 channel （&lt;- channel），则发送者 (channel &lt;-) 会一直阻塞。</p>
<h4 id="缓冲的Channels"><a href="#缓冲的Channels" class="headerlink" title="缓冲的Channels"></a>缓冲的Channels</h4><p>缓冲：缓冲 channel 类似一个有容量的队列。当队列满的时候发送者会阻塞；当队列空的时候接收者会阻塞。</p>
<p>此外在使用channel之后可以进行关闭，关闭channel后,对该channel的任何发送操作都将导致panic异常。对一个已经被close过的channel之行接收操作依然可以接受到之前已经成功发送的数据;如果channel中已经没有数据的话讲产生一个零值的数据。</p>
<p>使用内置的close函数就可以关闭一个channel:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure>

<p>但是关于关闭channel 有几点需要注意:</p>
<ul>
<li>重复关闭 channel 会导致 panic.</li>
<li>向关闭的 channel 发送数据会 panic.</li>
<li>从关闭的 channel 读数据不会 panic，读出channel中已有的数据之后再读就是channel类似的默认值，比如 chan int 类型的channel关闭之后读取到的值为 0.</li>
</ul>
<p>这里我们需要区分一下第三种channel 中的值是默认值还是channel 关闭了。可以使用 ok-idiom 方式，这种方式在 map 中比较常用.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)</span><br><span class="line">...</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ok-idiom </span></span><br><span class="line">val, ok := &lt;-ch</span><br><span class="line"><span class="keyword">if</span> ok == <span class="literal">false</span> &#123;</span><br><span class="line">    <span class="comment">// channel closed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Channel的典型用法"><a href="#Channel的典型用法" class="headerlink" title="Channel的典型用法"></a>Channel的典型用法</h3><h4 id="goroutine-使用channel通信"><a href="#goroutine-使用channel通信" class="headerlink" title="goroutine 使用channel通信"></a>goroutine 使用channel通信</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        x &lt;- <span class="number">1</span></span><br><span class="line">    &#125;()</span><br><span class="line">    &lt;-x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>select语句选择一组可能的send操作和receive操作去处理。它类似switch,但是只是用来处理通讯(communication)操作。<br>它的case可以是send语句，也可以是receive语句，亦或者default。</p>
<p>receive语句可以将值赋值给一个或者两个变量。它必须是一个receive操作。</p>
<p>select在一定程度上可以类比于linux中的 IO 多路复用中的 select。后者相当于提供了对多个 IO 事件的统一管理，而 Golang 中的 select 相当于提供了对多个 channel 的统一管理。当然这只是 select 在 channel 上的一种使用方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> e, ok := &lt;-ch1:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> e, ok := &lt;-ch2:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是 select 中的 break 只能跳到 select 这一层。select 使用的时候一般需要配合 for 循环使用，因为正常 select 里面的流程也就执行一遍。这么来看 select 中的 break 就稍显鸡肋了。所以使用 break 的时候一般配置 label 使用，label 定义在 for循环这一层。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="range-channel"><a href="#range-channel" class="headerlink" title="range channel"></a>range channel</h4><p>使用range channel 我们可以直接取到 channel 中的值。当我们使用 range 来操作 channel 的时候，一旦 channel 关闭，channel 内部数据读完之后循环自动结束。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> x := <span class="keyword">range</span> ch &#123;</span><br><span class="line">        fmt.Println(x)</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">producer</span><span class="params">(ch <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> values &#123;</span><br><span class="line">      ch &lt;- v</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="超时控制"><a href="#超时控制" class="headerlink" title="超时控制"></a>超时控制</h4><p>select有很重要的一个应用就是超时处理。由于如果没有case需要处理，select语句就会一直阻塞着。这时候我们可能就需要一个超时操作，用来处理超时的情况通常在很多操作情况下都需要超时控制，我们可以利用 select 实现超时控制:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">        c1 &lt;- <span class="string">&quot;result 1&quot;</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> res := &lt;-c1:</span><br><span class="line">        fmt.Println(res)</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">1</span>):</span><br><span class="line">        fmt.Println(<span class="string">&quot;timeout 1&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里利用的是time.After方法，它返回一个类型为&lt;-chan Time的单向的channel，在指定的时间发送一个当前时间给返回的channel中。</p>
<h4 id="channel同步"><a href="#channel同步" class="headerlink" title="channel同步"></a>channel同步</h4><p>channel可以用在goroutine之间的同步。<br>下面的例子main中goroutine通过done channel等待 mission完成任务。 mission做完任务后只需往channel发送一个数据就可以通知main goroutine任务完成。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mission</span><span class="params">(done <span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	<span class="comment">// 通知任务已完成</span></span><br><span class="line">	done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> mission(done)</span><br><span class="line">	<span class="comment">// 等待任务完成</span></span><br><span class="line">	&lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Golang中的channel 将goroutine 隔离开，并发编程的时候可以将注意力放在 channel 上。在一定程度上，这个和消息队列的解耦功能还是挺像的。</p>
<h4 id="扇出和扇入"><a href="#扇出和扇入" class="headerlink" title="扇出和扇入"></a>扇出和扇入</h4><p>通常情况下多个函数可以同时从一个channel接收数据，直到channel关闭，这种情况被称作扇出。这是一种将工作分布给一组工作者的方法，目的是并行使用CPU和I&#x2F;O。</p>
<p>如果一个函数同时接收并处理多个channel输入并转化为一个输出channel，直到所有的输入channel都关闭后，关闭输出channel，这种情况就被称作扇入。</p>
<p>但是main可以容易的通过关闭done　channel来释放所有的发送者。关闭是个高效的发送给所有发送者的信号。我们扩展channel管道里的每个函数，让其以参数方式接收done，并通过defer语句在函数退出时执行关闭操作，这样main里所有的退出路径都会触发管道里的所有状态退出。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 构建done channel，整个管道里分享done，并在管道退出时关闭这个channel</span></span><br><span class="line">    <span class="comment">// 以此通知所有Goroutine该推出了。</span></span><br><span class="line">    done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(done)</span><br><span class="line"></span><br><span class="line">    in := gen(done, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发布sq的工作到两个都从in里读取数据的Goroutine</span></span><br><span class="line">    c1 := sq(done, in)</span><br><span class="line">    c2 := sq(done, in)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理来自output的第一个数值</span></span><br><span class="line">    out := merge(done, c1, c2)</span><br><span class="line">    fmt.Println(&lt;-out) <span class="comment">// 4 或者 9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// done会通过defer调用而关闭</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sq</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> n := <span class="keyword">range</span> in &#123;</span><br><span class="line">            out &lt;- n*n</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(out)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>merge对每个流入channel启动一个Goroutine，并将流入的数值复制到流出channel，由此将一组channel转换到一个channel。一旦启动了所有的output  Goroutine，merge函数会多启动一个Goroutine，这个Goroutine在所有的输入channel输入完毕后，关闭流出channel。sq函数是把上一个函数的chan最为参数，下一个输出的chan作为返回值。</p>
<p>但是往一个已经关闭的channel输出会产生异常（panic），所以一定要保证所有数据发送完成后再执行关闭。</p>
<p>所以发送Goroutine将发送操作替换为一个select语句，要么把数据发送给out，要么处理来自done的数值。done的类型是个空结构，因为具体数值并不重要：接收事件本身就指明了应当放弃继续发送给out的动作。而output Goroutine会继续循环处理流入的channel，c,而不会阻塞上游状态.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gen函数启动一个Goroutine，将整数数列发送给channel，如果所有数都发送完成，关闭这个channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gen</span><span class="params">(nums ...<span class="type">int</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line"> out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    <span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        out &lt;- n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(out)</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从一个channel接收整数，并求整数的平方，发送给另一个channel.</span></span><br><span class="line"><span class="comment">// mission的循环中退出，因为我们知道如果done已经被关闭了，也会关闭上游的gen状态.</span></span><br><span class="line"><span class="comment">// mission通过defer语句，保证不管从哪个返回路径，它的out channel都会被关闭.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mission</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> <span class="built_in">close</span>(out)</span><br><span class="line">        <span class="keyword">for</span> n := <span class="keyword">range</span> in &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> out &lt;- n * n:</span><br><span class="line">            <span class="keyword">case</span> &lt;-done:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(cs ...&lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &lt;-<span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为每个cs中的输入channel启动一个output Goroutine。outpu从c里复制数值直到c被关闭</span></span><br><span class="line">    <span class="comment">// 或者从done里接收到数值，之后output调用wg.Done</span></span><br><span class="line">    output := <span class="function"><span class="keyword">func</span><span class="params">(c &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> n := <span class="keyword">range</span> c &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            	<span class="keyword">case</span> out &lt;- n:</span><br><span class="line">            	<span class="keyword">case</span> &lt;-done:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        wg.Done()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Add(<span class="built_in">len</span>(cs))</span><br><span class="line">    <span class="keyword">for</span> _, c := <span class="keyword">range</span> cs &#123;</span><br><span class="line">        <span class="keyword">go</span> output(c)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动一个Goroutine，当所有output Goroutine都工作完后（wg.Done），关闭out，</span></span><br><span class="line">    <span class="comment">// 保证只关闭一次。这个Goroutine必须在wg.Add之后启动</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        wg.Wait()</span><br><span class="line">        <span class="built_in">close</span>(out)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在channel模式中有个模式:</p>
<ul>
<li><p>状态会在所有发送操作做完后，关闭它们的流出channel</p>
</li>
<li><p>状态会持续接收从流入channel输入的数值，直到channel关闭</p>
</li>
</ul>
<p>这个模式使得每个接收状态可以写为一个range循环，并保证所有的Goroutine在将所有的数值发送成功给下游后立刻退出。</p>
<p>所以在构建channel的时候:</p>
<ul>
<li>状态会在所有发送操作做完后，关闭它们的流出channel.</li>
<li>状态会持续接收从流入channel输入的数值，直到channel关闭或者其发送者被释放.</li>
</ul>
<p>因而管道要么保证足够能存下所有发送数据的缓冲区，要么接收来自接收者明确的要放弃channel的信号，来保证释放发送者。</p>
<h2 id="三、Sync-WaitGroup解析"><a href="#三、Sync-WaitGroup解析" class="headerlink" title="三、Sync.WaitGroup解析"></a>三、Sync.WaitGroup解析</h2><p>Golang中的同步可以通过Sync.WaitGroup来实现的．WaitGroup的功能，它实现了一个类似队列的结构，可以一直向队列中添加任务，当任务完成后便从队列中删除，如果队列中的任务没有完全完成，可以通过Wait()函数来出发阻塞，防止程序继续进行，直到所有的队列任务都完成为止．</p>
<p>WaitGroup的特点是,Wait()方法可以用来阻塞直到队列中的所有任务都完成时才解除阻塞，而不需要sleep一个固定的时间来等待．但是其缺点是无法指定固定的Goroutine数目,我们可以通过使用channel解决这个问题。</p>
<p>Sync.WaitGroup中有3个方法，Add()，Done()，Wait()。其中Done()是Add(-1)的别名。</p>
<p>Sync.WaitGroup中三个方法的作用是：</p>
<ul>
<li>Add:添加或者减少等待goroutine的数量</li>
<li>Done:相当于Add(-1),减掉一个goroutine计数，计数不为0</li>
<li>Wait:执行阻塞，直到所有的WaitGroup数量变成0</li>
</ul>
<p>这里需要注意下，Sync中的Add()方法和Done方法。即在运行main函数的goroutine里运行Add()方法，在其他的goroutine里面运行Done()函数。</p>
<p>Add()方法添加将可能为负的增量添加到WaitGroup计数器。如果计数器变为零，则释放在等待时阻止的所有goroutine。如果计数器变为负数，则panic。<br>请注意，在计数器为零时发生的具有正增量的调用时必须在Wait()方法之前。 具有负增量的调用或具有在计数器大于零时开始的正增量的调用可以在任何时间发生。<br>通常，这意味着对Add的调用应该在语句之前执行,创建要等待的goroutine或其他事件。如果重新使用WaitGroup等待几个独立的事件集，新的Add()调用必须在所有先前的Wait()调用返回后发生。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Add(delta <span class="type">int</span>) &#123;</span><br><span class="line">	statep, semap := wg.state()</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = *statep <span class="comment">// trigger nil deref early</span></span><br><span class="line">		<span class="keyword">if</span> delta &lt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// Synchronize decrements with Wait.</span></span><br><span class="line">			race.ReleaseMerge(unsafe.Pointer(wg))</span><br><span class="line">		&#125;</span><br><span class="line">		race.Disable()</span><br><span class="line">		<span class="keyword">defer</span> race.Enable()</span><br><span class="line">	&#125;</span><br><span class="line">	state := atomic.AddUint64(statep, <span class="type">uint64</span>(delta)&lt;&lt;<span class="number">32</span>)</span><br><span class="line">	v := <span class="type">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line">	w := <span class="type">uint32</span>(state)</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &amp;&amp; delta &gt; <span class="number">0</span> &amp;&amp; v == <span class="type">int32</span>(delta) &#123;</span><br><span class="line">		<span class="comment">// The first increment must be synchronized with Wait.</span></span><br><span class="line">		<span class="comment">// Need to model this as a read, because there can be</span></span><br><span class="line">		<span class="comment">// several concurrent wg.counter transitions from 0.</span></span><br><span class="line">		race.Read(unsafe.Pointer(semap))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> v &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;sync: negative WaitGroup counter&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; delta &gt; <span class="number">0</span> &amp;&amp; v == <span class="type">int32</span>(delta) &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup misuse: Add called concurrently with Wait&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> v &gt; <span class="number">0</span> || w == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// This goroutine has set counter to 0 when waiters &gt; 0.</span></span><br><span class="line">	<span class="comment">// Now there can&#x27;t be concurrent mutations of state:</span></span><br><span class="line">	<span class="comment">// - Adds must not happen concurrently with Wait,</span></span><br><span class="line">	<span class="comment">// - Wait does not increment waiters if it sees counter == 0.</span></span><br><span class="line">	<span class="comment">// Still do a cheap sanity check to detect WaitGroup misuse.</span></span><br><span class="line">	<span class="keyword">if</span> *statep != state &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup misuse: Add called concurrently with Wait&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Reset waiters count to 0.</span></span><br><span class="line">	*statep = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> ; w != <span class="number">0</span>; w-- &#123;</span><br><span class="line">		runtime_Semrelease(semap, <span class="literal">false</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Done()方法将WaitGroup计数器减1</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Done() &#123;</span><br><span class="line">	wg.Add(<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Wait()直到WaitGroup计数器为零</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Wait() &#123;</span><br><span class="line">	statep, semap := wg.state()</span><br><span class="line">	<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">		_ = *statep <span class="comment">// trigger nil deref early</span></span><br><span class="line">		race.Disable()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		state := atomic.LoadUint64(statep)</span><br><span class="line">		v := <span class="type">int32</span>(state &gt;&gt; <span class="number">32</span>)</span><br><span class="line">		w := <span class="type">uint32</span>(state)</span><br><span class="line">		<span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// Counter is 0, no need to wait.</span></span><br><span class="line">			<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">				race.Enable()</span><br><span class="line">				race.Acquire(unsafe.Pointer(wg))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Increment waiters count.</span></span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapUint64(statep, state, state+<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> race.Enabled &amp;&amp; w == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// Wait must be synchronized with the first Add.</span></span><br><span class="line">				<span class="comment">// Need to model this is as a write to race with the read in Add.</span></span><br><span class="line">				<span class="comment">// As a consequence, can do the write only for the first waiter,</span></span><br><span class="line">				<span class="comment">// otherwise concurrent Waits will race with each other.</span></span><br><span class="line">				race.Write(unsafe.Pointer(semap))</span><br><span class="line">			&#125;</span><br><span class="line">			runtime_Semacquire(semap)</span><br><span class="line">			<span class="keyword">if</span> *statep != <span class="number">0</span> &#123;</span><br><span class="line">				<span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup is reused before previous Wait has returned&quot;</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> race.Enabled &#123;</span><br><span class="line">				race.Enable()</span><br><span class="line">				race.Acquire(unsafe.Pointer(wg))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用示例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">5</span>;i=i+<span class="number">1</span>&#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="comment">//defer wg.Done(),注意这个Done的位置，是另一个函数</span></span><br><span class="line">			<span class="keyword">defer</span> wg.Add(<span class="number">-1</span>)</span><br><span class="line">			EchoNumber(n)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EchoNumber</span><span class="params">(i <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">	time.Sleep(time.Millisecond *<span class="number">2000</span>)</span><br><span class="line">	fmt.Println(i)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>这个应用示例很简单，是将每次循环的数量过3秒钟输出。那么，这个程序如果不用WaitGroup，那么将看不见输出结果。因为Goroutine还没执行完，主线程已经执行完毕。注释的defer wg.Done()和defer wg.Add(-1)作用一样。</p>
<h2 id="四、Sync-Map解析"><a href="#四、Sync-Map解析" class="headerlink" title="四、Sync.Map解析"></a>四、Sync.Map解析</h2><p>在Go1.9之前，Go自带的Map不是并发安全的,因此我们需要自己再封装一层，给Map加上把读写锁,例如:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MapWithLock <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">    M <span class="keyword">map</span>[<span class="type">string</span>]Kline</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用MapWithLock的读写锁去控制map的并发安全。</p>
<p>但是到了Go1.9发布，它有了一个新的特性，那就是sync.map，它是原生支持并发安全的map，不过它的用法和以前我们熟悉的map完全不一样，主要还是因为sync.map封装了更为复杂的数据结构，用来实现比之前加锁map更优秀的性能。</p>
<p>空间换时间。 通过冗余的两个数据结构(read、dirty),实现加锁对性能的影响。使用只读数据(read)，避免读写冲突。动态调整，miss次数多了之后，将dirty数据提升为read。double-checking。<br>延迟删除。 删除一个键值只是打标记，只有在提升dirty的时候才清理删除的数据。<br>优先从read读取、更新、删除，因为对read的读取不需要锁。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 当涉及到dirty数据的操作的时候，需要使用这个锁</span></span><br><span class="line">    mu Mutex</span><br><span class="line">    <span class="comment">// 一个只读的数据结构，因为只读，所以不会有读写冲突。</span></span><br><span class="line">    <span class="comment">// 所以从这个数据中读取总是安全的。</span></span><br><span class="line">    <span class="comment">// 实际上，实际也会更新这个数据的entries,如果entry是未删除的(unexpunged), 并不需要加锁。如果entry已经被删除了，需要加锁，以便更新dirty数据。</span></span><br><span class="line">    read atomic.Value <span class="comment">// readOnly</span></span><br><span class="line">    <span class="comment">// dirty数据包含当前的map包含的entries,它包含最新的entries(包括read中未删除的数据,虽有冗余，但是提升dirty字段为read的时候非常快，不用一个一个的复制，而是直接将这个数据结构作为read字段的一部分),有些数据还可能没有移动到read字段中。</span></span><br><span class="line">    <span class="comment">// 对于dirty的操作需要加锁，因为对它的操作可能会有读写竞争。</span></span><br><span class="line">    <span class="comment">// 当dirty为空的时候， 比如初始化或者刚提升完，下一次的写操作会复制read字段中未删除的数据到这个数据中。</span></span><br><span class="line">    dirty <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span><br><span class="line">    <span class="comment">// 当从Map中读取entry的时候，如果read中不包含这个entry,会尝试从dirty中读取，这个时候会将misses加一，</span></span><br><span class="line">    <span class="comment">// 当misses累积到 dirty的长度的时候， 就会将dirty提升为read,避免从dirty中miss太多次。因为操作dirty需要加锁。</span></span><br><span class="line">    misses <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的数据结构很简单，值包含四个字段：read、mu、dirty、misses。</p>
<p>readOnly.m和Map.dirty存储的值类型是*entry,它包含一个指针p, 指向用户存储的value值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> entry <span class="keyword">struct</span> &#123;</span><br><span class="line">    p unsafe.Pointer <span class="comment">// *interface&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>p通常有三种类型的值:</p>
<ul>
<li>nil: entry已被删除了，并且m.dirty为nil</li>
<li>expunged: entry已被删除了，并且m.dirty不为nil，而且这个entry不存在于m.dirty中</li>
<li>其它： entry是一个正常的值</li>
</ul>
<p>它使用了冗余的数据结构read、dirty。dirty中会包含read中为删除的entries，新增加的entries会加入到dirty中。<br>read的数据结构是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123;</span><br><span class="line">    m       <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry</span><br><span class="line">    amended <span class="type">bool</span> <span class="comment">// 如果Map.dirty有些数据不在中的时候，这个值为true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>amended指明Map.dirty中有readOnly.m未包含的数据，所以如果从Map.read找不到数据的话，还要进一步到Map.dirty中查找。</p>
<p>对Map.read的修改是通过原子操作进行的。</p>
<p>虽然read和dirty有冗余数据，但这些数据是通过指针指向同一个数据，所以尽管Map的value会很大，但是冗余的空间占用还是有限的。</p>
<p>sync.Map主要有五个方法:</p>
<p>1、Load   取key对应的value</p>
<p>2、Store   存 key,value</p>
<p>3、Delete   删除key,及其value</p>
<p>4、Range   遍历所有的key,value</p>
<h3 id="Load方法"><a href="#Load方法" class="headerlink" title="Load方法"></a>Load方法</h3><p>Load方法，提供一个键key,查找对应的值value,如果不存在，通过ok反映：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Load(key <span class="keyword">interface</span>&#123;&#125;) (value <span class="keyword">interface</span>&#123;&#125;, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 1.首先从m.read中得到只读readOnly,从它的map中查找，不需要加锁</span></span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    e, ok := read.m[key]</span><br><span class="line">    <span class="comment">// 2. 如果没找到，并且m.dirty中有新数据，需要从m.dirty查找，这个时候需要加锁</span></span><br><span class="line">    <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        <span class="comment">// 双检查，避免加锁的时候m.dirty提升为m.read,这个时候m.read可能被替换了。</span></span><br><span class="line">        read, _ = m.read.Load().(readOnly)</span><br><span class="line">        e, ok = read.m[key]</span><br><span class="line">        <span class="comment">// 如果m.read中还是不存在，并且m.dirty中有新数据</span></span><br><span class="line">        <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">            <span class="comment">// 从m.dirty查找</span></span><br><span class="line">            e, ok = m.dirty[key]</span><br><span class="line">            <span class="comment">// 不管m.dirty中存不存在，都将misses计数加一</span></span><br><span class="line">            <span class="comment">// missLocked()中满足条件后就会提升m.dirty</span></span><br><span class="line">            m.missLocked()</span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e.load()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会先从m.read中加载，不存在的情况下，并且m.dirty中有新数据，加锁，然后从m.dirty中加载。其次是这里使用了双检查的处理，因为在下面的两个语句中，这两行语句并不是一个原子操作。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">        m.mu.Lock()</span><br></pre></td></tr></table></figure>

<p>当第一句执行的时候条件满足，但是在加锁之前，m.dirty可能被提升为m.read,所以加锁后还得再检查m.read，后续的方法中都使用了这个方法。</p>
<p>如果我们查询的键值正好存在于m.read中，无须加锁，直接返回，理论上性能优异。即使不存在于m.read中，经过miss几次之后，m.dirty会被提升为m.read，又会从m.read中查找。所以对于更新／增加较少，加载存在的key很多的case,性能基本和无锁的map类似。<br>接着我们看下如何m.dirty是如何被提升的。 missLocked方法中可能会将m.dirty提升。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> missLocked() &#123;</span><br><span class="line">    m.misses++</span><br><span class="line">    <span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    m.read.Store(readOnly&#123;m: m.dirty&#125;)</span><br><span class="line">    m.dirty = <span class="literal">nil</span></span><br><span class="line">    m.misses = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的最后三行代码就是提升m.dirty的，很简单的将m.dirty作为readOnly的m字段，原子更新m.read。提升后m.dirty、m.misses重置， 并且m.read.amended为false。</p>
<h3 id="Store方法"><a href="#Store方法" class="headerlink" title="Store方法"></a>Store方法</h3><ul>
<li>Store方法是更新或者新增一个entry。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Store(key, value <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    <span class="comment">// 如果m.read存在这个键，并且这个entry没有被标记删除，尝试直接存储。</span></span><br><span class="line">    <span class="comment">// 因为m.dirty也指向这个entry,所以m.dirty也保持最新的entry。</span></span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果`m.read`不存在或者已经被标记删除</span></span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    read, _ = m.read.Load().(readOnly)</span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">        <span class="keyword">if</span> e.unexpungeLocked() &#123; <span class="comment">//标记成未被删除</span></span><br><span class="line">            m.dirty[key] = e <span class="comment">//m.dirty中不存在这个键，所以加入m.dirty</span></span><br><span class="line">        &#125;</span><br><span class="line">        e.storeLocked(&amp;value) <span class="comment">//更新</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123; <span class="comment">// m.dirty存在这个键，更新</span></span><br><span class="line">        e.storeLocked(&amp;value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//新键值</span></span><br><span class="line">        <span class="keyword">if</span> !read.amended &#123; <span class="comment">//m.dirty中没有新的数据，往m.dirty中增加第一个新键</span></span><br><span class="line">            m.dirtyLocked() <span class="comment">//从m.read中复制未删除的数据</span></span><br><span class="line">            m.read.Store(readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        m.dirty[key] = newEntry(value) <span class="comment">//将这个entry加入到m.dirty中</span></span><br><span class="line">    &#125;</span><br><span class="line">    m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> dirtyLocked() &#123;</span><br><span class="line">    <span class="keyword">if</span> m.dirty != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    m.dirty = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]*entry, <span class="built_in">len</span>(read.m))</span><br><span class="line">    <span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">        <span class="keyword">if</span> !e.tryExpungeLocked() &#123;</span><br><span class="line">            m.dirty[k] = e</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> tryExpungeLocked() (isExpunged <span class="type">bool</span>) &#123;</span><br><span class="line">    p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">    <span class="keyword">for</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 将已经删除标记为nil的数据标记为expunged</span></span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, <span class="literal">nil</span>, expunged) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        p = atomic.LoadPointer(&amp;e.p)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p == expunged</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常是先从操作m.read开始的，如果不满足条件再加锁，然后操作m.dirty。Store 方法可能会在某种情况下(初始化或者m.dirty刚被提升后)从m.read中复制数据，如果这个时候m.read中数据量非常大，可能会影响性能。</p>
<h3 id="Delete方法"><a href="#Delete方法" class="headerlink" title="Delete方法"></a>Delete方法</h3><p>Delete方法用来删除一个键值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Delete(key <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    e, ok := read.m[key]</span><br><span class="line">    <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        read, _ = m.read.Load().(readOnly)</span><br><span class="line">        e, ok = read.m[key]</span><br><span class="line">        <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">            <span class="built_in">delete</span>(m.dirty, key)</span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        e.<span class="built_in">delete</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的删除操作还是从m.read中开始， 如果这个entry不存在于m.read中，并且m.dirty中有新数据，则加锁尝试从m.dirty中删除。</p>
<p>此外需要,双检查的。 从m.dirty中直接删除即可，就当它没存在过，但是如果是从m.read中删除，并不会直接删除，而是打标记：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> <span class="built_in">delete</span>() (hadValue <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">        <span class="comment">// 已标记为删除</span></span><br><span class="line">        <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 原子操作，e.p标记为nil</span></span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Range方法"><a href="#Range方法" class="headerlink" title="Range方法"></a>Range方法</h3><p>因为for … range map是内建的语言特性，所以没有办法使用for range遍历sync.Map, 但是可以使用它的Range方法，通过回调的方式遍历</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Range(f <span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span>) &#123;</span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    <span class="comment">// 如果m.dirty中有新数据，则提升m.dirty,然后在遍历</span></span><br><span class="line">    <span class="keyword">if</span> read.amended &#123;</span><br><span class="line">        <span class="comment">//提升m.dirty</span></span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        read, _ = m.read.Load().(readOnly) <span class="comment">//双检查</span></span><br><span class="line">        <span class="keyword">if</span> read.amended &#123;</span><br><span class="line">            read = readOnly&#123;m: m.dirty&#125;</span><br><span class="line">            m.read.Store(read)</span><br><span class="line">            m.dirty = <span class="literal">nil</span></span><br><span class="line">            m.misses = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历, for range是安全的</span></span><br><span class="line">    <span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">        v, ok := e.load()</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> !f(k, v) &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Range方法调用前可能会做一个m.dirty的提升，不过提升m.dirty不是一个耗时的操作。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://fabian4.site/blog">Fabian Bao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://fabian4.site/blog/20817.html">https://fabian4.site/blog/20817.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://fabian4.site/blog" target="_blank">Fabian Bao</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/blog/tags/go/">go</a><a class="post-meta__tags" href="/blog/tags/%E8%AF%AD%E6%B3%95/">语法</a></div><div class="post_share"><div class="social-share" data-image="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/u9vgyrxMZbcAEG2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/h3WuUjvQlqPEAzS.png" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/h3WuUjvQlqPEAzS.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/9yaek4PwfNoZEHF.jpg" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/9yaek4PwfNoZEHF.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blog/22341.html"><img class="prev-cover" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/u9vgyrxMZbcAEG2.png" onerror="onerror=null;src='/blog/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Go 环境变量、编程标准、程序测试和基础包</div></div></a></div><div class="next-post pull-right"><a href="/blog/48362.html"><img class="next-cover" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/u9vgyrxMZbcAEG2.png" onerror="onerror=null;src='/blog/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">GO函数、方法、接口和反射</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/blog/25998.html" title="GO 垃圾回收、异步调度和逃逸分析"><img class="cover" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/u9vgyrxMZbcAEG2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-16</div><div class="title">GO 垃圾回收、异步调度和逃逸分析</div></div></a></div><div><a href="/blog/48362.html" title="GO函数、方法、接口和反射"><img class="cover" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/u9vgyrxMZbcAEG2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-12</div><div class="title">GO函数、方法、接口和反射</div></div></a></div><div><a href="/blog/2317.html" title="Go 基本结构和数据类型"><img class="cover" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/u9vgyrxMZbcAEG2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-10</div><div class="title">Go 基本结构和数据类型</div></div></a></div><div><a href="/blog/22341.html" title="Go 环境变量、编程标准、程序测试和基础包"><img class="cover" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/u9vgyrxMZbcAEG2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-14</div><div class="title">Go 环境变量、编程标准、程序测试和基础包</div></div></a></div><div><a href="/blog/43536.html" title="Python笔记-基础语法"><img class="cover" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/HCB61igYcvPjJbV.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-18</div><div class="title">Python笔记-基础语法</div></div></a></div><div><a href="/blog/38749.html" title="Python笔记-高级语法"><img class="cover" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/9wpbI6VylYWotaA.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-22</div><div class="title">Python笔记-高级语法</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://fabian4.site/avatar.png" onerror="this.onerror=null;this.src='/blog/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Fabian Bao</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">73</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">The best is yet to come</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Go-%E7%9A%84%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">Go 的并发处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Goroutine"><span class="toc-number">1.1.</span> <span class="toc-text">一、Goroutine</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Go%E7%9A%84%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">Go的调度器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8%E7%8A%B6%E6%80%81%E7%9A%84%E6%9F%A5%E7%9C%8B%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.2.</span> <span class="toc-text">调度器状态的查看方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Goroutine%E7%9A%84%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.3.</span> <span class="toc-text">Goroutine的闭包函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Goroutine%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.4.</span> <span class="toc-text">Goroutine的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87sync%E5%AE%9E%E7%8E%B0goroutine%E4%B9%8B%E9%97%B4%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-number">1.1.5.</span> <span class="toc-text">通过sync实现goroutine之间的同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87channel%E5%AE%9E%E7%8E%B0goroutine%E4%B9%8B%E9%97%B4%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-number">1.1.6.</span> <span class="toc-text">通过channel实现goroutine之间的同步</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Channel"><span class="toc-number">1.2.</span> <span class="toc-text">二、Channel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Channel-%E7%AE%A1%E9%81%93"><span class="toc-number">1.2.1.</span> <span class="toc-text">Channel 管道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-Channel"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">创建 Channel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E7%BC%93%E5%86%B2%E7%9A%84Channels"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">无缓冲的Channels</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E7%9A%84Channels"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">缓冲的Channels</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Channel%E7%9A%84%E5%85%B8%E5%9E%8B%E7%94%A8%E6%B3%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">Channel的典型用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#goroutine-%E4%BD%BF%E7%94%A8channel%E9%80%9A%E4%BF%A1"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">goroutine 使用channel通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#select"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">select</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#range-channel"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">range channel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">超时控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#channel%E5%90%8C%E6%AD%A5"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">channel同步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%87%E5%87%BA%E5%92%8C%E6%89%87%E5%85%A5"><span class="toc-number">1.2.2.6.</span> <span class="toc-text">扇出和扇入</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Sync-WaitGroup%E8%A7%A3%E6%9E%90"><span class="toc-number">1.3.</span> <span class="toc-text">三、Sync.WaitGroup解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Sync-Map%E8%A7%A3%E6%9E%90"><span class="toc-number">1.4.</span> <span class="toc-text">四、Sync.Map解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Load%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.2.</span> <span class="toc-text">Load方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Store%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.3.</span> <span class="toc-text">Store方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Delete%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.4.</span> <span class="toc-text">Delete方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Range%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.5.</span> <span class="toc-text">Range方法</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/blog/55079.html" title="Mysql 执行流程和日志系统"><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/Hatshepsut_ZH-CN4516192627_1920x1080.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="Mysql 执行流程和日志系统"/></a><div class="content"><a class="title" href="/blog/55079.html" title="Mysql 执行流程和日志系统">Mysql 执行流程和日志系统</a><time datetime="2021-05-14T16:00:00.000Z" title="发表于 2021-05-15 00:00:00">2021-05-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/47132.html" title="Mysql 锁机制"><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/Italica_ZH-CN1692906751_1920x1080.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="Mysql 锁机制"/></a><div class="content"><a class="title" href="/blog/47132.html" title="Mysql 锁机制">Mysql 锁机制</a><time datetime="2021-04-24T16:00:00.000Z" title="发表于 2021-04-25 00:00:00">2021-04-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/10729.html" title="Mysql 隔离级别与MVCC"><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/CuscoCathedral_ZH-CN9834821723_1920x1080.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="Mysql 隔离级别与MVCC"/></a><div class="content"><a class="title" href="/blog/10729.html" title="Mysql 隔离级别与MVCC">Mysql 隔离级别与MVCC</a><time datetime="2021-04-19T16:00:00.000Z" title="发表于 2021-04-20 00:00:00">2021-04-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/58885.html" title="数据库四大性质和隔离等级"><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/ContainerShip_ZH-CN0850122021_1920x1080.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="数据库四大性质和隔离等级"/></a><div class="content"><a class="title" href="/blog/58885.html" title="数据库四大性质和隔离等级">数据库四大性质和隔离等级</a><time datetime="2021-04-07T16:00:00.000Z" title="发表于 2021-04-08 00:00:00">2021-04-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/5986.html" title="HashMap、HashTable和ConcurrentHashMap"><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/HallstattAustria_PT-BR9407016733_1920x1080.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="HashMap、HashTable和ConcurrentHashMap"/></a><div class="content"><a class="title" href="/blog/5986.html" title="HashMap、HashTable和ConcurrentHashMap">HashMap、HashTable和ConcurrentHashMap</a><time datetime="2021-04-02T16:00:00.000Z" title="发表于 2021-04-03 00:00:00">2021-04-03</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://fabian.oss-cn-hangzhou.aliyuncs.com/img/u9vgyrxMZbcAEG2.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Fabian Bao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/blog/js/utils.js"></script><script src="/blog/js/main.js"></script><script src="/blog/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '98fe0206dedd0d2caf96',
      clientSecret: '5f2816f58a108f15feba46f9bc88497d3d6457a4',
      repo: 'blog',
      owner: 'fabian4',
      admin: ['fabian4'],
      id: '224a1c338ecee8a3f78f86079279f504',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>