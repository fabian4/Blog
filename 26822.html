<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>SpringBoot 干货总结 | Hourglass</title><meta name="keywords" content="Java,SpringBoot"><meta name="author" content="Fabian Bao"><meta name="copyright" content="Fabian Bao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="SpringBoot 干货总结">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringBoot 干货总结">
<meta property="og:url" content="https://fabian4.site/blog/26822.html">
<meta property="og:site_name" content="Hourglass">
<meta property="og:description" content="SpringBoot 干货总结">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/NVO8hr3XDt7c56A.jpg">
<meta property="article:published_time" content="2020-08-26T16:00:00.000Z">
<meta property="article:modified_time" content="2022-08-24T07:47:19.057Z">
<meta property="article:author" content="Fabian Bao">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="SpringBoot">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/NVO8hr3XDt7c56A.jpg"><link rel="shortcut icon" href="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/202015ouknbvshlsrvbku5.jpeg.icon.png"><link rel="canonical" href="https://fabian4.site/blog/26822"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/blog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-E90K5222F4"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-E90K5222F4');
</script><script>const GLOBAL_CONFIG = { 
  root: '/blog/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'SpringBoot 干货总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-08-24 15:47:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/blog/atom.xml" title="Hourglass" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://fabian4.site/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">73</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/blog/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/blog/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/blog/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/blog/gallery/"><i class="fa-fw fas fa-video"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/blog/read/"><i class="fa-fw fa fa-book"></i><span> 阅读</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://fabian.oss-cn-hangzhou.aliyuncs.com/img/NVO8hr3XDt7c56A.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/blog/">Hourglass</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/blog/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/blog/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/blog/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/blog/gallery/"><i class="fa-fw fas fa-video"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/blog/read/"><i class="fa-fw fa fa-book"></i><span> 阅读</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">SpringBoot 干货总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-08-26T16:00:00.000Z" title="发表于 2020-08-27 00:00:00">2020-08-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-08-24T07:47:19.057Z" title="更新于 2022-08-24 15:47:19">2022-08-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/blog/categories/Spring/">Spring</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>36分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="SpringBoot 干货总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/blog/26822.html#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="SpringBoot-干货总结"><a href="#SpringBoot-干货总结" class="headerlink" title="SpringBoot 干货总结"></a>SpringBoot 干货总结</h1><h2 id="一、IOC容器"><a href="#一、IOC容器" class="headerlink" title="一、IOC容器"></a>一、IOC容器</h2><p>对于 IOC 容器来说，只需要你告诉它需要某个 bean，它就把对应的实例（instance）扔给你，至于这个 bean 是否依赖其他组件，怎样完成它的初始化，根本就不需要你的关心。</p>
<p>而 IOC 容器想要管理各个业务对象以及它们之间的依赖关心，需要通过某种途径来记录和管理这些信息。<strong>BeanDefinition对象就承担了这个责任</strong></p>
<h3 id="BeanDefinition-对象"><a href="#BeanDefinition-对象" class="headerlink" title="BeanDefinition 对象"></a>BeanDefinition 对象</h3><p>容器中的每一个 bean 都会有一个对应的 BeanDefinition 实例，该实例负责保存 bean 对象的所有必要信息，包括 bean 对象的 class 类型、是否是抽象类、构造方法和参数、其他属性等等。</p>
<p>当客户端想容器请求相应对象时，容器就会通过这些信息为客户端返回一个完整可用的 bean 实例</p>
<p>当 BeanDefinition 已经准备好，BeanDefinitionRegistry 抽象出 bean 的注册逻辑，而 BeanFactory 则抽象出了 bean 的管理逻辑，而各个 BeanFactory 的实现类就具体承担了 bean 的注册以及管理工作。</p>
<p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/MgXTdFH9akbh4fn.png" alt="image-20200827110609911"></p>
<p>DefaultListableBeanFactory 作为一个比较通用的 BeanFactory 实现，它同时也实现了 BeanDefinitionRegistry 接口，因此它就承担了 Bean 的注册管理工作。从图中也可以看出， BeanFactory 接口中主要包含 getBean、getType、getAlisses等管理 bean 的方法，而 BeanDefinitionRegistry 接口则包含 registerBeanDefinition、removeBeanDefinition、getBeanDefinition等注册管理BeanDefinition的方法</p>
<p><strong>模拟BeanFactory底层工作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认容器实现</span></span><br><span class="line"><span class="type">DefaultListableBeanFactory</span> <span class="variable">beanRegistry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line"> <span class="comment">// 根据业务对象构造相应的BeanDefinition</span></span><br><span class="line"><span class="type">AbstractBeanDefinition</span> <span class="variable">definition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RootBeanDefinition</span>(Business.class,<span class="literal">true</span>);</span><br><span class="line"> <span class="comment">// 将bean定义注册到容器中</span></span><br><span class="line">beanRegistry.registerBeanDefinition(<span class="string">&quot;beanName&quot;</span>,definition);</span><br><span class="line"> <span class="comment">// 如果有多个bean，还可以指定各个bean之间的依赖关系</span></span><br><span class="line"> <span class="comment">// ........</span></span><br><span class="line"> <span class="comment">// 然后可以从容器中获取这个bean的实例</span></span><br><span class="line"> <span class="comment">// 注意：这里的beanRegistry其实实现了BeanFactory接口，所以可以强转，</span></span><br><span class="line"> <span class="comment">// 单纯的BeanDefinitionRegistry是无法强制转换到BeanFactory类型的</span></span><br><span class="line"><span class="type">BeanFactory</span> <span class="variable">container</span> <span class="operator">=</span> (BeanFactory)beanRegistry;</span><br><span class="line"><span class="type">Business</span> <span class="variable">business</span> <span class="operator">=</span> (Business)container.getBean(<span class="string">&quot;beanName&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这一段代码仅仅为了说明 BeanFanctory 底层的大致工作流程，实际情况会更加复杂，比如 bean 之间的依赖关系可能定义在外部配置（XML&#x2F;Properties）中，也可能是注解方式。</p>
<h3 id="IOC容器工作流程"><a href="#IOC容器工作流程" class="headerlink" title="IOC容器工作流程"></a>IOC容器工作流程</h3><p><strong>Spring IOC容器的整个工作流程大致可以分为两个阶段</strong></p>
<ol>
<li><p>容器启动阶段</p>
<p>容器启动时，会通过某种途径加载 Configuration MataData。除了代码方式比较直接外，在大部分情况下，容器需要依赖某些工具类，比如：BeanDefinitionReader，BeanDefinitionReader会对加载的Configuration MetaData进行解析和分析，并将分析后的信息组成为相应的BeanDefinition，最后把这些保存了bean定义BeanDefinition，注册到相应的BeanDefinitionRegistry，这样容器的启动工作就完成了。</p>
<p>这个阶段主要完成一些准备性工作，更侧重于bean对象管理的收集，当然一些验证性或者辅助性的工作也在这一阶段完成。</p>
<p><strong>BeanFactory如何从配置文件中加载bean的定义以及吗依赖关系：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通常为BeanDefinitionRegistry的实现类，这里以DeFaultListabeBeanFactory为例</span></span><br><span class="line"><span class="type">BeanDefinitionRegistry</span> <span class="variable">beanRegistry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader实现了BeanDefinitionReader接口，用于解析XML文件</span></span><br><span class="line"><span class="type">XmlBeanDefinitionReader</span> <span class="variable">beanDefinitionReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReaderImpl</span>(beanRegistry);</span><br><span class="line"><span class="comment">// 加载配置文件 </span></span><br><span class="line">beanDefinitionReader.loadBeanDefinitions(<span class="string">&quot;classpath:spring-bean.xml&quot;</span>);</span><br><span class="line"><span class="comment">// 从容器中获取bean实例</span></span><br><span class="line"><span class="type">BeanFactory</span> <span class="variable">container</span> <span class="operator">=</span> (BeanFactory)beanRegistry;</span><br><span class="line"><span class="type">Business</span> <span class="variable">business</span> <span class="operator">=</span> (Business)container.getBean(<span class="string">&quot;beanName&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Bean的实例化阶段</p>
<p> 经过第一阶段，所有bean定义都通过BeanDefinition的方式注册到BeanDefinitionRegistry中当某个请求通过容器的getBean方法请求某个对象，或者因为依赖关系容器需要隐式的调用getBean时，就会触发第二阶段的活动：容器会首先检查所请求的对象之前是否已经实例化完成。</p>
<p> 如果没有，则会根据注册的BeanDafinition所提供的信息实例化被请求对象，并为其注入依赖。</p>
<p> 当该对象装配完毕后，容器会立即将其返回给请求方法使用。BeanFactory知识Spring IOC容器的一种实现，如果没有特殊指定，它采用延迟初始化策略：只有当访问容器中的某个对象时，才对该对象进行初始化和依赖注入操作。</p>
<p> 而在实际场景下，我们更多的使用另外一种类型的容器：ApplicationContext，它构建在BeanFactory之上，属于更高级的容器，除了具有BeanFactory的所有能力之外，还提供对事件监听机制以及国际化的支持等。它管理的bean，在容器启动时全部完成初始化和依赖注入操作。</p>
</li>
</ol>
<h3 id="Spring容器扩展机制"><a href="#Spring容器扩展机制" class="headerlink" title="Spring容器扩展机制"></a>Spring容器扩展机制</h3><p>IOC容器负责管理容器所有bean的生命周期，而在bean生命周期的不同阶段，Spring提供了不同的扩展点来改变bean的命运。在容器启动阶段，BeanFactoryPoatProcessor允许我们在容器实例化对象之前，对注册到容器的BeanDefinition所保存的信息做一些额外的操作，比如修改bean定义的某些属性或者增加其他信息等等。</p>
<p>如果要自定义扩展类，通常要实现<strong>org.springframework.beans.config.BeanFactoryPostProcessor</strong>接口，与此同时，因为容器中可能有多个 <strong>BeanFactoryPostProcessor</strong>，可能还需要实现 <strong>org.springframework.core.Ordered</strong>接口，以保证 <strong>BeanFactoryPostProcessor</strong> 按照顺序执行。</p>
<p>Spring 提供了为数不多的 <strong>BeanFactoryPostProcessor</strong> 实现，我们这里以<strong>PropertyPlaceholderConfigurer</strong>来说明其大致工作流程：</p>
<p>在Spring项目的XML配置文件中，经常可以看到许多配置项的值使用占位符，而将占位符所代表的值单独配置搭配独立的 <strong>properties</strong> 文件，这样可以将散落在不同XML文件中的配置集中管理，而且也方便运维根据不同的环境进行配置不用的值。</p>
<p>这个非常实用的功能就是由 <strong>PropertyPlaceholderConfigurer</strong> 负责实现的。</p>
<blockquote>
<p>根据前文，当BeanFactory在第一阶段加载完所有配置信息时，BeanFactory中保存的对象的属性还是以占位符方式存在，比如 <strong>${jdbc.mysql.url}</strong></p>
</blockquote>
<p>当 PropertyPlaceholderConfigurer作为BeanFactoryPostProcessor被应用时，它会使用properties配置文件中的值来替换相应的BeanDefinition中占位符所表示的属性值。当需要实例化bean时，bean定义中的属性值就已经被替换成我们配置的值。当然其实现比上面描述的要复杂一些，这里仅说明其大致工作原理，更详细的实现可以参考其源码。</p>
<p>与之相似的，还有 BeanPostProcessor，其存在于对象实例化阶段。根BeanFactoryPostProcessor类似，会处理容器内所有符合条件并且已经实例化后的对象。</p>
<p>简单的对比：</p>
<ul>
<li>BeanFactoryPostProcessor处理bean的定义</li>
<li>BeanPostProcrssor处理bean完成实例化后的对象</li>
</ul>
<p><strong>BeanPostProcessor定义了两个接口</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通常为BeanDefinitionRegistry的实现类，这里以DeFaultListabeBeanFactory为例</span></span><br><span class="line"><span class="type">BeanDefinitionRegistry</span> <span class="variable">beanRegistry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultListableBeanFactory</span>();</span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader实现了BeanDefinitionReader接口，用于解析XML文件</span></span><br><span class="line"><span class="type">XmlBeanDefinitionReader</span> <span class="variable">beanDefinitionReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XmlBeanDefinitionReaderImpl</span>(beanRegistry);</span><br><span class="line"><span class="comment">// 加载配置文件 </span></span><br><span class="line">beanDefinitionReader.loadBeanDefinitions(<span class="string">&quot;classpath:spring-bean.xml&quot;</span>);</span><br><span class="line"><span class="comment">// 从容器中获取bean实例</span></span><br><span class="line"><span class="type">BeanFactory</span> <span class="variable">container</span> <span class="operator">=</span> (BeanFactory)beanRegistry;</span><br><span class="line"><span class="type">Business</span> <span class="variable">business</span> <span class="operator">=</span> (Business)container.getBean(<span class="string">&quot;beanName&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>为了理解这两个方法执行的时机，简单的了解下bean的整个生命周期</strong></p>
<p><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/HP4er5hOTb1sC3M.png" alt="image-20200827221535647"></p>
<p>postProcessBeforeInitialization()方法与postProcessAfterInitialization()分别对应图中前置处理和后置处理两个步骤将执行的方法。这两个方法都传入了bean对象实例的引用，为扩展容器的对象实例化过程提供了很大便利，在这儿几乎可以对传入的实例执行任何操作。</p>
<blockquote>
<p>注解、AOP等功能的实现均大量使用了BeanPostProcessor，比如有一个自定义注解，你完全可以实现BeanPostProcessor的接口，在其中判断bean对象的脑袋上是否有该注解，如果有，你可以对这个bean实例执行任何操作。</p>
<p>在Spring中经常能够看到各种各样的Aware接口，其作用就是在对象实例化完成以后将Aware接口定义中规定的依赖注入到当前实例中。</p>
<p>比如最常见的ApplicationContextAware接口，实现了这个接口的类都可以获取到一个ApplicationContext对象。当容器中每一个对象的实例化过程走到BeanPostProcessor前置处理这一步时，容器会检测到之前注册到容器的ApplicationContextAwareProcessor，然后就会调用其postProcessBeforeInitialization()方法，检查并设置Aware相关依赖</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.springframework.context.support.ApplicationContextAwareProcessor</span></span><br><span class="line"><span class="comment">// 其postProcessBeforeInitialization方法调用了invokeAwareInterfaces方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">invokeAwareInterfaces</span><span class="params">(Object bean)</span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware)&#123;</span><br><span class="line">         ((EnvironmentAware) bean).setEnvironment(<span class="built_in">this</span>.applicationContext.getEnvironment());</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware)&#123;</span><br><span class="line">         ((ApplicationContextAware) bean).setApplicationContext(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、JavaConfig与常见Annotation"><a href="#二、JavaConfig与常见Annotation" class="headerlink" title="二、JavaConfig与常见Annotation"></a>二、JavaConfig与常见Annotation</h2><h3 id="JavaConfig"><a href="#JavaConfig" class="headerlink" title="JavaConfig"></a>JavaConfig</h3><p>我们知道bean是Spring IOC中非常核心的概念，Spring容器负责bean的生命周期的管理。</p>
<p>在最初，Spring使用XML配置文件的方式来描述bean的定义以及相互间的依赖关系，但随着Spring的发展，越来越多的人对这种方式表示不满，因为Spring项目的所有业务类均以bean的形式配置在XML文件中，造成了大量的XML文件，使项目变得复杂且难以管理。</p>
<p>后来，基于纯Java Annotation依赖注入框架Guice出世，其性能明显优于采用XML方式的Spring，甚至有部分人认为，Guice可以完全取代Spring（Guice仅是一个轻量级IOC框架，取代Spring还差的挺远）</p>
<p>正是这样的危机感，促使Spring及社区推出并持续完善了JavaConfig子项目，它基于Java代码和Annotation注解来描述bean之间的依赖绑定关系。</p>
<p><strong>XML 配置方法描述bean定义</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;me.fabian.service.BookServiceImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>基于JavaConfig的配置形式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span></span><br><span class="line"><span class="title class_">MoonBookConfiguration</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 任何标志了@Bean的方法，其返回值将作为一个bean注册到Spring的IOC容器中</span></span><br><span class="line">    <span class="comment">// 方法名默认成为该bean定义的id</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> BookService <span class="title function_">bookService</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BookServiceImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果两个bean之间有依赖关系，<strong>XML中配置方法</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;me.fabianme.fabian.service.BookServiceImpl&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dependencyService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dependencyService&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;otherService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;me.fabian.service.OtherServiceImpl&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dependencyService&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dependencyService&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dependencyService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;DependencyServiceImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>JavaConfig中</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MoonBookConfiguration</span> &#123;</span><br><span class="line">    <span class="comment">// 如果一个bean依赖另一个bean，则直接调用对应JavaConfig类中依赖bean的创建方法即可</span></span><br><span class="line">    <span class="comment">// 这里直接调用dependencyService()</span></span><br><span class="line">     <span class="meta">@Bean</span></span><br><span class="line">     <span class="keyword">public</span> BookService <span class="title function_">bookService</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BookServiceImpl</span>(dependencyService());</span><br><span class="line">     &#125;</span><br><span class="line">      <span class="meta">@Bean</span></span><br><span class="line">     <span class="keyword">public</span> OtherService <span class="title function_">otherService</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OtherServiceImpl</span>(dependencyService());</span><br><span class="line">     &#125;</span><br><span class="line">      <span class="meta">@Bean</span></span><br><span class="line">     <span class="keyword">public</span> DependencyService <span class="title function_">dependencyService</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DependencyServiceImpl</span>();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>@ComponentScan注解对应XML配置形式中的元素表示启用组件扫描，Spring会自动扫描所有通过注解配置的bean，然后将其注册到IOC容器中。</p>
<p>我们可以通过basePackages等属性来指定@ComponentScan自动扫描的范围，如果不指定，默认从声明@ComponentScan所在类的package进行扫描。正因为如此，SpringBoot的启动类都默认在src&#x2F;main&#x2F;java下。</p>
<h3 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h3><p><strong>@Import注解用于导入配置类，举个简单的例子：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MoonBookConfiguration</span>&#123;</span><br><span class="line">     <span class="meta">@Bean</span></span><br><span class="line">     <span class="keyword">public</span> BookService <span class="title function_">bookService</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BookServiceImpl</span>();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>现在有另外一个配置类，比如：MoonUserConfiguration，这个配置类中有一个bean依赖于MoonBookConfiguration中的bookService，如何将这两个bean组合在一起？</p>
<p><strong>借助@Import即可：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"> <span class="comment">// 可以同时导入多个配置类，比如：@Import(&#123;A.class,B.class&#125;)</span></span><br><span class="line"> <span class="meta">@Import(MoonBookConfiguration.class)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MoonUserConfiguration</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="meta">@Bean</span></span><br><span class="line">     <span class="keyword">public</span> UserService <span class="title function_">userService</span><span class="params">(BookService bookService)</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BookServiceImpl</span>(bookService);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在4.2之前，@Import注解只支持导入配置类，但是在4.2之后，它支持导入普通类，并将这个类作为一个bean的定义注册到IOC容器中。</p>
<h3 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h3><p>@Conditional注解表示在满足某种条件后才初始化一个bean或者启用某些配置。</p>
<p>它一般用在由@Component、@Service、@Configuration等注解标识的类上面，或者由@Bean标记的方法上。如果一个@Configuration类标记了@Conditional，则该类中所有标识了@Bean的方法和@Import注解导入的相关类将遵从这些条件。</p>
<p>在Spring里可以很方便的编写你自己的条件类，所要做的就是实现Condition接口，并覆盖它的matches()方法。</p>
<p><strong>举个例子，下面的简单条件类表示只有在Classpath里存在JdbcTemplate类时才生效:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcTemplateCondition</span> <span class="keyword">implements</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(ConditionContext</span></span><br><span class="line"><span class="params"> conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata)</span> &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">         conditionContext.getClassLoader().loadClass(<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>);</span><br><span class="line">             <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line"> <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>当你用Java来声明bean的时候，可以使用这个自定义条件类：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Conditional(JdbcTemplateCondition.class)</span> </span><br><span class="line"><span class="meta">@Service</span> </span><br><span class="line"><span class="keyword">public</span> MyService <span class="title function_">service</span><span class="params">()</span> &#123; ...... &#125;</span><br></pre></td></tr></table></figure>

<p>这个例子中只有当JdbcTemplateCondition类的条件成立时才会创建MyService这个bean。</p>
<p>也就是说MyService这bean的创建条件是classpath里面包含JdbcTemplate，否则这个bean的声明就会被忽略掉。</p>
<p>Spring Boot定义了很多有趣的条件，并把他们运用到了配置类上，这些配置类构成了Spring Boot的自动配置的基础。</p>
<p>Spring Boot运用条件化配置的方法是：定义多个特殊的条件化注解，并将它们用到配置类上。</p>
<p><strong>下面列出了Spring Boot提供的部分条件化注解：</strong></p>
<table>
<thead>
<tr>
<th>条件化注解</th>
<th>配置生效条件</th>
</tr>
</thead>
<tbody><tr>
<td>@ConditionalOnBean</td>
<td>配置了某个特定的bean</td>
</tr>
<tr>
<td>@ConditionalOnMissingBean</td>
<td>没有配置特定的bean</td>
</tr>
<tr>
<td>@ConditionalOnClass</td>
<td>Classpath里有指定的类</td>
</tr>
<tr>
<td>@ConditionalOnMissingClass</td>
<td>Classpath里没有指定的类</td>
</tr>
<tr>
<td>@ConditionalOnExpression</td>
<td>给定的Spring Expression Language表达式计算结果为true</td>
</tr>
<tr>
<td>@ConditionalOnJava</td>
<td>Java的版本匹配特定值或者一个范围值</td>
</tr>
<tr>
<td>@ConditionalOnProperty</td>
<td>指定的配置属性要有一个明确的值</td>
</tr>
<tr>
<td>@ConditionalOnResource</td>
<td>Classpath有指定的资源</td>
</tr>
<tr>
<td>@ConditionalOnWebApplication</td>
<td>这是一个Web应用程序</td>
</tr>
<tr>
<td>@ConditionalOnNotWebApplication</td>
<td>这不是一个Web应用程序</td>
</tr>
</tbody></table>
<h3 id="ConfigurationProperties与-EnableConfigurationProperties"><a href="#ConfigurationProperties与-EnableConfigurationProperties" class="headerlink" title="@ConfigurationProperties与@EnableConfigurationProperties"></a>@ConfigurationProperties与@EnableConfigurationProperties</h3><p>当某些属性的值需要配置的时候，我们一般会在application.properties文件中新建配置项，然后在bean中使用@Value注解来获取配置的值，比如下面配置数据源的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jdbc config</span></span><br><span class="line"> jdbc.mysql.url=jdbc:mysql:<span class="comment">//localhost:3306/sampledb</span></span><br><span class="line"> jdbc.mysql.username=root</span><br><span class="line"> jdbc.mysql.password=<span class="number">123456</span></span><br><span class="line"> ......</span><br><span class="line"><span class="comment">// 配置数据源</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HikariDataSourceConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Value(&quot;jdbc.mysql.url&quot;)</span></span><br><span class="line">     <span class="keyword">public</span> String url;</span><br><span class="line">     <span class="meta">@Value(&quot;jdbc.mysql.username&quot;)</span></span><br><span class="line">     <span class="keyword">public</span> String user;</span><br><span class="line">     <span class="meta">@Value(&quot;jdbc.mysql.password&quot;)</span></span><br><span class="line">     <span class="keyword">public</span> String password;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Bean</span></span><br><span class="line">     <span class="keyword">public</span> HikariDataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="type">HikariConfig</span> <span class="variable">hikariConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariConfig</span>();</span><br><span class="line">         hikariConfig.setJdbcUrl(url);</span><br><span class="line">         hikariConfig.setUsername(user);</span><br><span class="line">         hikariConfig.setPassword(password);</span><br><span class="line">         <span class="comment">// 省略部分代码</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>(hikariConfig);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用@Value注解注入的属性通常都比较简单，如果同一个配置在多个地方使用，也存在不方便维护的问题</p>
<p>对于更为复杂的配置，Spring Boot提供了更优雅的实现方式,那就是@ConfigurationProperties注解。</p>
<p><strong>我们可以通过下面的方式来改写上面的代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="comment">// 还可以通过@PropertySource(&quot;classpath:jdbc.properties&quot;)来指定配置文件</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;jdbc.mysql&quot;)</span></span><br><span class="line"><span class="comment">// 前缀=jdbc.mysql，会在配置文件中寻找jdbc.mysql.*的配置项</span></span><br><span class="line">pulic <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> String url;</span><br><span class="line">     <span class="keyword">public</span> String username;</span><br><span class="line">     <span class="keyword">public</span> String password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HikariDataSourceConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@AutoWired</span></span><br><span class="line">     <span class="keyword">public</span> JdbcConfig config;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Bean</span></span><br><span class="line">     <span class="keyword">public</span> HikariDataSource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="type">HikariConfig</span> <span class="variable">hikariConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariConfig</span>();</span><br><span class="line">         hikariConfig.setJdbcUrl(config.url);</span><br><span class="line">         hikariConfig.setUsername(config.username);</span><br><span class="line">         hikariConfig.setPassword(config.password);</span><br><span class="line">         <span class="comment">// 省略部分代码</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>(hikariConfig);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@ConfigurationProperties对于更为复杂的配置，处理起来也是得心应手，比如有如下配置文件：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#App</span></span><br><span class="line"><span class="attr">app.menus[0].title</span>=<span class="string">Home</span></span><br><span class="line"><span class="attr">app.menus[0].name</span>=<span class="string">Home</span></span><br><span class="line"><span class="attr">app.menus[0].path</span>=<span class="string">/</span></span><br><span class="line"><span class="attr">app.menus[1].title</span>=<span class="string">Login</span></span><br><span class="line"><span class="attr">app.menus[1].name</span>=<span class="string">Login</span></span><br><span class="line"><span class="attr">app.menus[1].path</span>=<span class="string">/login</span></span><br><span class="line"></span><br><span class="line"><span class="attr">app.compiler.timeout</span>=<span class="string">5</span></span><br><span class="line"><span class="attr">app.compiler.output-folder</span>=<span class="string">/temp/</span></span><br><span class="line"></span><br><span class="line"><span class="attr">app.error</span>=<span class="string">/error/</span></span><br></pre></td></tr></table></figure>

<p><strong>可以定义如下配置类来接收这些属性：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;app&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> String error;</span><br><span class="line">     <span class="keyword">public</span> List&lt;Menu&gt; menus = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">     <span class="keyword">public</span> <span class="type">Compiler</span> <span class="variable">compiler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Compiler</span>();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Menu</span> &#123;</span><br><span class="line">         <span class="keyword">public</span> String name;</span><br><span class="line">         <span class="keyword">public</span> String path;</span><br><span class="line">         <span class="keyword">public</span> String title;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Compiler</span> &#123;</span><br><span class="line">         <span class="keyword">public</span> String timeout;</span><br><span class="line">         <span class="keyword">public</span> String outputFolder;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>@EnableConfigurationProperties注解表示对@ConfigurationProperties的内嵌支持默认会将对应Properties Class作为bean注入的IOC容器中，即在相应的Properties类上不用加@Component注解。</p>
<h2 id="三、SpringFactoriesLoader详解"><a href="#三、SpringFactoriesLoader详解" class="headerlink" title="三、SpringFactoriesLoader详解"></a>三、SpringFactoriesLoader详解</h2><p><strong>JVM提供了3种类加载器：</strong></p>
<p>BootstrapClassLoader、ExtClassLoader、AppClassLoader分别加载Java核心类库、扩展类库以及应用的类路径(CLASSPATH)下的类库。</p>
<p>JVM通过<strong>双亲委派模型</strong>进行类的加载，我们也可以通过继承java.lang.classloader实现自己的类加载器。</p>
<p>何为双亲委派模型？当一个类加载器收到类加载任务时，会先交给自己的父加载器去完成，因此最终加载任务都会传递到最顶层的BootstrapClassLoader，只有当父加载器无法完成加载任务时，才会尝试自己来加载。</p>
<p>采用双亲委派模型的一个好处是保证使用不同类加载器最终得到的都是同一个对象，这样就可以保证Java 核心库的类型安全，比如，加载位于rt.jar包中的java.lang.Object类，不管是哪个加载器加载这个类，最终都是委托给顶层的BootstrapClassLoader来加载的，这样就可以保证任何的类加载器最终得到的都是同样一个Object对象。</p>
<p><strong>查看ClassLoader的源码，对双亲委派模型会有更直观的认识：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) &#123;</span><br><span class="line">     <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">     <span class="comment">// 首先，检查该类是否已经被加载，如果从JVM缓存中找到该类，则直接返回</span></span><br><span class="line">     Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">     <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// 遵循双亲委派的模型，首先会通过递归从父加载器开始找，</span></span><br><span class="line">             <span class="comment">// 直到父类加载器是BootstrapClassLoader为止</span></span><br><span class="line">             <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                 c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 c = findBootstrapClassOrNull(name);</span><br><span class="line">             &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;&#125;</span><br><span class="line">         <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">             <span class="comment">// 如果还找不到，尝试通过findClass方法去寻找</span></span><br><span class="line">             <span class="comment">// findClass是留给开发者自己实现的，也就是说</span></span><br><span class="line">             <span class="comment">// 自定义类加载器时，重写此方法即可</span></span><br><span class="line">            c = findClass(name);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">        resolveClass(c);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> c;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>但双亲委派模型并不能解决所有的类加载器问题，比如，Java 提供了很多服务提供者接口(Service Provider Interface，SPI)，允许第三方为这些接口提供实现。</p>
<p>常见的 SPI 有 JDBC、JNDI、JAXP 等，这些SPI的接口由核心类库提供，却由第三方实现这样就存在一个问题：SPI 的接口是 Java 核心库的一部分，是由BootstrapClassLoader加载的；SPI实现的Java类一般是由AppClassLoader来加载的。BootstrapClassLoader是无法找到 SPI 的实现类的，因为它只加载Java的核心库。它也不能代理给AppClassLoader，因为它是最顶层的类加载器。也就是说，双亲委派模型并不能解决这个问题。</p>
<p><strong>线程上下文类加载器</strong>(ContextClassLoader)正好解决了这个问题。</p>
<p>从名称上看，可能会误解为它是一种新的类加载器，实际上，它仅仅是Thread类的一个变量而已，可以通过setContextClassLoader(ClassLoader cl)和getContextClassLoader()来设置和获取该对象。</p>
<p>如果不做任何的设置，Java应用的线程的上下文类加载器默认就是AppClassLoader。</p>
<p>在核心类库使用SPI接口时，传递的类加载器使用线程上下文类加载器，就可以成功的加载到SPI实现的类。</p>
<p>线程上下文类加载器在很多SPI的实现中都会用到。但在JDBC中，你可能会看到一种更直接的实现方式，比如，JDBC驱动管理java.sql.Driver中的loadInitialDrivers()方法中</p>
<p><strong>你可以直接看到JDK是如何加载驱动的：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String aDriver : driversList) &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 直接使用AppClassLoader</span></span><br><span class="line">         Class.forName(aDriver, <span class="literal">true</span>, ClassLoader.getSystemClassLoader());</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">         println(<span class="string">&quot;DriverManager.Initialize: load failed: &quot;</span> + ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>其实讲解线程上下文类加载器，最主要是让大家在看到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().getClassLoader()</span><br><span class="line">Thread.currentThread().getContextClassLoader()</span><br></pre></td></tr></table></figure>

<p>这两者除了在许多底层框架中取得的ClassLoader可能会有所不同外，其他大多数业务场景下都是一样的，大家只要知道它是为了解决什么问题而存在的即可。</p>
<p>类加载器除了加载class外，还有一个非常重要功能，就是<strong>加载资源</strong>，它可以从jar包中读取任何资源文件，比如，<code>ClassLoader.getResources(String name)</code>方法就是用于读取jar包中的资源文件，其代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Enumeration&lt;URL&gt; <span class="title function_">getResources</span><span class="params">(String name)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">     Enumeration&lt;URL&gt;[] tmp = (Enumeration&lt;URL&gt;[]) <span class="keyword">new</span> <span class="title class_">Enumeration</span>&lt;?&gt;[<span class="number">2</span>];</span><br><span class="line">     <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">         tmp[<span class="number">0</span>] = parent.getResources(name);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         tmp[<span class="number">0</span>] = getBootstrapResources(name);</span><br><span class="line">     &#125;</span><br><span class="line">     tmp[<span class="number">1</span>] = findResources(name);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CompoundEnumeration</span>&lt;&gt;(tmp);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>它的逻辑其实跟类加载的逻辑是一样的,首先判断父类加载器是否为空，不为空则委托父类加载器执行资源查找任务, 直到BootstrapClassLoader，最后才轮到自己查找。</p>
<p>而不同的类加载器负责扫描不同路径下的jar包，就如同加载class一样，最后会扫描所有的jar包，找到符合条件的资源文件。</p>
<p>类加载器的<code>findResources(name)</code>方法会遍历其负责加载的所有jar包，找到jar包中名称为name的资源文件，这里的资源可以是任何文件，甚至是.class文件，比如下面的示例，用于查找Array.class文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 寻找Array.class文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">     <span class="comment">// Array.class的完整路径</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;java/sql/Array.class&quot;</span>;</span><br><span class="line">     Enumeration&lt;URL&gt; urls = Thread.currentThread().getContextClassLoader().getResources(name);</span><br><span class="line">     <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">         <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> urls.nextElement();</span><br><span class="line">         System.out.println(url.toString());</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>运行后可以得到如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$JAVA_HOME/jre/lib/rt.jar!/java/sql/Array.class</span><br></pre></td></tr></table></figure>

<p>根据资源文件的URL，可以构造相应的文件来读取资源内容</p>
<p>下面我们来看一下 SpringFactoriesLoader 的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FACTORIES_RESOURCE_LOCATION</span> <span class="operator">=</span> <span class="string">&quot;META-INF/spring.factories&quot;</span>;</span><br><span class="line"> <span class="comment">// spring.factories文件的格式为：key=value1,value2,value3</span></span><br><span class="line"> <span class="comment">// 从所有的jar包中找到META-INF/spring.factories文件</span></span><br><span class="line"> <span class="comment">// 然后从文件中解析出key=factoryClass类名称的所有value值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, ClassLoader classLoader)</span> &#123;</span><br><span class="line">     <span class="type">String</span> <span class="variable">factoryClassName</span> <span class="operator">=</span> factoryClass.getName();</span><br><span class="line">     <span class="comment">// 取得资源文件的URL</span></span><br><span class="line">     Enumeration&lt;URL&gt; urls = (classLoader != <span class="literal">null</span> ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">     List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">     <span class="comment">// 遍历所有的URL</span></span><br><span class="line">     <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">         <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> urls.nextElement();</span><br><span class="line">         <span class="comment">// 根据资源文件URL解析properties文件</span></span><br><span class="line">         <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> PropertiesLoaderUtils.loadProperties(<span class="keyword">new</span> <span class="title class_">UrlResource</span>(url));</span><br><span class="line">         <span class="type">String</span> <span class="variable">factoryClassNames</span> <span class="operator">=</span> properties.getProperty(factoryClassName);</span><br><span class="line">         <span class="comment">// 组装数据，并返回</span></span><br><span class="line">         result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>从CLASSPATH下的每个Jar包中搜寻所有META-INF&#x2F;spring.factories配置文件，然后将解析properties文件，找到指定名称的配置后返回。</p>
<p>需要注意的是，其实这里不仅仅是会去ClassPath路径下查找，会扫描所有路径下的Jar包，只不过这个文件只会在Classpath下的jar包中。</p>
<p>来简单看下spring.factories文件的内容吧：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">//</span> <span class="string">来自 org.springframework.boot.autoconfigure下的META-INF/spring.factories</span></span><br><span class="line"><span class="attr">//</span> <span class="string">EnableAutoConfiguration后文会讲到，它用于开启Spring Boot自动配置功能</span></span><br><span class="line"></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration\</span></span><br></pre></td></tr></table></figure>

<p>执行loadFactoryNames(EnableAutoConfiguration.class, classLoader)后，得到对应的一组@Configuration类，我们就可以通过反射实例化这些类然后注入到IOC容器中，最后容器里就有了一系列标注了@Configuration的JavaConfig形式的配置类。</p>
<p>这就是SpringFactoriesLoader，它本质上属于Spring框架私有的一种扩展方案，类似于SPI，Spring Boot在Spring基础上的很多核心功能都是基于此。</p>
<h2 id="四、Spring容器的事件监听机制"><a href="#四、Spring容器的事件监听机制" class="headerlink" title="四、Spring容器的事件监听机制"></a>四、Spring容器的事件监听机制</h2><p>过去，事件监听机制多用于图形界面编程，比如：点击按钮、在文本框输入内容等操作被称为事件，而当事件触发时，应用程序作出一定的响应则表示应用监听了这个事件，而在服务器端，事件的监听机制更多的用于异步通知以及监控和异常处理。</p>
<p>Java提供了实现事件监听机制的两个基础类：自定义事件类型扩展自java.util.EventObject、事件的监听器扩展自java.util.EventListener。</p>
<p>来看一个简单的实例：简单的监控一个方法的耗时。</p>
<p>首先定义事件类型，通常的做法是扩展EventObject，随着事件的发生，相应的状态通常都封装在此类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodMonitorEvent</span> <span class="keyword">extends</span> <span class="title class_">EventObject</span> &#123;</span><br><span class="line">     <span class="comment">// 时间戳，用于记录方法开始执行的时间</span></span><br><span class="line">     <span class="keyword">public</span> <span class="type">long</span> timestamp;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="title function_">MethodMonitorEvent</span><span class="params">(Object source)</span> &#123;</span><br><span class="line">         <span class="built_in">super</span>(source);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>事件发布之后，相应的监听器即可对该类型的事件进行处理，我们可以在方法开始执行之前发布一个begin事件.</p>
<p>在方法执行结束之后发布一个end事件，相应地，事件监听器需要提供方法对这两种情况下接<strong>收到的事件进行处理：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、定义事件监听接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MethodMonitorEventListener</span> <span class="keyword">extends</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line">    <span class="comment">// 处理方法执行之前发布的事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMethodBegin</span><span class="params">(MethodMonitorEvent event)</span>;</span><br><span class="line">    <span class="comment">// 处理方法结束时发布的事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMethodEnd</span><span class="params">(MethodMonitorEvent event)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2、事件监听接口的实现：如何处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractMethodMonitorEventListener</span> <span class="keyword">implements</span> <span class="title class_">MethodMonitorEventListener</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMethodBegin</span><span class="params">(MethodMonitorEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// 记录方法开始执行时的时间</span></span><br><span class="line">        event.timestamp = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMethodEnd</span><span class="params">(MethodMonitorEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// 计算方法耗时</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">duration</span> <span class="operator">=</span> System.currentTimeMillis() - event.timestamp;</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时：&quot;</span> + duration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事件监听器接口针对不同的事件发布实际提供相应的处理方法定义，最重要的是，其方法只接收MethodMonitorEvent参数，说明这个监听器类只负责监听器对应的事件并进行处理。</p>
<p>有了事件和监听器，剩下的就是发布事件，然后让相应的监听器监听并处理。</p>
<p>通常情况，我们会有一个事件发布者，它本身作为事件源，在合适的时机，将相应的事件发布<strong>给对应的事件监听器：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodMonitorEventPublisher</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> List&lt;MethodMonitorEventListener&gt; listeners = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;MethodMonitorEventListener&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodMonitor</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="type">MethodMonitorEvent</span> <span class="variable">eventObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodMonitorEvent</span>(<span class="built_in">this</span>);</span><br><span class="line">         publishEvent(<span class="string">&quot;begin&quot;</span>,eventObject);</span><br><span class="line">         <span class="comment">// 模拟方法执行：休眠5秒钟</span></span><br><span class="line">         TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">         publishEvent(<span class="string">&quot;end&quot;</span>,eventObject);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">publishEvent</span><span class="params">(String status,MethodMonitorEvent event)</span> &#123;</span><br><span class="line">         <span class="comment">// 避免在事件处理期间，监听器被移除，这里为了安全做一个复制操作</span></span><br><span class="line">         List&lt;MethodMonitorEventListener&gt; copyListeners = ➥ <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;MethodMonitorEventListener&gt;(listeners);</span><br><span class="line">         <span class="keyword">for</span> (MethodMonitorEventListener listener : copyListeners) &#123;</span><br><span class="line">             <span class="keyword">if</span> (<span class="string">&quot;begin&quot;</span>.equals(status)) &#123;</span><br><span class="line">                 listener.onMethodBegin(event);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 listener.onMethodEnd(event);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         <span class="type">MethodMonitorEventPublisher</span> <span class="variable">publisher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodMonitorEventPublisher</span>();</span><br><span class="line">         publisher.addEventListener(<span class="keyword">new</span> <span class="title class_">AbstractMethodMonitorEventListener</span>());</span><br><span class="line">         publisher.methodMonitor();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 省略实现</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEventListener</span><span class="params">(MethodMonitorEventListener listener)</span> &#123;&#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeEventListener</span><span class="params">(MethodMonitorEventListener listener)</span> &#123;&#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeAllListeners</span><span class="params">()</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对于事件发布者（事件源）通常需要关注两点：</strong></p>
<ol>
<li><p>在合适的时机发布事件。此例中的methodMonitor()方法是事件发布的源头，其在方法执行之前和结束之后两个时间点发布MethodMonitorEvent事件，每个时间点发布的事件都会传给相应的监听器进行处理</p>
<blockquote>
<p>在具体实现时需要注意的是，事件发布是顺序执行，为了不影响处理性能，事件监听器的处理逻辑应尽量简单。</p>
</blockquote>
</li>
<li><p>事件监听器的管理。publisher类中提供了事件监听器的注册与移除方法，这样客户端可以根据实际情况决定是否需要注册新的监听器或者移除某个监听器。</p>
<blockquote>
<p>如果这里没有提供remove方法，那么注册的监听器示例将一直MethodMonitorEventPublisher引用，即使已经废弃不用了，也依然在发布者的监听器列表中，这会导致隐性的内存泄漏。</p>
</blockquote>
</li>
</ol>
<p><strong>Spring容器内的事件监听机制</strong></p>
<p>Spring的ApplicationContext容器内部中的所有事件类型均继承自org.springframework.context.AppliationEvent，容器中的所有监听器都实现org.springframework.context.ApplicationListener接口，并且以bean的形式注册在容器中。</p>
<p>一旦在容器内发布ApplicationEvent及其子类型的事件，注册到容器的ApplicationListener就会对这些事件进行处理。</p>
<p>ApplicationEvent继承自EventObject，Spring提供了一些默认的实现，比如：</p>
<ul>
<li>ContextClosedEvent表示容器在即将关闭时发布的事件类型</li>
<li>ContextRefreshedEvent表示容器在初始化或者刷新的时候发布的事件类型（容器内部使用）</li>
<li>ApplicationListener作为事件监听器接口定义，它继承自EventListener。</li>
<li>ApplicationContext容器在启动时，会自动识别并加载EventListener类型的bean一旦容器内有事件发布，将通知这些注册到容器的EventListener。</li>
<li>ApplicationContext接口继承了ApplicationEventPublisher接口，该接口提供了void publishEvent(ApplicationEvent event)方法定义，不难看出，ApplicationContext容器担当的就是事件发布者的角色。</li>
<li>ApplicationContext将事件的发布以及监听器的管理工作委托给 ApplicationEventMulticaster接口的实现类。</li>
<li>在容器启动时，会检查容器内是否存在名为applicationEventMulticaster的 ApplicationEventMulticaster对象实例。如果有就使用其提供的实现，没有就默认初始化一个SimpleApplicationEventMulticaster作为实现。</li>
<li>最后，如果我们业务需要在容器内部发布事件，只需要为其注入ApplicationEventPublisher 依赖即可：实现ApplicationEventPublisherAware接口或者ApplicationContextAware接口.</li>
</ul>
<h2 id="五、自动配置原理"><a href="#五、自动配置原理" class="headerlink" title="五、自动配置原理"></a>五、自动配置原理</h2><p>典型的Spring Boot应用的启动类一般均位于src&#x2F;main&#x2F;java根路径下</p>
<p>比如MoonApplication类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MoonApplication</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">         SpringApplication.run(MoonApplication.class, args);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>其中@SpringBootApplication开启组件扫描和自动配置，而SpringApplication.run则负责启动引导应用程序。</p>
<p>@SpringBootApplication是一个复合Annotation，它将三个有用的注解组合在一起：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span> </span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123;</span></span><br><span class="line"><span class="meta">@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span></span><br><span class="line"> <span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">     <span class="comment">// ......</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>@SpringBootConfiguration就是@Configuration，它是Spring框架的注解，标明该类是一个JavaConfig配置类。</p>
<p>而@ComponentScan启用组件扫描，前文已经详细讲解过，这里着重关注@EnableAutoConfiguration。@EnableAutoConfiguration注解表示开启Spring Boot自动配置功能，Spring Boot会根据应用的依赖、自定义的bean、classpath下有没有某个类 等等因素来猜测你需要的bean，</p>
<p>然后注册到IOC容器中。</p>
<p>那@EnableAutoConfiguration是如何推算出你的需求？</p>
<p>首先看下它的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(EnableAutoConfigurationImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">     <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你的关注点应该在@Import(EnableAutoConfigurationImportSelector.class)上了，前文说过，@Import注解用于导入类，并将这个类作为一个bean的定义注册到容器中，这里将把EnableAutoConfigurationImportSelector作为bean注入到容器中，而这个类会将<strong>所有符合条件的@Configuration配置都加载到容器中</strong>，看看它的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">     <span class="comment">// 省略了大部分代码，保留一句核心代码</span></span><br><span class="line">     <span class="comment">// 注意：SpringBoot最近版本中，这句代码被封装在一个单独的方法中</span></span><br><span class="line">     <span class="comment">// SpringFactoriesLoader相关知识请参考前文</span></span><br><span class="line">     List&lt;String&gt; factories = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;String&gt;(</span><br><span class="line">           SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class, <span class="built_in">this</span>.beanClassLoader)));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这个类会扫描所有的jar包，将所有符合条件的@Configuration配置类注入的容器中<strong>何为符合条件，看看META-INF&#x2F;spring.factories的文件内容：</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">//</span> <span class="string">来自 org.springframework.boot.autoconfigure下的META-INF/spring.factories</span></span><br><span class="line"><span class="attr">//</span> <span class="string">配置的key = EnableAutoConfiguration，与代码中一致</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration\</span></span><br><span class="line"><span class="string">.....</span></span><br></pre></td></tr></table></figure>

<p>以DataSourceAutoConfiguration为例，看看Spring Boot是如何自动配置的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(&#123; DataSource.class, EmbeddedDatabaseType.class &#125;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(DataSourceProperties.class)</span></span><br><span class="line"><span class="meta">@Import(&#123; Registrar.class, DataSourcePoolMetadataProvidersConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceAutoConfiguration</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分别说一说：</strong></p>
<p>@ConditionalOnClass({ DataSource.class, EmbeddedDatabaseType.class })：当Classpath中存在DataSource或者EmbeddedDatabaseType类时才启用这个配置，否则这个配置将被忽略。</p>
<p>@EnableConfigurationProperties(DataSourceProperties.class)：将DataSource的默认配置类注入到IOC容器中，DataSourceproperties定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提供对datasource配置信息的支持，所有的配置前缀为：spring.datasource</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> ClassLoader classLoader;</span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;testdb&quot;</span>;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Import({ Registrar.class, DataSourcePoolMetadataProvidersConfiguration.class })：导入其他额外的配置，就以DataSourcePoolMetadataProvidersConfiguration为例吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourcePoolMetadataProvidersConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="meta">@ConditionalOnClass(org.apache.tomcat.jdbc.pool.DataSource.class)</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TomcatDataSourcePoolMetadataProviderConfiguration</span> &#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="keyword">public</span> DataSourcePoolMetadataProvider <span class="title function_">tomcatPoolDataSourceMetadataProvider</span><span class="params">()</span> &#123;</span><br><span class="line">            .....</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ......</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>DataSourcePoolMetadataProvidersConfiguration是数据库连接池提供者的一个配置类，即Classpath中存在org.apache.tomcat.jdbc.pool.DataSource.class，则使用tomcat-jdbc连接池，如果Classpath中存在HikariDataSource.class则使用Hikari连接池。</p>
<p>这里仅描述了DataSourceAutoConfiguration的冰山一角，但足以说明Spring Boot如何利用条件话配置来实现自动配置的。</p>
<p>回顾一下，@EnableAutoConfiguration中导入了EnableAutoConfigurationImportSelector类，而这个类的selectImports()通过SpringFactoriesLoader得到了大量的配置类，而每一个配置类则根据条件化配置来做出决策，以实现自动配置。</p>
<p>整个流程很清晰，但漏了一个大问题：</p>
<p>EnableAutoConfigurationImportSelector.selectImports()是何时执行的？其实这个方法会在容器启动过程中执行：AbstractApplicationContext.refresh()。</p>
<h2 id="六、启动引导"><a href="#六、启动引导" class="headerlink" title="六、启动引导"></a>六、启动引导</h2><h3 id="SpringApplication初始化"><a href="#SpringApplication初始化" class="headerlink" title="SpringApplication初始化"></a>SpringApplication初始化</h3><p>SpringBoot整个启动流程分为两个步骤：</p>
<ol>
<li><p>初始化一个SpringApplication对象</p>
</li>
<li><p>执行该对象的run方法</p>
</li>
</ol>
<p>看下SpringApplication的初始化流程，SpringApplication的构造方法中调用initialize(Object[] sources)方法，其代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(Object[] sources)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (sources != <span class="literal">null</span> &amp;&amp; sources.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="built_in">this</span>.sources.addAll(Arrays.asList(sources));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 判断是否是Web项目</span></span><br><span class="line">      <span class="built_in">this</span>.webEnvironment = deduceWebEnvironment();</span><br><span class="line">      setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">      setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">      <span class="comment">// 找到入口类</span></span><br><span class="line">      <span class="built_in">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>初始化流程中最重要的就是通过SpringFactoriesLoader找到spring.factories文件中配置的ApplicationContextInitializer和ApplicationListener两个接口的实现类名称，以便后期构造相应的实例。</p>
<p>ApplicationContextInitializer的主要目的是在ConfigurableApplicationContext做refresh之前，对ConfigurableApplicationContext实例做进一步的设置或处理。</p>
<p>ConfigurableApplicationContext继承自ApplicationContext，其主要提供了对ApplicationContext进行设置的能力。</p>
<p>实现一个ApplicationContextInitializer非常简单，因为它只有一个方法，但大多数情况下我们没有必要自定义一个ApplicationContextInitializer，即便是Spring Boot框架，它默认也只是注册了两个实现，毕竟Spring的容器已经非常成熟和稳定，你没有必要来改变它。</p>
<p>而ApplicationListener的目的就没什么好说的了，它是Spring框架对Java事件监听机制的一种框架实现，具体内容在前文Spring事件监听机制这个小节有详细讲解。这里主要说说，如果你想为Spring Boot应用添加监听器，该如何实现。</p>
<p>Spring Boot提供两种方式来添加自定义监听器：</p>
<p>通过**SpringApplication.addListeners(ApplicationListener… listeners)<strong>或者</strong>SpringApplication.setListeners(Collection&gt; listeners)**两个方法来添加一个或者多个自定义监听器</p>
<p>既然SpringApplication的初始化流程中已经从spring.factories中获取到ApplicationListener的实现类，那么我们直接在自己的jar包的META-INF&#x2F;spring.factories文件中新增配置即可：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.springframework.context.ApplicationListener</span>=<span class="string">\ cn.moondev.listeners.xxxxListener\</span></span><br></pre></td></tr></table></figure>

<h3 id="Spring-Boot启动流程"><a href="#Spring-Boot启动流程" class="headerlink" title="Spring Boot启动流程."></a>Spring Boot启动流程.</h3><p>Spring Boot应用的整个启动流程都封装在SpringApplication.run方法中，其整个流程真的是太长太长了，但本质上就是在Spring容器启动的基础上做了大量的扩展，按照这个思路来看看</p>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">         <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">         stopWatch.start();</span><br><span class="line">         <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">         <span class="type">FailureAnalyzers</span> <span class="variable">analyzers</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">         configureHeadlessProperty();</span><br><span class="line">         <span class="comment">// ①</span></span><br><span class="line">         <span class="type">SpringApplicationRunListeners</span> <span class="variable">listeners</span> <span class="operator">=</span> getRunListeners(args);</span><br><span class="line">         listeners.starting();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="comment">// ②</span></span><br><span class="line"><span class="type">ApplicationArguments</span> <span class="variable">applicationArguments</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultApplicationArguments</span>(args);</span><br><span class="line">             <span class="type">ConfigurableEnvironment</span> <span class="variable">environment</span> <span class="operator">=</span> prepareEnvironment(listeners,applicationArguments);</span><br><span class="line">             <span class="comment">// ③</span></span><br><span class="line">             <span class="type">Banner</span> <span class="variable">printedBanner</span> <span class="operator">=</span> printBanner(environment);</span><br><span class="line">             <span class="comment">// ④</span></span><br><span class="line">             context = createApplicationContext();</span><br><span class="line">             <span class="comment">// ⑤</span></span><br><span class="line">             analyzers = <span class="keyword">new</span> <span class="title class_">FailureAnalyzers</span>(context);</span><br><span class="line">             <span class="comment">// ⑥</span></span><br><span class="line">             prepareContext(context, environment, listeners, applicationArguments,printedBanner);</span><br><span class="line">             <span class="comment">// ⑦</span></span><br><span class="line">              refreshContext(context);</span><br><span class="line">             <span class="comment">// ⑧</span></span><br><span class="line">             afterRefresh(context, applicationArguments);</span><br><span class="line">             <span class="comment">// ⑨</span></span><br><span class="line">             listeners.finished(context, <span class="literal">null</span>);</span><br><span class="line">             stopWatch.stop();</span><br><span class="line">             <span class="keyword">return</span> context;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">             handleRunFailure(context, listeners, analyzers, ex);</span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(ex);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>① 通过SpringFactoriesLoader查找并加载所有的SpringApplicationRunListeners通过调用starting()方法通知所有的SpringApplicationRunListeners：应用开始启动了。</p>
<p>SpringApplicationRunListeners其本质上就是一个事件发布者，它在SpringBoot应用启动的不同时间点发布不同应用事件类型(ApplicationEvent)，如果有哪些事件监听者(ApplicationListener)对这些事件感兴趣，则可以接收并且处理。还记得初始化流程中，SpringApplication加载了一系列ApplicationListener吗？这个启动流程中没有发现有发布事件的代码，其实都已经在SpringApplicationRunListeners这儿实现了。</p>
<p>简单的分析一下其实现流程，首先看下SpringApplicationRunListener的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SpringApplicationRunListener</span> &#123;</span><br><span class="line">     <span class="comment">// 运行run方法时立即调用此方法，可以用户非常早期的初始化工作</span></span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">starting</span><span class="params">()</span>;</span><br><span class="line">     <span class="comment">// Environment准备好后，并且ApplicationContext创建之前调用</span></span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">environmentPrepared</span><span class="params">(ConfigurableEnvironment environment)</span>;</span><br><span class="line">     <span class="comment">// ApplicationContext创建好后立即调用</span></span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">contextPrepared</span><span class="params">(ConfigurableApplicationContext context)</span>;</span><br><span class="line">     <span class="comment">// ApplicationContext加载完成，在refresh之前调用</span></span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">contextLoaded</span><span class="params">(ConfigurableApplicationContext context)</span>;</span><br><span class="line">     <span class="comment">// 当run方法结束之前调用</span></span><br><span class="line">     <span class="keyword">void</span> <span class="title function_">finished</span><span class="params">(ConfigurableApplicationContext</span></span><br><span class="line"><span class="params"> context, Throwable exception)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SpringApplicationRunListener只有一个实现类：EventPublishingRunListener。</p>
<p>①处的代码只会获取到一个EventPublishingRunListener的实例</p>
<p>我们来看看starting()方法的内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">starting</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="comment">// 发布一个ApplicationStartedEvent</span></span><br><span class="line">     <span class="built_in">this</span>.initialMulticaster.multicastEvent(<span class="keyword">new</span> <span class="title class_">ApplicationStartedEvent</span>(<span class="built_in">this</span>.application, <span class="built_in">this</span>.args));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>顺着这个逻辑，你可以在②处的prepareEnvironment()方法的源码中找到</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listeners.environmentPrepared(environment);</span><br></pre></td></tr></table></figure>

<p>即SpringApplicationRunListener接口的第二个方法，那不出你所料，environmentPrepared()又发布了另外一个事件ApplicationEnvironmentPreparedEvent。</p>
</li>
<li><p>② 创建并配置当前应用将要使用的Environment，Environment用于描述应用程序当前的运行环境，其抽象了两个方面的内容：配置文件(profile)和属性(properties)，开发经验丰富的同学对这两个东西一定不会陌生：不同的环境(eg：生产环境、预发布境)可以使用不同的配置文件，而属性则可以从配置文件、环境变量、命令行参数等来源获取。因此，当Environment准备好后，在整个应用的任何时候，都可以从Environment中获取资源。</p>
<blockquote>
<p>总结起来，②处的两句代码，主要完成以下几件事：</p>
<ul>
<li>判断Environment是否存在，不存在就创建（如果是web项目就创建StandardServletEnvironment，否则创建StandardEnvironment）</li>
<li>配置Environment：配置profile以及properties</li>
<li>调用SpringApplicationRunListener的environmentPrepared()方法，通知事件监听者：应用的Environment已经准备好</li>
</ul>
</blockquote>
</li>
<li><p>③SpringBoot应用在启动时会输出这样的东西：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">. ____          _            __ _ _</span><br><span class="line">  /\\ / ___&#x27;_ __ _ _(_)_ __ __ _ \ \ \ \</span><br><span class="line"> ( ( )\___ | &#x27;_ | &#x27;_| | &#x27;_ \/ _` | \ \ \ \</span><br><span class="line">  \\/ ___)| |_)| | | | | || (_| | ) ) ) )</span><br><span class="line">   &#x27; |____| .__|_| |_|_| |_\__, | / / / /</span><br><span class="line">  =========|_|==============|___/=/_/_/_/</span><br><span class="line"> :: Spring Boot :: (v1.5.6.RELEASE)</span><br></pre></td></tr></table></figure>

<p>如果想把这个东西改成自己的涂鸦，你可以研究一下Banner的实现。</p>
</li>
<li><p>④根据是否是web项目，来创建不同的ApplicationContext容器。</p>
</li>
<li><p>⑤创建一系列FailureAnalyzer，创建流程依然是通过SpringFactoriesLoader获取到所有实现FailureAnalyzer接口的class，然后在创建对应的实例。FailureAnalyzer用于分析故障并提供相关诊断信息。</p>
</li>
<li><p>⑥初始化ApplicationContext，主要完成以下工作：</p>
<ul>
<li>将准备好的Environment设置给ApplicationContext</li>
<li>遍历调用所有的ApplicationContextInitializer的initialize()方法来对已经创建好的ApplicationContext进行进一步的处理</li>
<li>调用SpringApplicationRunListener的contextPrepared()方法，通知所有的监听者：ApplicationContext已经准备完毕</li>
<li>将所有的bean加载到容器中</li>
<li>调用SpringApplicationRunListener的contextLoaded()方法，通知所有的监听者：ApplicationContext已经装载完毕</li>
</ul>
</li>
<li><p>⑦调用ApplicationContext的refresh()方法，完成IoC容器可用的最后一道工序。</p>
<p>那如何刷新呢？且看下面代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 摘自refresh()方法中一句代码</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br></pre></td></tr></table></figure>

<p>看看这个方法的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">invokeBeanFactoryPostProcessors</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">     PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());</span><br><span class="line">     ......</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>获取到所有的BeanFactoryPostProcessor来对容器做一些额外的操作。</p>
<p>BeanFactoryPostProcessor允许我们在容器实例化相应对象之前，对注册到容器的BeanDefinition所保存的信息做一些额外的操作。</p>
<p>这里的getBeanFactoryPostProcessors()方法可以获取到3个Processor：</p>
<ul>
<li>ConfigurationWarningsApplicationContextInitializer$ConfigurationWarningsPostProcessor</li>
<li>SharedMetadataReaderFactoryContextInitializer$CachingMetadataReaderFactoryPostProcessor</li>
<li>ConfigFileApplicationListener$PropertySourceOrderingPostProcessor</li>
</ul>
<p>不是有那么多BeanFactoryPostProcessor的实现类，为什么这儿只有这3个？</p>
<p>因为在初始化流程获取到的各种ApplicationContextInitializer和ApplicationListener中，只有上文3个做了类似于如下操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(ConfigurableApplicationContext context)</span> &#123;</span><br><span class="line">     context.addBeanFactoryPostProcessor(<span class="keyword">new</span> <span class="title class_">ConfigurationWarningsPostProcessor</span>(getChecks()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后你就可以进入到PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors()方法了，这个方法除了会遍历上面的3个BeanFactoryPostProcessor处理外，还会获取类型为BeanDefinitionRegistryPostProcessor的bean：org.springframework.context.annotation.internalConfigurationAnnotationProcessor，对应的Class为ConfigurationClassPostProcessor。ConfigurationClassPostProcessor用于解析处理各种注解，包括：@Configuration、@ComponentScan、@Import、@PropertySource、@ImportResource、@Bean。当处理@import注解的时候，就会调用这一小节中的EnableAutoConfigurationImportSelector.selectImports()来完成自动配置功能。其他的这里不再多讲，如果你有兴趣，可以查阅参考资料6。</p>
</li>
<li><p>⑧查找当前context中是否注册有CommandLineRunner和ApplicationRunner，如果有则遍历执行它们。</p>
</li>
<li><p>⑨执行所有SpringApplicationRunListener的finished()方法。这就是Spring Boot的整个启动流程，其核心就是在Spring容器初始化并启动的基础上加入各种扩展点，这些扩展点包括：ApplicationContextInitializer、<strong>ApplicationListener以及各种BeanFactoryPostProcessor等等。</strong></p>
</li>
</ul>
<blockquote>
<p>你对整个流程的细节不必太过关注，甚至没弄明白也没有关系，你只要理解这些扩展点是在何时如何工作的，能让它们为你所用即可。整个启动流程确实非常复杂，可以查询参考资料中的部分章节和内容，对照着源码，多看看，我想最终你都能弄清楚的。<strong>言而总之</strong>，Spring才是核心，理解清楚Spring容器的启动流程，那Spring Boot启动流程就不在话下了。</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://fabian4.site/blog">Fabian Bao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://fabian4.site/blog/26822.html">https://fabian4.site/blog/26822.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://fabian4.site/blog" target="_blank">Hourglass</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/blog/tags/Java/">Java</a><a class="post-meta__tags" href="/blog/tags/SpringBoot/">SpringBoot</a></div><div class="post_share"><div class="social-share" data-image="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/NVO8hr3XDt7c56A.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blog/51833.html"><img class="prev-cover" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/bKJAquvenOPl6Ng.jpg" onerror="onerror=null;src='/blog/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计算机组成与结构大纲</div></div></a></div><div class="next-post pull-right"><a href="/blog/49869.html"><img class="next-cover" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/zHGp7behEU6qYBD.jpg" onerror="onerror=null;src='/blog/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SpringBoot 的最佳实践解读</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/blog/56408.html" title="Spring Boot 笔记"><img class="cover" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/1ncfhPdosVSEkZb.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-15</div><div class="title">Spring Boot 笔记</div></div></a></div><div><a href="/blog/49869.html" title="SpringBoot 的最佳实践解读"><img class="cover" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/zHGp7behEU6qYBD.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-22</div><div class="title">SpringBoot 的最佳实践解读</div></div></a></div><div><a href="/blog/24594.html" title="SpringBoot 的切面日志配置"><img class="cover" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/oQcqPG4DpUfrV86.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-29</div><div class="title">SpringBoot 的切面日志配置</div></div></a></div><div><a href="/blog/11717.html" title="SpringBoot 日志配置"><img class="cover" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/d9JG86X4ryqSDxp.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-25</div><div class="title">SpringBoot 日志配置</div></div></a></div><div><a href="/blog/62781.html" title="JAVA 8 新特性"><img class="cover" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/MYxEQ51GWCyp8R9.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-02</div><div class="title">JAVA 8 新特性</div></div></a></div><div><a href="/blog/6499.html" title="JAVA 多线程编程"><img class="cover" src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/DBQoWytONRSr5I3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-25</div><div class="title">JAVA 多线程编程</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://fabian4.site/avatar.png" onerror="this.onerror=null;this.src='/blog/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Fabian Bao</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">73</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">54</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">The best is yet to come</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringBoot-%E5%B9%B2%E8%B4%A7%E6%80%BB%E7%BB%93"><span class="toc-number">1.</span> <span class="toc-text">SpringBoot 干货总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81IOC%E5%AE%B9%E5%99%A8"><span class="toc-number">1.1.</span> <span class="toc-text">一、IOC容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanDefinition-%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.1.</span> <span class="toc-text">BeanDefinition 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IOC%E5%AE%B9%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">IOC容器工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E5%AE%B9%E5%99%A8%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.3.</span> <span class="toc-text">Spring容器扩展机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81JavaConfig%E4%B8%8E%E5%B8%B8%E8%A7%81Annotation"><span class="toc-number">1.2.</span> <span class="toc-text">二、JavaConfig与常见Annotation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaConfig"><span class="toc-number">1.2.1.</span> <span class="toc-text">JavaConfig</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ComponentScan"><span class="toc-number">1.2.2.</span> <span class="toc-text">@ComponentScan</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Import"><span class="toc-number">1.2.3.</span> <span class="toc-text">@Import</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Conditional"><span class="toc-number">1.2.4.</span> <span class="toc-text">@Conditional</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConfigurationProperties%E4%B8%8E-EnableConfigurationProperties"><span class="toc-number">1.2.5.</span> <span class="toc-text">@ConfigurationProperties与@EnableConfigurationProperties</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81SpringFactoriesLoader%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.3.</span> <span class="toc-text">三、SpringFactoriesLoader详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Spring%E5%AE%B9%E5%99%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.</span> <span class="toc-text">四、Spring容器的事件监听机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">五、自动配置原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%90%AF%E5%8A%A8%E5%BC%95%E5%AF%BC"><span class="toc-number">1.6.</span> <span class="toc-text">六、启动引导</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringApplication%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.6.1.</span> <span class="toc-text">SpringApplication初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Boot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">1.6.2.</span> <span class="toc-text">Spring Boot启动流程.</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/blog/55079.html" title="Mysql 执行流程和日志系统"><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/Hatshepsut_ZH-CN4516192627_1920x1080.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="Mysql 执行流程和日志系统"/></a><div class="content"><a class="title" href="/blog/55079.html" title="Mysql 执行流程和日志系统">Mysql 执行流程和日志系统</a><time datetime="2021-05-14T16:00:00.000Z" title="发表于 2021-05-15 00:00:00">2021-05-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/47132.html" title="Mysql 锁机制"><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/Italica_ZH-CN1692906751_1920x1080.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="Mysql 锁机制"/></a><div class="content"><a class="title" href="/blog/47132.html" title="Mysql 锁机制">Mysql 锁机制</a><time datetime="2021-04-24T16:00:00.000Z" title="发表于 2021-04-25 00:00:00">2021-04-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/10729.html" title="Mysql 隔离级别与MVCC"><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/CuscoCathedral_ZH-CN9834821723_1920x1080.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="Mysql 隔离级别与MVCC"/></a><div class="content"><a class="title" href="/blog/10729.html" title="Mysql 隔离级别与MVCC">Mysql 隔离级别与MVCC</a><time datetime="2021-04-19T16:00:00.000Z" title="发表于 2021-04-20 00:00:00">2021-04-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/58885.html" title="数据库四大性质和隔离等级"><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/ContainerShip_ZH-CN0850122021_1920x1080.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="数据库四大性质和隔离等级"/></a><div class="content"><a class="title" href="/blog/58885.html" title="数据库四大性质和隔离等级">数据库四大性质和隔离等级</a><time datetime="2021-04-07T16:00:00.000Z" title="发表于 2021-04-08 00:00:00">2021-04-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/5986.html" title="HashMap、HashTable和ConcurrentHashMap"><img src="https://fabian.oss-cn-hangzhou.aliyuncs.com/img/HallstattAustria_PT-BR9407016733_1920x1080.jpg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="HashMap、HashTable和ConcurrentHashMap"/></a><div class="content"><a class="title" href="/blog/5986.html" title="HashMap、HashTable和ConcurrentHashMap">HashMap、HashTable和ConcurrentHashMap</a><time datetime="2021-04-02T16:00:00.000Z" title="发表于 2021-04-03 00:00:00">2021-04-03</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://fabian.oss-cn-hangzhou.aliyuncs.com/img/NVO8hr3XDt7c56A.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Fabian Bao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/blog/js/utils.js"></script><script src="/blog/js/main.js"></script><script src="/blog/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '98fe0206dedd0d2caf96',
      clientSecret: '5f2816f58a108f15feba46f9bc88497d3d6457a4',
      repo: 'hexo-blog',
      owner: 'fabian4',
      admin: ['fabian4'],
      id: '56b98fc66e3ca376d87c808f05db2b05',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start -->
  <script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://python-github-calendar-api.vercel.app/api?fabian4";
            var git_color =['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f'];
            var git_user ="fabian4";
            var parent_div_git = document.getElementById('page');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/about/'){
                console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('page')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style><!-- hexo injector body_end end --></body></html>